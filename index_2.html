<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>R Data Science - Kapitel 2</title>

<script src="site_libs/header-attrs-2.24/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">My Website</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="bbb1.html">1. Grundlagen Programmierung mit R</a>
</li>
<li>
  <a href="index_2.html">2. Data Science mit R</a>
</li>
<li>
  <a href="index_3.html">3. Machine Learning</a>
</li>
<li>
  <a href="index_4.html">4. Projekte mit R</a>
</li>
<li>
  <a href="test_markdown.html">Testen</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">R Data Science - Kapitel 2</h1>

</div>


<div id="einleitung" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Einleitung</h1>
<p>Im ersten Teil haben wir die wichtigsten Konzepte kennengelernt. Es
wurde ein wenig theoretischer und wir haben viel über R kennengelernt.
Ich möchte Teil 1 ein wenig mit der Grundgrammatik vergleichen.<br />
In Teil 2 geht es um <strong>Data Science</strong>. Hier lernen wir dia
Anwendung kennen, mehr Vokabeln, mehr Spaß?<br />
Wir werden sehen.</p>
<div id="was-lernen-wir" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Was lernen wir?</h2>
<p>In einem typischen Data Science Projekt haben wir folgende
Schritte:</p>
<p>Zuerst müssen wir die Daten importieren. Aus einer Datei oder dem
Netz oder einer Datenbank für gewöhnlich, so dass wir eine schöne,
übersichtliche Tabelle haben. Im besten Fall versteht sich.</p>
<p>Danach muss aufgeräumt werden. Spalten mit Variablen und Zeilen mit
Beobachtungen liegen uns vor, so dass wir uns im weiteren nicht mehr um
nervige Aufräumarbeit kümmern müssen.</p>
<p>Haben wir aufgeräumt, so werden die Daten transformiert. Relevante
Variablen werden zusammengefasst, neue Variablen entstehen aus alten
durch Funktionen, <em>summary statistics</em> werden berechnet.
Aufräumen und Transformation nennen wir zusammen:
<em>Wrangling</em>.</p>
<p>Danach wird es spannend: Visualisation und Modelle erstellen steht im
Vordergrund. Eine Grafik sagt mehr als 1000 Worte. Richtig romantisch,
oder?</p>
<p>Kommunikation folgt dann. Kommuniziere deine Ergebnisse zu Anderen.
Dies wird oft vernachlässigt, ist aber nicht immer so leicht wie man
denkt.</p>
<p>Umfasst werden all diese Werkzeuge von der Programmierung. Um ein
erfolgreicher Data Scientist zu sein, musst du nicht auch ein Experte in
Sachen Programmierung sein. Aber ein besserer Programmierer zu sein
hilft, da es dir erlaubt viele Aufgaben zu automatisieren und erheblich
zu beschleunigen.</p>
</div>
<div id="voraussetzungen" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Voraussetzungen</h2>
<p>Es hilft natürlich sich mit den wichtigsten Konzepten von Teil 1
auseinandergesetzt zu haben. Neben R und RStudio brauchen wir noch das
<strong>tidyverse</strong> Paket und viele weitere.</p>
<div id="tidyverse" class="section level3" number="1.2.1">
<h3><span class="header-section-number">1.2.1</span> tidyverse</h3>
<p>Ein Paket ist eine Kollektion von Funktionen, Daten und
Dokumentationen von R. Funktionen in R zu nutzen ist das Erfolgsgeheimis
von R.<br />
Die meisten Pakete, die wir hier kennenlernen sind Teil vom
<code>tidyverse</code> Paket. Mit einer Zeile Code kannst du
<code>tidyverse</code> installieren.</p>
<pre class="r"><code>install.packages(&quot;tidyverse&quot;)</code></pre>
<p>Anschließend musst du natürlich noch das Paket laden:</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<pre><code>## Warning: Paket &#39;tidyverse&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;ggplot2&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;tibble&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;dplyr&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;stringr&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;lubridate&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──
## ✔ dplyr     1.1.1     ✔ readr     2.1.4
## ✔ forcats   1.0.0     ✔ stringr   1.5.0
## ✔ ggplot2   3.4.1     ✔ tibble    3.2.1
## ✔ lubridate 1.9.2     ✔ tidyr     1.3.0
## ✔ purrr     1.0.1     
## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ dplyr::filter() masks stats::filter()
## ✖ dplyr::lag()    masks stats::lag()
## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
<p>So gehen wir immer vor, wenn Pakete benötigt werden. Sie erleichtern
uns die Arbeit. Acht Pakete werden hier auf einmal geladen:
<strong>ggplot2</strong>, <strong>tibble</strong>,
<strong>tidyr</strong>, <strong>readr</strong>, <strong>purrr</strong>,
<strong>dplyr</strong>, <strong>stringr</strong> und
<strong>forcats</strong>. Bei fast jeder Analyse brauchst du sie.</p>
</div>
<div id="weitere-pakete" class="section level3" number="1.2.2">
<h3><span class="header-section-number">1.2.2</span> Weitere Pakete</h3>
<p>In diesem Teil brauchen wir wahrscheinlich noch drei weitere
Pakete:</p>
<pre class="r"><code>install.packages(c(&quot;nycflights13&quot;, &quot;gapminder&quot;, &quot;Lahman&quot;))</code></pre>
<pre class="r"><code>library(nycflights13)</code></pre>
<pre><code>## Warning: Paket &#39;nycflights13&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre class="r"><code>library(gapminder)</code></pre>
<pre><code>## Warning: Paket &#39;gapminder&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre class="r"><code>library(Lahman)</code></pre>
<pre><code>## Warning: Paket &#39;Lahman&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<p>Sie liefern uns Daten.</p>
</div>
</div>
</div>
<div id="daten-visualisieren" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Daten
visualisieren</h1>
<p>In diesem Kapitel fokusieren wir uns auf <code>ggplot2</code>. Das
Paket haben wir schon über <code>library(tidyverse)</code> geladen.
Falls nicht, holen wir dies schnell nach.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<p>Ein Paket musst du nur einmal installieren, es aber bei jeder neuen
Session wieder laden. Hinzo kommen jetzt Daten von Pinguinen.</p>
<pre class="r"><code>install.packages(&quot;palmerpenguins&quot;)</code></pre>
<pre class="r"><code>library(palmerpenguins)</code></pre>
<pre><code>## Warning: Paket &#39;palmerpenguins&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<div id="fragen" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Fragen</h2>
<p>Gibt es einen Zusammenhang zwischen der Flossenlänge eines Pinguins
und seinem Gewicht? Wie sieht dieser Zusammenhang aus? Hängt er von der
Spezie der Pinguine ab? Und vielleicht sogar von der Herkunft der
Pinguine?</p>
<div id="penguins-data-frame" class="section level3" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span>
<code>penguins</code> data frame</h3>
<p>Dieser Datensatz enthält 344 Zeilen und 7 Spalten.</p>
<p>Einen alternativen Blick kannst du mit <code>glimpse()</code> auf die
Daten werfen. Oder mit <code>View(penguins)</code>.</p>
<pre class="r"><code>glimpse(penguins)</code></pre>
<pre><code>## Rows: 344
## Columns: 8
## $ species           &lt;fct&gt; Adelie, Adelie, Adelie, Adelie, Adelie, Adelie, Adel…
## $ island            &lt;fct&gt; Torgersen, Torgersen, Torgersen, Torgersen, Torgerse…
## $ bill_length_mm    &lt;dbl&gt; 39.1, 39.5, 40.3, NA, 36.7, 39.3, 38.9, 39.2, 34.1, …
## $ bill_depth_mm     &lt;dbl&gt; 18.7, 17.4, 18.0, NA, 19.3, 20.6, 17.8, 19.6, 18.1, …
## $ flipper_length_mm &lt;int&gt; 181, 186, 195, NA, 193, 190, 181, 195, 193, 190, 186…
## $ body_mass_g       &lt;int&gt; 3750, 3800, 3250, NA, 3450, 3650, 3625, 4675, 3475, …
## $ sex               &lt;fct&gt; male, female, female, NA, female, male, female, male…
## $ year              &lt;int&gt; 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007, 2007…</code></pre>
<p><code>species</code>, <code>flipper_length_mm</code> und
<code>body_mass_g</code> gehören zu den Variablen. Mehr Infos unter
<code>?penguins</code>.</p>
<p>Wir wollen jetzt das Gewicht in Abhängigkeit von der Flossenlänge
darstellen. Für alle drei Spezien getrennt.</p>
</div>
<div id="ggplot-erstellen" class="section level3" number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> <code>ggplot</code>
erstellen</h3>
<p>Das erste Argument von <code>ggplot()</code> ist der Datensatz.</p>
<pre class="r"><code>ggplot(data = penguins)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>Es entsteht ein leerer Graph. Wir brauchen natürlich noch die
Variablen.<br />
Das <code>mapping</code> Argument der <code>ggplot()</code> Funktion
definiert wie Variablen abgebildet werden, um sie zu visualisieren. Es
kommt immer mit der <code>aes()</code> Funktion und den <code>x</code>
und <code>y</code> Argumenten von <code>aes()</code> daher.<br />
Bei uns soll die Flossenlänge auf der x-Achse sein und der Body Maß auf
der y-Achse.</p>
<pre class="r"><code>ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<pre class="r"><code>ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, y = body_mass_g))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-10-2.png" width="672" /></p>
<p>Unsere leere Leinwand wurde jetzt ein wenig gefüllt. Aber wo sind die
Pinguine? Noch nicht da, weil wir noch nicht gesagt haben wie die
Beobachtungen auf den Plot angewendet werden sollen. Um das zu machen
müssen wir ein <strong>geom</strong> definieren. Dieses Objekt benutzt
einen Plot um Daten zu repräsentieren. Oftmals wird der Typ des Plots an
<code>geom_</code> angehängt wie z.B. <code>geom_bar</code>,
<code>geom_line</code>, <code>geom_boxplot</code> oder
<code>geom_point</code>.<br />
Mithilfe von <code>geom_point</code> werden Punkte zum Plot hinzugefügt,
so dass ein Scatterplot entsteht. Insgesamt gibt es sehr viele
<em>geom</em> Funktionen.</p>
<pre class="r"><code>ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<p>Wir haben einen einigermaßen linearen, positiven Zusammenhang.
Genauso wie erwartet zwischen Flossenlänge und Gewicht. Nur die
verschiedenen Spezien fehlen noch.<br />
Eine Fehlermeldung wurde aber auch noch ausgegeben. Hier fehlen 2 Werte,
siehe Tabelle oder hier (der Code ist neu für uns. Keine Sorge,
Erklärung kommt noch).</p>
<pre class="r"><code>penguins |&gt;
  select(species, flipper_length_mm, body_mass_g) |&gt;
  filter(is.na(body_mass_g) | is.na(flipper_length_mm))</code></pre>
<pre><code>## # A tibble: 2 × 3
##   species flipper_length_mm body_mass_g
##   &lt;fct&gt;               &lt;int&gt;       &lt;int&gt;
## 1 Adelie                 NA          NA
## 2 Gentoo                 NA          NA</code></pre>
<p><em>Missing Values</em> haben ihre Daseinsberechtigung. Kein
Witz.</p>
</div>
<div id="hinzufügen-von-aesthetics-und-layers" class="section level3"
number="2.1.3">
<h3><span class="header-section-number">2.1.3</span> Hinzufügen von
<em>aesthetics</em> und <em>layers</em></h3>
<p>Den Zusammenhang zwischen zwei Variablen darzustellen ist schön und
gut. Doch oftmals fragt man sich, ob es nicht noch weitere Variablen
gibt, die den Zusammenhang erklären oder ändern.<br />
In unserem Beispiel nehmen wir noch die Spezie hinzu. Aber wo genau? In
das <em>aesthetic mapping</em>, in die <code>aes()</code> Funktion.</p>
<pre class="r"><code>ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, y = body_mass_g,
                     color = species)) +
  geom_point()</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>Da eine weitere Variable in das <code>aes()</code> aufgenommen wurde,
hat <code>ggplot2</code> dieser automatisch einen einzigartigen Wert
zugewiesen, hier eine eine Farbe jedem Level der Variable. Das nennt
sich <strong>scaling</strong>. Auch eine Legende wurde automatisch
hinzugefügt. Weitere Schichten (<em>layers</em>) sind möglich.<br />
Zum Beispiel eine glatte Kurve, die den Zusammenhang anschaulich
wiedergibt. Ein neues <em>geom</em> wird hinzugefügt:
<code>geom_smooth()</code>.</p>
<pre class="r"><code>ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, y = body_mass_g,
                     color = species)) +
  geom_point() +
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>Wir wollen aber nur eine Kurve für alle Spezien zusammen. Wie geht
das denn?</p>
<p>Wir haben aes mappings in <code>ggplot()</code> definiert, im
globalen Level. Jetzt werden sie weiter vererbt von jeder folgenden
<em>geom</em> Schicht des Plots. Wir können aber jeder <em>geom</em>
Funktion in <code>ggplot2</code> ein lokales <code>mapping</code>
verpassen. Wollen wir farbige Punkte für die verschiedenen Spezien, aber
eine Kurve für alle, so können wir nur für die Punkte
<code>geom_point()</code> eine Unterscheidung vornehmen, durch
<code>color = species</code>.</p>
<pre class="r"><code>ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(mapping = aes(color = species)) +
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>So gefällt uns das doch schon viel besser. Uns reichen verschiedene
Farben aber nicht aus. Wir wollen auch verschiedene Symbole. Es gibt
auch Farbenblinde, auch an die denken wir jetzt einmal.</p>
<p>Zusätzlich können wir auch <code>species</code> zum
<code>shape</code> <em>aes</em> hinzufügen.</p>
<pre class="r"><code>ggplot(data = penguins,
       mapping = aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(mapping = aes(color = species, shape = species)) +
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Als weitere Schicht können wir noch die <code>labs()</code> Funktion
hinzufügen. Alles (<em>Labels</em>) sieht dann noch schöner aus.</p>
<pre class="r"><code>ggplot(penguins, 
       aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species)) +
  geom_smooth() +
  labs(
    title = &quot;Body mass and flipper length&quot;,
    subtitle = &quot;Dimensions for Adelie, Chinstrap, and Gentoo Penguins&quot;,
    x = &quot;Flipper length (mm)&quot;, 
    y = &quot;Body mass (g)&quot;,
    color = &quot;Species&quot;, 
    shape = &quot;Species&quot;
  )</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_smooth()`).</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>Die Ausdrücke <code>data = penguins</code> und
<code>mapping = aes()</code> können wir auch verkürzen zu
<code>penguins</code> und <code>aes()</code>.</p>
<pre class="r"><code>ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()</code></pre>
<p>Später lernen wir die <em>Pipe</em> kennen, dann können wir weiter
vereinfachen.</p>
<pre class="r"><code>penguins |&gt; 
  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + 
  geom_point()</code></pre>
</div>
</div>
<div id="verteilungen-visualisieren" class="section level2"
number="2.2">
<h2><span class="header-section-number">2.2</span> Verteilungen
visualisieren</h2>
<p>Die Visualisierung hängt natürlich vom Datentyp bzw. dem Skalenniveau
ab: kategorial oder numerisch.</p>
<div id="kategoriale-variable" class="section level3" number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> kategoriale
Variable</h3>
<p>Für kategoriale Variablen bietet sich ein <em>bar chart</em> an, ein
Säulendiagramm. Es zählt die Häufigkeit der Variable <code>x</code>.</p>
<pre class="r"><code>ggplot(penguins, aes(x = species)) +
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<p>Die Reihenfolge wird oft durch das Alphabet vorgenommen, kann aber
nach Häufigkeit vorgenommen werden. Dafür müssen wir aber die Variable
zu einem Faktor transformieren. Danach können wir neu sortieren.</p>
<pre class="r"><code>ggplot(penguins, aes(x = fct_infreq(species))) +
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Mehr dazu später.</p>
</div>
<div id="numerische-variable" class="section level3" number="2.2.2">
<h3><span class="header-section-number">2.2.2</span> Numerische
Variable</h3>
<p>Um die Verteilung einer stetigen Variable zu visualisieren, benutze
ein Histogramm oder einen <em>density</em> (Dichte) <em>plot</em>.</p>
<pre class="r"><code>ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 200)</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_bin()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-22-1.png" width="672" /></p>
<pre class="r"><code>ggplot(penguins, aes(x = body_mass_g)) +
  geom_density()</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_density()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-22-2.png" width="672" /></p>
<p>Wir sehen, dass 39 Pinguine ein Gewicht zwischen 3500 g und 3700 g
haben (Klassengrenzen, Klassenbreite = 200).</p>
<pre class="r"><code>penguins |&gt;
  count(cut_width(body_mass_g, 200))</code></pre>
<pre><code>## # A tibble: 19 × 2
##    `cut_width(body_mass_g, 200)`     n
##    &lt;fct&gt;                         &lt;int&gt;
##  1 [2.7e+03,2.9e+03]                 7
##  2 (2.9e+03,3.1e+03]                10
##  3 (3.1e+03,3.3e+03]                23
##  4 (3.3e+03,3.5e+03]                38
##  5 (3.5e+03,3.7e+03]                39
##  6 (3.7e+03,3.9e+03]                37
##  7 (3.9e+03,4.1e+03]                28
##  8 (4.1e+03,4.3e+03]                25
##  9 (4.3e+03,4.5e+03]                20
## 10 (4.5e+03,4.7e+03]                22
## 11 (4.7e+03,4.9e+03]                21
## 12 (4.9e+03,5.1e+03]                17
## 13 (5.1e+03,5.3e+03]                13
## 14 (5.3e+03,5.5e+03]                14
## 15 (5.5e+03,5.7e+03]                16
## 16 (5.7e+03,5.9e+03]                 6
## 17 (5.9e+03,6.1e+03]                 5
## 18 (6.1e+03,6.3e+03]                 1
## 19 &lt;NA&gt;                              2</code></pre>
<p>Probiere verschiedene Bandbreiten aus, um das anschaulichste
Histogramm zu erhalten.</p>
<pre class="r"><code>ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 20)</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_bin()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<pre class="r"><code>ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 200)</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_bin()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-24-2.png" width="672" /></p>
<pre class="r"><code>ggplot(penguins, aes(x = body_mass_g)) +
  geom_histogram(binwidth = 2000)</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_bin()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-24-3.png" width="672" /></p>
</div>
</div>
<div id="zusammenhänge-visualisieren" class="section level2"
number="2.3">
<h2><span class="header-section-number">2.3</span> Zusammenhänge
visualisieren</h2>
<p>Dafür brauchen wir natürlich mindestens zwei Variablen.</p>
<div id="eine-numerische-und-eine-kategoriale-variable"
class="section level3" number="2.3.1">
<h3><span class="header-section-number">2.3.1</span> Eine numerische und
eine kategoriale Variable</h3>
<p>Boxplots natürlich.</p>
<pre class="r"><code>ggplot(penguins, aes(x = species, y = body_mass_g)) +
  geom_boxplot()</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_boxplot()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-25-1.png" width="672" /></p>
<p>Alternativ bieten sich Häufigkeits-Polygonzüge an, mit
<code>geom_freqpoly()</code>. Statt konstante Höhen werden hier Linien
benutzt.</p>
<pre class="r"><code>ggplot(penguins, aes(x = body_mass_g, color = species)) +
  geom_freqpoly(binwidth = 200, linewidth = 0.75)</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_bin()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-26-1.png" width="672" /></p>
<p>Wir können die Dicke der Linien mit <code>linewidth</code> anpassen.
Wir können <em>density plots</em> anschaulich überlappen, sie
transparent machen, Farben benutzen und sie befüllen. Rund werden sie
auch noch. Der “Transparenzwert” <code>alpha</code> liegt zwischen 0
(komplett transparent) und 1.</p>
<pre class="r"><code>ggplot(penguins, aes(x = body_mass_g, color = species, fill = species)) +
  geom_density(alpha = 0.5)</code></pre>
<pre><code>## Warning: Removed 2 rows containing non-finite values (`stat_density()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-27-1.png" width="672" /></p>
</div>
<div id="zwei-kategoriale-variablen" class="section level3"
number="2.3.2">
<h3><span class="header-section-number">2.3.2</span> Zwei kategoriale
Variablen</h3>
<p>Die erste Variable wird unter <code>x</code> <code>aes</code> auf der
x-Achse abgetragen und die zweite Variable wird dem <code>fill</code>
<code>aes</code> zugeordnet. Farblich wird dann jeder Balken noch einmal
unterteilt (bzgl. der Variable).</p>
<p>Die Plots sind dann selbsterklärend.</p>
<pre class="r"><code>ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-28-1.png" width="672" /></p>
<pre class="r"><code>ggplot(penguins, aes(x = island, fill = species)) +
  geom_bar(position = &quot;fill&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-28-2.png" width="672" /></p>
</div>
<div id="zwei-numerische-variablen" class="section level3"
number="2.3.3">
<h3><span class="header-section-number">2.3.3</span> Zwei numerische
Variablen</h3>
<p>Ein <strong>Scatterplot</strong> ist die weitverbreiteste
Darstellungsart von zwei numerischen Variablen.</p>
<pre class="r"><code>ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
</div>
<div id="drei-oder-mehr-variablen" class="section level3"
number="2.3.4">
<h3><span class="header-section-number">2.3.4</span> Drei oder mehr
Variablen</h3>
<p>Eine Möglichkeit ist es, die Variablen einem <code>aes</code>
zuzuordnen. Neben x-Achse und y-Achse haben wir so insgesamt 4
Variablen: <code>species</code> und <code>island</code> noch dazu.</p>
<pre class="r"><code>ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = island))</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>Zu viele <code>aes</code> machen einen Plot aber unübersichtlich.
Eine andere, nützliche Möglichkeit bei kategorialen Variablen sind
Subplots, <strong>facets</strong> genannt.<br />
Benutze dafür <code>facet_wrap()</code> Das erste Argument ist eine
Tilde, das zweite der Variablenname. Diese Variable sollte natürlich
kategorial sein.</p>
<pre class="r"><code>ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point(aes(color = species, shape = species)) +
  facet_wrap(~island)</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
</div>
</div>
<div id="plots-speichern" class="section level2" number="2.4">
<h2><span class="header-section-number">2.4</span> Plots speichern</h2>
<p><code>ggsave()</code> speichert.</p>
<pre class="r"><code>ggplot(penguins, aes(x = flipper_length_mm, y = body_mass_g)) +
  geom_point()</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p>
<pre class="r"><code>#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).
ggsave(filename = &quot;my-plot.png&quot;)</code></pre>
<pre><code>## Saving 7 x 5 in image</code></pre>
<pre><code>## Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<pre class="r"><code>#&gt; Saving 6 x 4 in image
#&gt; Warning: Removed 2 rows containing missing values (`geom_point()`).</code></pre>
<p>Dieser Befehl speichert den Plot in der <em>working directory</em>.
Notfalls sucht die Datei auf eurem Computer. Mehr dazu unter
<code>?sec-workflow-scripts</code>.</p>
</div>
<div id="gängige-probleme" class="section level2" number="2.5">
<h2><span class="header-section-number">2.5</span> Gängige Probleme</h2>
<p>Denke daran deine Klammern wieder zu schließen. Wenn du ein
<code>+</code> siehst. R wartet darauf, dass du deinen Befehl zu Ende
schreibst. Das <code>+</code> steht am Ende der Zeile, nicht am
Anfang.<br />
Scheue dich nicht google.com zu benutzen, hier findest du wirklich
alles. Oder Chat GPT.</p>
</div>
</div>
<div id="daten-transformieren" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Daten
transformieren</h1>
<div id="einleitung-1" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Einleitung</h2>
<p>Visualisierung ist schön und gut. Aber es ist doch sehr selten, dass
du deine Daten genau in der gewünschten Form bekommst. Oft musst du neue
Variablen erstellen, andere zusammenfassen, oder umbenennen, Werte in
ihnen neu sortieren. All das lernen wir in diesem Kapitel. Dafür
brauchen wir das <strong>dplyr</strong> Paket und einen neuen
Datensatz.</p>
<div id="voraussetzungen-1" class="section level3" number="3.1.1">
<h3><span class="header-section-number">3.1.1</span>
Voraussetzungen</h3>
<pre class="r"><code>library(nycflights13)
library(tidyverse)</code></pre>
</div>
<div id="nycflights13" class="section level3" number="3.1.2">
<h3><span class="header-section-number">3.1.2</span> nycflights13</h3>
<p>Der Datensatz enthält 336 776 Flüge, die 2013 von NYC aus geflogen
wurden.</p>
<pre class="r"><code>flights</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Dieser Datensatz sieht jetzt optisch ein wenig anders aus, als wir es
(von früher) gewohnt sind. Weil er ein <strong>tibble</strong> ist, ein
spezieller Typ von <em>Data Frame</em>. Es werden hier nur die ersten
Zeilen angezeigt. Auch nicht alle Spalten, gersde so viele wie auf den
Bildschirm passen oder ins Fenster. Der Datentyp ist für große
Datensätze gemacht. <code>View(flights)</code> bietet eine interaktive
Ansicht, ähnlich wie in Excel. Mit
<code>print(flights, width = Inf)</code> kannst du alle Spalten anzeigen
lassen. Oder mit <code>glimpse()</code>.</p>
<pre class="r"><code>glimpse(flights)</code></pre>
<pre><code>## Rows: 336,776
## Columns: 19
## $ year           &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2…
## $ month          &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…
## $ day            &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1…
## $ dep_time       &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 558, 558, …
## $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 600, 600, …
## $ dep_delay      &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2, -2, -1…
## $ arr_time       &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 753, 849,…
## $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 745, 851,…
## $ arr_delay      &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -3, 7, -1…
## $ carrier        &lt;chr&gt; &quot;UA&quot;, &quot;UA&quot;, &quot;AA&quot;, &quot;B6&quot;, &quot;DL&quot;, &quot;UA&quot;, &quot;B6&quot;, &quot;EV&quot;, &quot;B6&quot;, &quot;…
## $ flight         &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79, 301, 4…
## $ tailnum        &lt;chr&gt; &quot;N14228&quot;, &quot;N24211&quot;, &quot;N619AA&quot;, &quot;N804JB&quot;, &quot;N668DN&quot;, &quot;N394…
## $ origin         &lt;chr&gt; &quot;EWR&quot;, &quot;LGA&quot;, &quot;JFK&quot;, &quot;JFK&quot;, &quot;LGA&quot;, &quot;EWR&quot;, &quot;EWR&quot;, &quot;LGA&quot;,…
## $ dest           &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;MIA&quot;, &quot;BQN&quot;, &quot;ATL&quot;, &quot;ORD&quot;, &quot;FLL&quot;, &quot;IAD&quot;,…
## $ air_time       &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138, 149, 1…
## $ distance       &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 944, 733, …
## $ hour           &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5, 6, 6, 6…
## $ minute         &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, 0, 59, 0…
## $ time_hour      &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013-01-01 0…</code></pre>
<p>Hier ist auch der Typ jeder Variable angegeben:
<code>&lt;int&gt;</code> für <em>integer</em>, <code>&lt;dbl&gt;</code>
für <em>double</em>, <code>&lt;chr&gt;</code> für <em>character</em> und
<code>&lt;dttm&gt;</code> für <em>date-time</em>. Wichtig sind sie, da
die Operationen, die du auf sie ausführst, vom Datentyp abhängen.</p>
</div>
<div id="dplyr-basics" class="section level3" number="3.1.3">
<h3><span class="header-section-number">3.1.3</span> dplyr basics</h3>
<p>Die wichtigsten <em>dplyr verbs</em> lernen wir hier kennen. Sie
erlauben uns die meiste Arbeit der Datenmanipulation zu verrichten. Was
haben sie alle gemeinsam?</p>
<ol style="list-style-type: decimal">
<li><p>Das erste Argument ist ein <em>Data Frame</em>.</p></li>
<li><p>Die nachfolgenden Argumente beschreiben was mit dem <em>Data
Frame</em> zu machen ist. Sie benutzen die Variablennamen hierbei (ohne
Anführungszeichen).</p></li>
<li><p>Das Ergebnis ist ein neuer <em>Data Frame</em>.</p></li>
</ol>
<p>Da das erste Argument immer ein <em>Data Frame</em> ist, und auch der
Output, arbeiten dplyr verbs gut mit der <strong>pipe</strong>,
<code>|&gt;</code>:</p>
<p><code>x |&gt; f(y)</code> ist äquivalent zu <code>f(x, y)</code></p>
<p>und</p>
<p><code>x |&gt; f(y) |&gt; g(z)</code> ist äquivalent zu
<code>g(f(x, y), z)</code>.</p>
<p>Ausgesprochen wir die <em>pipe</em> als “dann” oder “then”.</p>
<pre class="r"><code>flights |&gt;
  filter(dest == &quot;IAH&quot;) |&gt; 
  group_by(year, month, day) |&gt; 
  summarize(
    arr_delay = mean(arr_delay, na.rm = TRUE)
  )</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre><code>## # A tibble: 365 × 4
## # Groups:   year, month [12]
##     year month   day arr_delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;     &lt;dbl&gt;
##  1  2013     1     1     17.8 
##  2  2013     1     2      7   
##  3  2013     1     3     18.3 
##  4  2013     1     4     -3.2 
##  5  2013     1     5     20.2 
##  6  2013     1     6      9.28
##  7  2013     1     7     -7.74
##  8  2013     1     8      7.79
##  9  2013     1     9     18.1 
## 10  2013     1    10      6.68
## # ℹ 355 more rows</code></pre>
<pre class="r"><code>fd  &lt;- data.frame(A = c(2009, 2009, 2009, 2010, 2010), B = c(3,4,5,6,8))
fd|&gt;
  group_by(A)|&gt;
  summarise(B = mean(B))</code></pre>
<pre><code>## # A tibble: 2 × 2
##       A     B
##   &lt;dbl&gt; &lt;dbl&gt;
## 1  2009     4
## 2  2010     7</code></pre>
<p>Der Code startet mit dem <code>flights</code> Datensatz, dann wird
gefiltert, dann gruppiert, dann zusammengefasst.<br />
<em>dplyr’s verbs</em> sind in 4 Gruppen organisiert: <em>rows</em>,
<em>columns</em>, <em>groups</em>, <em>tables</em>.</p>
</div>
</div>
<div id="rows" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Rows</h2>
<p>Die wichtigsten Verben, die auf Reihen angewendet werden, sind
<code>filter()</code> und <code>arrange()</code>. Beide Funktionen
affektieren nur die Zeilen. Die Spalten bleiben unberührt.
<code>distinct</code> findet Zeilen mit einzigartigen <em>Values</em>.
Es kann auch die Spalten verändern.</p>
<div id="filter" class="section level3" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span>
<code>filter()</code></h3>
<p>Wir behalten die Reihen bei, die bestimmte Werte der Spalten haben.
Das erste Argument ist ein Data Frame, danach folgen die Bedingugnen,
die erfüllt sein müssen. Alle Flüge mit mehr als 120 Minuten
Verspätung:</p>
<pre class="r"><code>flights |&gt; 
  filter(arr_delay &gt; 120)</code></pre>
<pre><code>## # A tibble: 10,034 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      811            630       101     1047            830
##  2  2013     1     1      848           1835       853     1001           1950
##  3  2013     1     1      957            733       144     1056            853
##  4  2013     1     1     1114            900       134     1447           1222
##  5  2013     1     1     1505           1310       115     1638           1431
##  6  2013     1     1     1525           1340       105     1831           1626
##  7  2013     1     1     1549           1445        64     1912           1656
##  8  2013     1     1     1558           1359       119     1718           1515
##  9  2013     1     1     1732           1630        62     2028           1825
## 10  2013     1     1     1803           1620       103     2008           1750
## # ℹ 10,024 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Natürlich kannst du auch die bekannten Operatoren:</p>
<ul>
<li><code>&gt;</code><br />
</li>
<li><code>&gt;=</code><br />
</li>
<li><code>&lt;</code><br />
</li>
<li><code>&lt;=</code><br />
</li>
<li><code>==</code><br />
</li>
<li><code>!=</code></li>
</ul>
<p>benutzen, und auch <code>&amp;</code> (und) oder <code>|</code>
(oder).</p>
<pre class="r"><code># Flights that departed on January 1
flights |&gt; 
  filter(month == 1 &amp; day == 1)</code></pre>
<pre><code>## # A tibble: 842 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 832 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Kombinationen sind also natürlich möglich.</p>
<pre class="r"><code># Flights that departed in January or February
flights |&gt; 
  filter(month == 1 | month == 2)</code></pre>
<pre><code>## # A tibble: 51,955 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 51,945 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Bekannt ist auch der <code>%in%</code> Operator, der die Kombination
<code>|</code> und <code>==</code> ersetzt. Zeilen werden behalten, bei
denen die Variable einem der Werte auf der rechten Seite entspricht.</p>
<pre class="r"><code># A shorter way to select flights that departed in January or February
flights |&gt; 
  filter(month %in% c(1, 2))</code></pre>
<pre><code>## # A tibble: 51,955 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 51,945 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p><code>dplyr</code> Funktionen modifizieren niemals ihren <em>input
data frame</em>, <code>flights</code> bleibt also erhalten. Um das
Ergebnis zu speichern, musst du also den assign Operator
<code>&lt;-</code> bemühen.</p>
<pre class="r"><code>jan1 &lt;- flights |&gt; 
  filter(month == 1 &amp; day == 1)
jan1</code></pre>
<pre><code>## # A tibble: 842 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 832 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
</div>
<div id="arrange" class="section level3" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span>
<code>arrange()</code></h3>
<p><code>arrange()</code> ändert die Reihenfolge der Reihen, basierend
auf den Werten der Spalten. Als Argumente kommen nach dem <em>Data
Frame</em> die Spalten, die sortiert werden sollen. Von klein nach groß.
Erst Jahr, dann Monat, usw.</p>
<pre class="r"><code>flights |&gt; 
  arrange(year, month, day, dep_time)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Du kannst natürlich auch andersrum sortieren mit
<code>desc()</code>.</p>
<pre class="r"><code>flights |&gt; 
  arrange(desc(dep_delay))</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     9      641            900      1301     1242           1530
##  2  2013     6    15     1432           1935      1137     1607           2120
##  3  2013     1    10     1121           1635      1126     1239           1810
##  4  2013     9    20     1139           1845      1014     1457           2210
##  5  2013     7    22      845           1600      1005     1044           1815
##  6  2013     4    10     1100           1900       960     1342           2211
##  7  2013     3    17     2321            810       911      135           1020
##  8  2013     6    27      959           1900       899     1236           2226
##  9  2013     7    22     2257            759       898      121           1026
## 10  2013    12     5      756           1700       896     1058           2020
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p><code>arrange()</code> und <code>filter()</code> können natürlich
kombiniert werden.</p>
<pre class="r"><code>flights |&gt; 
  filter(dep_delay &lt;= 10 &amp; dep_delay &gt;= -10) |&gt; 
  arrange(desc(arr_delay))</code></pre>
<pre><code>## # A tibble: 239,109 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013    11     1      658            700        -2     1329           1015
##  2  2013     4    18      558            600        -2     1149            850
##  3  2013     7     7     1659           1700        -1     2050           1823
##  4  2013     7    22     1606           1615        -9     2056           1831
##  5  2013     9    19      648            641         7     1035            810
##  6  2013     4    18      655            700        -5     1213            950
##  7  2013     6    30     1423           1425        -2     1816           1554
##  8  2013     6    24     1523           1520         3     1931           1710
##  9  2013     3    18     1844           1847        -3       39           2219
## 10  2013     7     1      905            905         0     1443           1223
## # ℹ 239,099 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
</div>
<div id="distinct" class="section level3" number="3.2.3">
<h3><span class="header-section-number">3.2.3</span>
<code>distinct()</code></h3>
<p>Einzigartige Zeilen werden mit <code>distinct()</code> gefunden.
Meistens wollen wir jedoch nur eine einzigartige Kombination von ein
paar Variablen. Dann brauchen wir diese natürlich als Argument für
<code>distinct</code>.</p>
<pre class="r"><code># This would remove any duplicate rows if there were any
flights |&gt; 
  distinct()</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Oder natürlich.</p>
<pre class="r"><code># This finds all unique origin and destination pairs.
flights |&gt; 
  distinct(origin, dest)</code></pre>
<pre><code>## # A tibble: 224 × 2
##    origin dest 
##    &lt;chr&gt;  &lt;chr&gt;
##  1 EWR    IAH  
##  2 LGA    IAH  
##  3 JFK    MIA  
##  4 JFK    BQN  
##  5 LGA    ATL  
##  6 EWR    ORD  
##  7 EWR    FLL  
##  8 LGA    IAD  
##  9 JFK    MCO  
## 10 LGA    ORD  
## # ℹ 214 more rows</code></pre>
<p>Für die Anzahl an Duplikaten benutze aber besser
<code>count()</code>.</p>
</div>
</div>
<div id="columns" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Columns</h2>
<p>Es gibt vier verschiedene Verben, die Spalten beeinträchtigen, ohne
die Zeilen zu vertauschen:<br />
- <code>mutate()</code> - <code>select()</code> -
<code>rename()</code><br />
- <code>relocate()</code></p>
<div id="mutate" class="section level3" number="3.3.1">
<h3><span class="header-section-number">3.3.1</span>
<code>mutate()</code></h3>
<p><code>mutate()</code> fügt eine neue Spalte hinzu, die aus den
bereits existierenden berechnet wird. Wir berechnen einfache Dinge, wie
Differenzen und Quotienten, z.B. wie lange ein Flug in der Luft war oder
die Geschwindigkeit in Meilen pro Stunde.</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 21
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, speed &lt;dbl&gt;</code></pre>
<p><code>mutate()</code> hängt diese neuen Variablen rechts an die
Tabellen dran. Mit <code>.before</code> können wir die Variablen auch
links dran setzen.</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .before = 1
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 21
##     gain speed  year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1    -9  370.  2013     1     1      517            515         2      830
##  2   -16  374.  2013     1     1      533            529         4      850
##  3   -31  408.  2013     1     1      542            540         2      923
##  4    17  517.  2013     1     1      544            545        -1     1004
##  5    19  394.  2013     1     1      554            600        -6      812
##  6   -16  288.  2013     1     1      554            558        -4      740
##  7   -24  404.  2013     1     1      555            600        -5      913
##  8    11  259.  2013     1     1      557            600        -3      709
##  9     5  405.  2013     1     1      557            600        -3      838
## 10   -10  319.  2013     1     1      558            600        -2      753
## # ℹ 336,766 more rows
## # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Der <code>.</code> ist ein Zeichen, so dass <code>.before</code> ein
Argument der Funktion ist, nicht der Name einer neuen Variable.
<code>.after</code> kannst du auch benutzen, um nach einer Variable
deine neue Spalte zu setzen. Statt der Position, kannst du hier auch den
Namen der Variable setzen (z.B. <code>day</code>).</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    gain = dep_delay - arr_delay,
    speed = distance / air_time * 60,
    .after = day
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 21
##     year month   day  gain speed dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1  2013     1     1    -9  370.      517            515         2      830
##  2  2013     1     1   -16  374.      533            529         4      850
##  3  2013     1     1   -31  408.      542            540         2      923
##  4  2013     1     1    17  517.      544            545        -1     1004
##  5  2013     1     1    19  394.      554            600        -6      812
##  6  2013     1     1   -16  288.      554            558        -4      740
##  7  2013     1     1   -24  404.      555            600        -5      913
##  8  2013     1     1    11  259.      557            600        -3      709
##  9  2013     1     1     5  405.      557            600        -3      838
## 10  2013     1     1   -10  319.      558            600        -2      753
## # ℹ 336,766 more rows
## # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Alternativ kannst du kontrollieren, welche Variablen behalten werden
sollen, mit dem <code>.keep</code> Argument. Ein nützliches Argument ist
<code>used</code>, welches dir die Inputs und Outputs deiner
Berechnungen anzeigt.</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    gain = dep_delay - arr_delay,
    hours = air_time / 60,
    gain_per_hour = gain / hours,
    .keep = &quot;used&quot;
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 6
##    dep_delay arr_delay air_time  gain hours gain_per_hour
##        &lt;dbl&gt;     &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;         &lt;dbl&gt;
##  1         2        11      227    -9 3.78          -2.38
##  2         4        20      227   -16 3.78          -4.23
##  3         2        33      160   -31 2.67         -11.6 
##  4        -1       -18      183    17 3.05           5.57
##  5        -6       -25      116    19 1.93           9.83
##  6        -4        12      150   -16 2.5           -6.4 
##  7        -5        19      158   -24 2.63          -9.11
##  8        -3       -14       53    11 0.883         12.5 
##  9        -3        -8      140     5 2.33           2.14
## 10        -2         8      138   -10 2.3           -4.35
## # ℹ 336,766 more rows</code></pre>
</div>
<div id="select" class="section level3" number="3.3.2">
<h3><span class="header-section-number">3.3.2</span>
<code>select()</code></h3>
<p>Oftmals kriegt man unendlich viele Variablen an die Hand, von denen
uns aber nur ein paar interessieren. <code>select()</code> gibt uns nur
einige von ihnen wieder. In unserem Beispiel haben wir nur 19 Variablen,
aber die Idee zählt.</p>
<pre class="r"><code># Select columns by name
flights |&gt; 
  select(year, month, day)</code></pre>
<pre><code>## # A tibble: 336,776 × 3
##     year month   day
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1  2013     1     1
##  2  2013     1     1
##  3  2013     1     1
##  4  2013     1     1
##  5  2013     1     1
##  6  2013     1     1
##  7  2013     1     1
##  8  2013     1     1
##  9  2013     1     1
## 10  2013     1     1
## # ℹ 336,766 more rows</code></pre>
<pre class="r"><code># Select all columns between year and day (inclusive)
flights |&gt; 
  select(year:day)</code></pre>
<pre><code>## # A tibble: 336,776 × 3
##     year month   day
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1  2013     1     1
##  2  2013     1     1
##  3  2013     1     1
##  4  2013     1     1
##  5  2013     1     1
##  6  2013     1     1
##  7  2013     1     1
##  8  2013     1     1
##  9  2013     1     1
## 10  2013     1     1
## # ℹ 336,766 more rows</code></pre>
<pre class="r"><code># Select all columns except those from year to day (inclusive)
flights |&gt; 
  select(!year:day)</code></pre>
<pre><code>## # A tibble: 336,776 × 16
##    dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier
##       &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;  
##  1      517            515         2      830            819        11 UA     
##  2      533            529         4      850            830        20 UA     
##  3      542            540         2      923            850        33 AA     
##  4      544            545        -1     1004           1022       -18 B6     
##  5      554            600        -6      812            837       -25 DL     
##  6      554            558        -4      740            728        12 UA     
##  7      555            600        -5      913            854        19 B6     
##  8      557            600        -3      709            723       -14 EV     
##  9      557            600        -3      838            846        -8 B6     
## 10      558            600        -2      753            745         8 AA     
## # ℹ 336,766 more rows
## # ℹ 9 more variables: flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;,
## #   air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code># Select all columns that are characters
flights |&gt; 
  select(where(is.character))</code></pre>
<pre><code>## # A tibble: 336,776 × 4
##    carrier tailnum origin dest 
##    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  &lt;chr&gt;
##  1 UA      N14228  EWR    IAH  
##  2 UA      N24211  LGA    IAH  
##  3 AA      N619AA  JFK    MIA  
##  4 B6      N804JB  JFK    BQN  
##  5 DL      N668DN  LGA    ATL  
##  6 UA      N39463  EWR    ORD  
##  7 B6      N516JB  EWR    FLL  
##  8 EV      N829AS  LGA    IAD  
##  9 B6      N593JB  JFK    MCO  
## 10 AA      N3ALAA  LGA    ORD  
## # ℹ 336,766 more rows</code></pre>
<p>Viele weitere Hilfsfunktionen arbeiten mit <code>select()</code>:</p>
<pre class="r"><code># starts_with(&quot;tai&quot;): matches names that begin with “tai”
flights |&gt; 
    select(starts_with(&quot;tai&quot;))</code></pre>
<pre><code>## # A tibble: 336,776 × 1
##    tailnum
##    &lt;chr&gt;  
##  1 N14228 
##  2 N24211 
##  3 N619AA 
##  4 N804JB 
##  5 N668DN 
##  6 N39463 
##  7 N516JB 
##  8 N829AS 
##  9 N593JB 
## 10 N3ALAA 
## # ℹ 336,766 more rows</code></pre>
<ul>
<li><code>starts_with("abc")</code></li>
<li><code>ends_with("xyz")</code><br />
</li>
<li><code>contains("ijk")</code><br />
</li>
<li><code>num_range("x", 1:3)</code>: matcht <code>x1</code>,
<code>x2</code>, <code>x3</code></li>
</ul>
<p>Variablen neu benennen über <code>select()</code> durch
<code>=</code>.</p>
<pre class="r"><code>flights |&gt; 
  select(tail_num = tailnum)</code></pre>
<pre><code>## # A tibble: 336,776 × 1
##    tail_num
##    &lt;chr&gt;   
##  1 N14228  
##  2 N24211  
##  3 N619AA  
##  4 N804JB  
##  5 N668DN  
##  6 N39463  
##  7 N516JB  
##  8 N829AS  
##  9 N593JB  
## 10 N3ALAA  
## # ℹ 336,766 more rows</code></pre>
</div>
<div id="rename" class="section level3" number="3.3.3">
<h3><span class="header-section-number">3.3.3</span>
<code>rename()</code></h3>
<pre class="r"><code>flights |&gt; 
  rename(tail_num = tailnum)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tail_num &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Funktioniert wie <code>select()</code>, aber behält alle nicht
ausgewähle Variablen bei.</p>
</div>
<div id="relocate" class="section level3" number="3.3.4">
<h3><span class="header-section-number">3.3.4</span>
<code>relocate()</code></h3>
<p>Bewege Variablen nach vorne.</p>
<pre class="r"><code>flights |&gt; 
  relocate(time_hour, air_time)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##    time_hour           air_time  year month   day dep_time sched_dep_time
##    &lt;dttm&gt;                 &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;
##  1 2013-01-01 05:00:00      227  2013     1     1      517            515
##  2 2013-01-01 05:00:00      227  2013     1     1      533            529
##  3 2013-01-01 05:00:00      160  2013     1     1      542            540
##  4 2013-01-01 05:00:00      183  2013     1     1      544            545
##  5 2013-01-01 06:00:00      116  2013     1     1      554            600
##  6 2013-01-01 05:00:00      150  2013     1     1      554            558
##  7 2013-01-01 06:00:00      158  2013     1     1      555            600
##  8 2013-01-01 06:00:00       53  2013     1     1      557            600
##  9 2013-01-01 06:00:00      140  2013     1     1      557            600
## 10 2013-01-01 06:00:00      138  2013     1     1      558            600
## # ℹ 336,766 more rows
## # ℹ 12 more variables: dep_delay &lt;dbl&gt;, arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;,
## #   arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;,
## #   dest &lt;chr&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;</code></pre>
<p>Oder an einen bestimmten Ort mit <code>.before</code> und
<code>.after</code>.</p>
<pre class="r"><code>flights |&gt; 
  relocate(year:dep_time, .after = time_hour)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##    sched_dep_time dep_delay arr_time sched_arr_time arr_delay carrier flight
##             &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;    &lt;int&gt;
##  1            515         2      830            819        11 UA        1545
##  2            529         4      850            830        20 UA        1714
##  3            540         2      923            850        33 AA        1141
##  4            545        -1     1004           1022       -18 B6         725
##  5            600        -6      812            837       -25 DL         461
##  6            558        -4      740            728        12 UA        1696
##  7            600        -5      913            854        19 B6         507
##  8            600        -3      709            723       -14 EV        5708
##  9            600        -3      838            846        -8 B6          79
## 10            600        -2      753            745         8 AA         301
## # ℹ 336,766 more rows
## # ℹ 12 more variables: tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, year &lt;int&gt;,
## #   month &lt;int&gt;, day &lt;int&gt;, dep_time &lt;int&gt;</code></pre>
<pre class="r"><code>flights |&gt; 
  relocate(starts_with(&quot;arr&quot;), .before = dep_time)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day arr_time arr_delay dep_time sched_dep_time dep_delay
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;
##  1  2013     1     1      830        11      517            515         2
##  2  2013     1     1      850        20      533            529         4
##  3  2013     1     1      923        33      542            540         2
##  4  2013     1     1     1004       -18      544            545        -1
##  5  2013     1     1      812       -25      554            600        -6
##  6  2013     1     1      740        12      554            558        -4
##  7  2013     1     1      913        19      555            600        -5
##  8  2013     1     1      709       -14      557            600        -3
##  9  2013     1     1      838        -8      557            600        -3
## 10  2013     1     1      753         8      558            600        -2
## # ℹ 336,766 more rows
## # ℹ 11 more variables: sched_arr_time &lt;int&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
</div>
</div>
<div id="gruppen" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Gruppen</h2>
<p><code>dplyr</code> wird noch mächtiger durch die Arbeit mit
Gruppen.</p>
<div id="group_by" class="section level3" number="3.4.1">
<h3><span class="header-section-number">3.4.1</span>
<code>group_by</code></h3>
<p>Benutze <code>group_by()</code> um deinen Datensatz in Gruppen zu
unterteilen, die dir bei deiner Analyse helfen.</p>
<pre class="r"><code>flights |&gt; 
  group_by(month)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
## # Groups:   month [12]
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Die Daten werden nicht verändert, aber der Output ist jetzt
<em>grouped by month</em>. <code>grouped_by()</code> verändert das
Verhalten nachkommender Verben.</p>
</div>
<div id="summarize" class="section level3" number="3.4.2">
<h3><span class="header-section-number">3.4.2</span>
<code>summarize()</code></h3>
<p>Die wichtigste gruppierte Operation ist eine Zusammenfassung
(<em>summary</em>), welche jede Gruppe zu einer einzelnen Zeile
zusammenfasst. Die durchschnittliche <em>departure delay</em>
(Abflugverzögerung) nach Monaten kann so berechnet werden.</p>
<pre class="r"><code>flights |&gt; 
  group_by(month) |&gt; 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE)
  )</code></pre>
<pre><code>## # A tibble: 12 × 2
##    month delay
##    &lt;int&gt; &lt;dbl&gt;
##  1     1 10.0 
##  2     2 10.8 
##  3     3 13.2 
##  4     4 13.9 
##  5     5 13.0 
##  6     6 20.8 
##  7     7 21.7 
##  8     8 12.6 
##  9     9  6.72
## 10    10  6.24
## 11    11  5.44
## 12    12 16.6</code></pre>
<p>In einem <code>summarize()</code> Aufruf kannst du jede beliebige
Anzahl von <em>Summaries</em> ausgeben lassen. <code>n()</code> gibt die
Anzahl von Zeilen in jeder Gruppe wieder.</p>
<pre class="r"><code>flights |&gt; 
  group_by(month) |&gt; 
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 12 × 3
##    month delay     n
##    &lt;int&gt; &lt;dbl&gt; &lt;int&gt;
##  1     1 10.0  27004
##  2     2 10.8  24951
##  3     3 13.2  28834
##  4     4 13.9  28330
##  5     5 13.0  28796
##  6     6 20.8  28243
##  7     7 21.7  29425
##  8     8 12.6  29327
##  9     9  6.72 27574
## 10    10  6.24 28889
## 11    11  5.44 27268
## 12    12 16.6  28135</code></pre>
</div>
<div id="slice_-funktionen" class="section level3" number="3.4.3">
<h3><span class="header-section-number">3.4.3</span> <code>slice_</code>
Funktionen</h3>
<p>Fünf Funktionen erlauben es dir spezielle Zeilen innerhalb jeder
Gruppe wiederzugeben.</p>
<ul>
<li><code>df |&gt; slice_head(n = 1)</code> erste Zeile jeder
Gruppe</li>
<li><code>df |&gt; slice_tail(n = 1)</code> letzte Zeile jeder
Gruppe</li>
<li><code>df |&gt; slice_min(x, n = 1)</code> Zeile mit kleinstem Wert
von <code>x</code></li>
<li><code>df |&gt; slice_max(x, n = 1)</code> Zeile mit größtem
Wert</li>
<li><code>df |&gt; slice_sample(n = 1)</code> zufällige Zeile</li>
</ul>
<p>Über <code>n</code> kannst du auch mehr als eine Zeile dir ausgeben
lassen. Stattdessen kannst du dir auch einen Prozentsatz ausgeben
lassen: <code>prop = 0.1</code> für 10%.</p>
<pre class="r"><code>flights |&gt; 
  group_by(dest) |&gt; 
  slice_max(arr_delay, n = 1)</code></pre>
<pre><code>## # A tibble: 108 × 19
## # Groups:   dest [105]
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     7    22     2145           2007        98      132           2259
##  2  2013     7    23     1139            800       219     1250            909
##  3  2013     1    25      123           2000       323      229           2101
##  4  2013     8    17     1740           1625        75     2042           2003
##  5  2013     7    22     2257            759       898      121           1026
##  6  2013     7    10     2056           1505       351     2347           1758
##  7  2013     8    13     1156            832       204     1417           1029
##  8  2013     2    21     1728           1316       252     1839           1413
##  9  2013    12     1     1504           1056       248     1628           1230
## 10  2013     4    10       25           1900       325      136           2045
## # ℹ 98 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Eine ähnliche Ausgabe kriegst du über <code>summarize()</code>. Nur
einmal kriegst du die ganze Zeile, einmal die <em>single
summary</em>.</p>
<pre class="r"><code>flights |&gt; 
  group_by(dest) |&gt; 
  summarize(max_delay = max(arr_delay, na.rm = TRUE))</code></pre>
<pre><code>## Warning: There was 1 warning in `summarize()`.
## ℹ In argument: `max_delay = max(arr_delay, na.rm = TRUE)`.
## ℹ In group 52: `dest = &quot;LGA&quot;`.
## Caused by warning in `max()`:
## ! kein nicht-fehlendes Argument für max; gebe -Inf zurück</code></pre>
<pre><code>## # A tibble: 105 × 2
##    dest  max_delay
##    &lt;chr&gt;     &lt;dbl&gt;
##  1 ABQ         153
##  2 ACK         221
##  3 ALB         328
##  4 ANC          39
##  5 ATL         895
##  6 AUS         349
##  7 AVL         228
##  8 BDL         266
##  9 BGR         238
## 10 BHM         291
## # ℹ 95 more rows</code></pre>
</div>
<div id="gruppieren-nach-mehreren-variablen" class="section level3"
number="3.4.4">
<h3><span class="header-section-number">3.4.4</span> Gruppieren nach
mehreren Variablen</h3>
<p>Du kannst natürlich auch nach mehreren Variablen gruppieren. Eine
Gruppe für jeden Tag.</p>
<pre class="r"><code>daily &lt;- flights |&gt;  
  group_by(year, month, day)
daily</code></pre>
<pre><code>## # A tibble: 336,776 × 19
## # Groups:   year, month, day [365]
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Wenn du ein <em>tibble</em> zusammenfasst, gruppiert mit mehr als
einer Variable, kriegst du einen Hinweis nach welcher Variable vor der
letzten zuvor gruppiert wurde.</p>
<pre class="r"><code>daily_flights &lt;- daily |&gt; 
  summarize(
    n = n()
  )</code></pre>
<pre><code>## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre class="r"><code>daily_flights |&gt;
  print(n = 30)</code></pre>
<pre><code>## # A tibble: 365 × 4
## # Groups:   year, month [12]
##     year month   day     n
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1  2013     1     1   842
##  2  2013     1     2   943
##  3  2013     1     3   914
##  4  2013     1     4   915
##  5  2013     1     5   720
##  6  2013     1     6   832
##  7  2013     1     7   933
##  8  2013     1     8   899
##  9  2013     1     9   902
## 10  2013     1    10   932
## 11  2013     1    11   930
## 12  2013     1    12   690
## 13  2013     1    13   828
## 14  2013     1    14   928
## 15  2013     1    15   894
## 16  2013     1    16   901
## 17  2013     1    17   927
## 18  2013     1    18   924
## 19  2013     1    19   674
## 20  2013     1    20   786
## 21  2013     1    21   912
## 22  2013     1    22   890
## 23  2013     1    23   897
## 24  2013     1    24   925
## 25  2013     1    25   922
## 26  2013     1    26   680
## 27  2013     1    27   823
## 28  2013     1    28   923
## 29  2013     1    29   890
## 30  2013     1    30   900
## # ℹ 335 more rows</code></pre>
<p>Diese Meldung kannst du unterdrücken durch:</p>
<pre class="r"><code>daily_flights &lt;- daily |&gt; 
  summarize(
    n = n(), 
    .groups = &quot;drop_last&quot;
  )</code></pre>
<p>Und erhälst so dann:</p>
<pre class="r"><code>daily_flights |&gt;
  print(n = 5)</code></pre>
<pre><code>## # A tibble: 365 × 4
## # Groups:   year, month [12]
##    year month   day     n
##   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;
## 1  2013     1     1   842
## 2  2013     1     2   943
## 3  2013     1     3   914
## 4  2013     1     4   915
## 5  2013     1     5   720
## # ℹ 360 more rows</code></pre>
</div>
<div id="ungrouping" class="section level3" number="3.4.5">
<h3><span class="header-section-number">3.4.5</span> Ungrouping</h3>
<p>Durch <code>ungroup()</code> kannst du die Gruppierung außerhalb von
<code>summarize()</code> entfernen.</p>
<pre class="r"><code>daily |&gt; 
  ungroup() |&gt;
  summarize(
    delay = mean(dep_delay, na.rm = TRUE), 
    flights = n()
  )</code></pre>
<pre><code>## # A tibble: 1 × 2
##   delay flights
##   &lt;dbl&gt;   &lt;int&gt;
## 1  12.6  336776</code></pre>
<p>Wenn du einen ungruppierten <em>Data Frame</em> zusammenfasst,
kriegst du logischerweise nur eine Zeile als Ausgabe. Als hättest du nur
eine Gruppe.</p>
</div>
</div>
<div id="case-study" class="section level2" number="3.5">
<h2><span class="header-section-number">3.5</span> Case Study</h2>
<p>Bei Aggregation ist es immer sinnvoll eine <em>count</em> Variable
mit einzubauen.<br />
Schauen wir uns die Flugzeuge an, identifiziert durch ihre <em>tail
number</em>, die die höchsten durchschnittlichen Verspätungen haben.</p>
<pre class="r"><code>delays &lt;- flights |&gt;  
  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; 
  group_by(tailnum) |&gt; 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

ggplot(delays, aes(x = delay)) + 
  geom_freqpoly(binwidth = 10)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-72-1.png" width="672" /></p>
<p>Manche Flugzeuge haben einen durchschnittlichen <em>delay</em> von
300 Minuten.<br />
Erstellen wir einen Scatterplot mit Anzahl an Flügen vs. <em>average
delay</em>:</p>
<pre class="r"><code>ggplot(delays, aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-73-1.png" width="672" /></p>
<p>Gruppen mit den kleinsten Anzahlen an Beobachtungen wollen wir
rausfiltern, sodass mehr <em>Pattern</em> und weniger extreme
Variationen in kleinen Gruppen angezeigt werden.</p>
<pre class="r"><code>delays |&gt;  
  filter(n &gt; 25) |&gt; 
  ggplot(aes(x = n, y = delay)) + 
  geom_point(alpha = 1/10) + 
  geom_smooth(se = FALSE)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-74-1.png" width="672" /></p>
<p><strong>Beispiel_2</strong> Baseball.</p>
<p>Aus dem <strong>Lahman</strong> Paket: Anteil an Versuchen, bei denen
der Ball getroffen wurde vs. Anzahl an Versuche.</p>
<pre class="r"><code>batters &lt;- Lahman::Batting |&gt; 
  group_by(playerID) |&gt; 
  summarize(
    perf = sum(H, na.rm = TRUE) / sum(AB, na.rm = TRUE),
    n = sum(AB, na.rm = TRUE)
  )
batters</code></pre>
<pre><code>## # A tibble: 20,166 × 3
##    playerID    perf     n
##    &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt;
##  1 aardsda01 0          4
##  2 aaronha01 0.305  12364
##  3 aaronto01 0.229    944
##  4 aasedo01  0          5
##  5 abadan01  0.0952    21
##  6 abadfe01  0.111      9
##  7 abadijo01 0.224     49
##  8 abbated01 0.254   3044
##  9 abbeybe01 0.169    225
## 10 abbeych01 0.281   1756
## # ℹ 20,156 more rows</code></pre>
<p>Zwei Muster sind zu erkennen: mehr Datenpunkte heißt weniger
Variation. Und eine positive Korrelation zwischen <code>perf</code> und
<code>n</code> ist zu erkennen. Logisch, da der beste Batter auch die
meisten Möglichkeiten kriegen soll.</p>
<pre class="r"><code>batters |&gt; 
  filter(n &gt; 100) |&gt; 
  ggplot(aes(x = n, y = perf)) +
    geom_point(alpha = 1 / 10) + 
    geom_smooth(se = FALSE)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;gam&#39; and formula = &#39;y ~ s(x, bs = &quot;cs&quot;)&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-76-1.png" width="672" /></p>
<p>Sortierst du naiv nach <code>desc(ba)</code> (<em>batting
average</em>), sind oben die glücklichsten, nicht die besten Spieler zu
finden.</p>
<pre class="r"><code>batters |&gt; 
  arrange(desc(perf))</code></pre>
<pre><code>## # A tibble: 20,166 × 3
##    playerID   perf     n
##    &lt;chr&gt;     &lt;dbl&gt; &lt;int&gt;
##  1 abramge01     1     1
##  2 alberan01     1     1
##  3 banisje01     1     1
##  4 bartocl01     1     1
##  5 bassdo01      1     1
##  6 birasst01     1     2
##  7 bruneju01     1     1
##  8 burnscb01     1     1
##  9 cammaer01     1     1
## 10 campsh01      1     1
## # ℹ 20,156 more rows</code></pre>
</div>
</div>
<div id="pipes" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Pipes</h1>
<p>Die Pipe <code>|&gt;</code> ist ein mächtiges Werkzeug, die eine
Reihe von Operationen ausdrückt, die ein Objekt transformieren. Bekannt
ist vielleicht der Vorgänger <code>%&gt;%</code>.</p>
<p>Für den <em>keyboard shortcut</em> Ctrl + Shift + M, gehe in
<em>Options</em>, <em>Editing</em> und klicke <em>Use native pipe
operator</em> an.</p>
<div id="warum-pipe-benutzen" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Warum Pipe
benutzen?</h2>
<p>Jedes <em>dplyr verb</em> ist sehr simpel, jedoch erfordert die
Lösung komplexer Probleme eine Kombination vieler Verben.</p>
<pre class="r"><code>flights |&gt;  
  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; 
  group_by(tailnum) |&gt; 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 4,037 × 3
##    tailnum  delay     n
##    &lt;chr&gt;    &lt;dbl&gt; &lt;int&gt;
##  1 D942DN  31.5       4
##  2 N0EGMQ   9.98    352
##  3 N10156  12.7     145
##  4 N102UW   2.94     48
##  5 N103US  -6.93     46
##  6 N104UW   1.80     46
##  7 N10575  20.7     269
##  8 N105UW  -0.267    45
##  9 N107US  -5.73     41
## 10 N108UW  -1.25     60
## # ℹ 4,027 more rows</code></pre>
<p>Die Verben stehen am Beginn jeder Zeile:<br />
<code>flights</code> Daten, dann filter, dann gruppieren, dann
zusammenfassen.</p>
<p>Ohne <em>Pipe</em>:</p>
<pre class="r"><code>summarize(
  group_by(
    filter(
      flights, 
      !is.na(arr_delay), !is.na(tailnum)
    ),
    tailnum
  ), 
  delay = mean(arr_delay, na.rm = TRUE
  ), 
  n = n()
)</code></pre>
<pre><code>## # A tibble: 4,037 × 3
##    tailnum  delay     n
##    &lt;chr&gt;    &lt;dbl&gt; &lt;int&gt;
##  1 D942DN  31.5       4
##  2 N0EGMQ   9.98    352
##  3 N10156  12.7     145
##  4 N102UW   2.94     48
##  5 N103US  -6.93     46
##  6 N104UW   1.80     46
##  7 N10575  20.7     269
##  8 N105UW  -0.267    45
##  9 N107US  -5.73     41
## 10 N108UW  -1.25     60
## # ℹ 4,027 more rows</code></pre>
</div>
<div id="magrittr-und-die-pipe" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> magrittr und die
<code>%&gt;%</code> Pipe</h2>
<p>Im <strong>magrittr</strong> Paket wird die <code>%&gt;%</code> Pipe
angeboten. Diese Pipe kannst du benutzen, wenn das tidyverse Paket
geladen ist.</p>
<pre class="r"><code>library(tidyverse)

mtcars %&gt;% 
  group_by(cyl) %&gt;%
  summarize(n = n())</code></pre>
<pre><code>## # A tibble: 3 × 2
##     cyl     n
##   &lt;dbl&gt; &lt;int&gt;
## 1     4    11
## 2     6     7
## 3     8    14</code></pre>
</div>
<div id="vs." class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> <code>|&gt;</code>
vs. <code>%&gt;%</code></h2>
<p>Die Pipe übergibt das Objekt zu ihrer linken Seite als erstes
Argument auf die rechte Seite. <code>%&gt;%</code> erlaubt es die
Platzierung zu tauschen:</p>
<ul>
<li><p><code>x %&gt;% f(1)</code> ist äquivalent zu
<code>f(x, 1)</code>, aber <code>x %&gt;% f(1, .)</code> ist äquivalent
zu <code>f(1, x)</code>.<br />
Bei der “neuen Pipe” muss das Argument genannt werden.
<code>x |&gt; f(1, y = _)</code> ist äquivalent zu
<code>f(1, y = x)</code>.</p></li>
<li><p>Mit <code>%&gt;%</code> kannst du <code>.</code> auf der linken
Seite von Operatoren wie <code>$</code>, <code>[[</code> oder
<code>[</code> benutzen, so dass du z.B. eine einzelne Spalte
extrahieren kannst: <code>mtcars %&gt;% .$cyl</code>.<br />
Du kannst sogar zwei mal ersetzen:
<code>df %&gt;% {split(.$x, .$y)}</code> ist äquivalent zu
<code>split(df$x, df$y)</code>.<br />
Für das Extrahieren einer Spalte benutze statt
<code>pull(mtcars, cyl)</code> die pull Funktion
<code>dplyr::pull()</code>:</p></li>
</ul>
<pre class="r"><code>mtcars |&gt; pull(cyl)</code></pre>
<pre><code>##  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4</code></pre>
<ul>
<li><code>%&gt;%</code> erlaubt es dir bei Funktionen die Klamern
wegzulassen, wenn es keine Argumente gibt:
<code>mtcars[,1] %&gt;% mean</code> funktioniert,
<code>mtcars[,1] |&gt; mean</code> aber nicht.</li>
</ul>
</div>
<div id="vs.-1" class="section level2" number="4.4">
<h2><span class="header-section-number">4.4</span> <code>|&gt;</code>
vs. <code>+</code></h2>
<p>Da <code>ggplot2</code> vor der Pipe entwickelt wurde, ist der
Übergang von <code>|&gt;</code> zu <code>+</code> notwendig:</p>
<pre class="r"><code>ggplot2::diamonds |&gt; 
  count(cut, clarity) |&gt; 
  ggplot(aes(x = clarity, y = cut, fill = n)) + 
  geom_tile()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-82-1.png" width="672" /></p>
<p>Vor den zwei Doppelpunkten steht das Paket aus dem der Datensatz
kommt! Gleiche Ergebnisse liefert übrigens:</p>
<pre class="r"><code>aa&lt;-count(ggplot2::diamonds, cut, clarity)
ggplot(aa, aes(x = clarity, y = cut, fill = n)) +
  geom_tile()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-83-1.png" width="672" /></p>
</div>
</div>
<div id="code-style" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Code Style</h1>
<p>Ohne guten <em>Code style</em> kannst du arbeiten, mit ist es aber
wesentlich einfacher. Es gibt sogar Pakete mit denen du deinen Code
aufhübschen kannst. Zum Beispiel das <strong>styler</strong> Paket. Nach
der Installation benutze Cmd + Shift + P und gebe <code>styler</code>
ein, um alle Shortcuts zu sehen.</p>
<div id="namen" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Namen</h2>
<p>Kleinbuchstaben, Zahlen und Trennungen durch <code>_</code> werden
als guter Style angesehen.</p>
<pre class="r"><code># Strebe nach:
short_flights &lt;- flights |&gt; filter(air_time &lt; 60)

# Vermeide:
SHORTFLIGHTS &lt;- flights |&gt; filter(air_time &lt; 60)</code></pre>
<p>Lange, beschreibende Namen sind einfach zu verstehen. Kurze sind
schneller zu tippen, aber auch eventuell später schwer zu verstehen.</p>
</div>
<div id="lücken" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Lücken</h2>
<p>Lücken bei mathematischen Operatoren erleichtern das Lesen
(<code>+</code>, <code>-</code>, <code>==</code>, <code>&lt;</code>).
Nicht bei <code>^</code>, aber um Zuweisungen. Keine Lücken stehen nach
oder vor Klammern, aber nach dem <code>,</code>.</p>
<pre class="r"><code># bitte
z &lt;- (a + b)^2 / d

# nicht
z&lt;-( a + b ) ^ 2/d

# bitte
mean(x, na.rm = TRUE)

# nicht
mean (x ,na.rm=TRUE)</code></pre>
<p>Extra Lücken einzufügen, so dass es der Lesbarkeit und Harmonie
dient, ist durchaus wünschenswert.</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    speed      = air_time / distance,
    dep_hour   = dep_time %/% 100,
    dep_minute = dep_time %%  100
  )</code></pre>
</div>
<div id="pipes-1" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> Pipes</h2>
<p><em>Pipes</em> sollten immer das letzte Element einer Zeile sein.</p>
<pre class="r"><code># bitte 
flights |&gt;  
  filter(!is.na(arr_delay), !is.na(tailnum)) |&gt; 
  count(dest)

# nicht
flights|&gt;filter(!is.na(arr_delay), !is.na(tailnum))|&gt;count(dest)</code></pre>
<p>Hat die <em>piping function</em> Argumente wie <code>mutate()</code>
oder <code>summarize()</code>, so kommt jedes Argument in eine neue
Zeile.</p>
<pre class="r"><code># bitte
flights |&gt;  
  group_by(tailnum) |&gt; 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

# nicht
flights |&gt;
  group_by(
    tailnum
  ) |&gt; 
  summarize(delay = mean(arr_delay, na.rm = TRUE), n = n())</code></pre>
<p>Nach der Zeile der <em>Pipe</em> wird zwei Leerzeichen eingerückt.
Bekommt jedes Argument eine eigene Zeile wird wieder eingerückt. Die
<code>)</code> bekommt wieder eine eigene Zeile, auf Höhe des
Funktionsnamens.</p>
<pre class="r"><code># bitte
flights |&gt;  
  group_by(tailnum) |&gt; 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE),
    n = n()
  )

# nicht
flights|&gt;
  group_by(tailnum) |&gt; 
  summarize(
             delay = mean(arr_delay, na.rm = TRUE), 
             n = n()
           )

flights|&gt;
  group_by(tailnum) |&gt; 
  summarize(
  delay = mean(arr_delay, na.rm = TRUE), 
  n = n()
  )</code></pre>
<p>Manchmal passt der komplette Befehl in eine Zeile, jedoch wächst
erfahrungsgemäß die Zeile schnell an.</p>
<pre class="r"><code># alles passt kompakt in eine Zeile
df |&gt; mutate(y = x + 1)

# vier mal so viel Zeilen, jedoch einfach zu verlängern 
# mehr Variable und Schritte in der Zukunft.
df |&gt; 
  mutate(
    y = x + 1
  )</code></pre>
<p>Vermeide es zu lange <em>Pipes</em> von mehr als 10-15 Zeilen zu
schreiben. Breche sie runter in Unteraufgaben und verpasse ihnen
günstige Namen. Wichtig.</p>
</div>
<div id="ggplot2" class="section level2" number="5.4">
<h2><span class="header-section-number">5.4</span> ggplot2</h2>
<p>Was für <code>|&gt;</code> bei der <em>Pipe</em> gilt, gilt natürlich
auch für <code>+</code> bei <code>ggplot2</code>.</p>
<pre class="r"><code>flights |&gt; 
  group_by(month) |&gt; 
  summarize(
    delay = mean(arr_delay, na.rm = TRUE)
  ) |&gt; 
  ggplot(aes(x = month, y = delay)) +
  geom_point() + 
  geom_line()</code></pre>
<p>Jedes Argument kommt in ihre eigene Zeile.</p>
<pre class="r"><code>flights |&gt; 
  group_by(dest) |&gt; 
  summarize(
    distance = mean(distance),
    speed = mean(air_time / distance, na.rm = TRUE)
  ) |&gt; 
  ggplot(aes(x = distance, y = speed)) +
  geom_smooth(
    method = &quot;loess&quot;,
    span = 0.5,
    se = FALSE, 
    color = &quot;white&quot;, 
    size = 4
  ) +
  geom_point()</code></pre>
</div>
<div id="sectioning-comments" class="section level2" number="5.5">
<h2><span class="header-section-number">5.5</span> Sectioning
Comments</h2>
<p>Wird dein Skript länger, so trenne es in kleinere Happen. Verpasse
Kommentare und hebe sie optisch hervor.</p>
<pre class="r"><code># Load data --------------------------------------

# Plot data --------------------------------------</code></pre>
<p>Mit Cmd + Shift + R werden sie unten links im Editor angezeigt, in
einer <em>drop-down</em> Liste.</p>
</div>
</div>
<div id="daten-importieren" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Daten importieren</h1>
<div id="einleitung-2" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> Einleitung</h2>
<p>Mit den von R bereitgestellten Daten zu arbeiten hilft ungemein, aber
für eigene Projekte wollen wir natürlich auch mal eigene Daten
importieren.</p>
<div id="voraussetzungen-2" class="section level3" number="6.1.1">
<h3><span class="header-section-number">6.1.1</span>
Voraussetzungen</h3>
<p>Dazu brauchen wit das <strong>readr</strong> Paket, welches Teil des
tidyverse ist.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
</div>
<div id="daten-aus-datei-einlesen" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Daten aus Datei
einlesen</h2>
<p>Zu Beginn konzentrieren wir uns auf eine <em>.csv</em> Datei:<br />
In der ersten Zeile stehen für gewöhnlich die Spaltennamen, danach
kommen die Daten.</p>
<pre class="r"><code>#&gt; Student ID, Full Name,Age
#&gt; 1,Sunil Huffmann,4
#&gt; 2,Baclay Lynn,5
#&gt; 3,Peter Pan,7
#&gt; 4,Leon Leonidas,
#&gt; 5,Marion Farre,five
#&gt; 6,Attila Attilon,6</code></pre>
<p>Diese Daten können wir aus der Datei einlesen mit
<code>read_csv()</code>. Zwei Spalten haben wir noch hinzugefügt</p>
<pre class="r"><code>students &lt;- read_csv(&quot;data/students.csv&quot;)</code></pre>
<pre><code>## Rows: 6 Columns: 5
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr (4): Full Name, favourite.food, mealPlan, AGE
## dbl (1): Student ID
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<p>Bei Ausgabe wird die Anzahl der Zeilen und Spalten genannt, das
Trennzeichen und die Spalten-Spezifikationen: Namen und Datentyp.</p>
<div id="praktische-hinweise" class="section level3" number="6.2.1">
<h3><span class="header-section-number">6.2.1</span> Praktische
Hinweise</h3>
<p>Nach dem Einlesen werden die Daten für gewöhnlich transformiert, so
dass wir mit ihnen einfacher arbeiten können. In der
<code>favourite.food</code> Spalte haben wir den
<code>Character String</code> <code>N/A</code>, den wir in ein
“richtiges” <code>NA</code>, not available, transformieren wollen.</p>
<pre class="r"><code>students &lt;- read_csv(&quot;data/students.csv&quot;, na = c(&quot;N/A&quot;, &quot;&quot;))</code></pre>
<pre><code>## Rows: 6 Columns: 5
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr (4): Full Name, favourite.food, mealPlan, AGE
## dbl (1): Student ID
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre class="r"><code>students</code></pre>
<pre><code>## # A tibble: 6 × 5
##   `Student ID` `Full Name`    favourite.food     mealPlan            AGE  
##          &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;
## 1            1 Sunil Huffmann Strawberry yoghurt Lunch only          4    
## 2            2 Baclay Lynn    French Fries       Lunch only          5    
## 3            3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch 7    
## 4            4 Leon Leonidas  Anchovies          Lunch only          &lt;NA&gt; 
## 5            5 Marion Farre   Pizza              Breakfast and Lunch five 
## 6            6 Attila Attilon Ice cream          Lunch only          6</code></pre>
<p><code>Student ID</code> und <code>Full Name</code> sind umgeben von
<em>Backticks</em>. Das passiert, weil es Leerzeichen in den
Variablennamen gibt, so dass die Namensregeln für Variablen gebrochen
werden. Wir können natürlich die Variablennamen umbenennen.</p>
<pre class="r"><code>students |&gt; 
  rename(
    student_id = `Student ID`,
    full_name = `Full Name`
  )</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite.food     mealPlan            AGE  
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only          4    
## 2          2 Baclay Lynn    French Fries       Lunch only          5    
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch 7    
## 4          4 Leon Leonidas  Anchovies          Lunch only          &lt;NA&gt; 
## 5          5 Marion Farre   Pizza              Breakfast and Lunch five 
## 6          6 Attila Attilon Ice cream          Lunch only          6</code></pre>
<p>Eine Alternatie ist es <code>janitor::clean_names()</code> zu
benutzen, so dass heuristisch alle Namen in angenehme Formate gebracht
werden.</p>
<pre class="r"><code>library(janitor)</code></pre>
<pre><code>## Warning: Paket &#39;janitor&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## 
## Attache Paket: &#39;janitor&#39;</code></pre>
<pre><code>## Die folgenden Objekte sind maskiert von &#39;package:stats&#39;:
## 
##     chisq.test, fisher.test</code></pre>
<pre class="r"><code>students |&gt; janitor::clean_names()</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite_food     meal_plan           age  
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;chr&gt;               &lt;chr&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only          4    
## 2          2 Baclay Lynn    French Fries       Lunch only          5    
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch 7    
## 4          4 Leon Leonidas  Anchovies          Lunch only          &lt;NA&gt; 
## 5          5 Marion Farre   Pizza              Breakfast and Lunch five 
## 6          6 Attila Attilon Ice cream          Lunch only          6</code></pre>
<p>Eine andere gewöhnliche Aufgabe ist es den Variablentyp zu bedenken.
Zum Beispiel ist <code>meal_type</code> eine kategoriale Variable mit
einer bekannten Menge an möglichen Werten, die in R als Faktoren
dargestellt werden sollten.</p>
<pre class="r"><code>students |&gt;
  janitor::clean_names() |&gt;
  mutate(
    meal_plan = factor(meal_plan)
  )</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite_food     meal_plan           age  
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;fct&gt;               &lt;chr&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only          4    
## 2          2 Baclay Lynn    French Fries       Lunch only          5    
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch 7    
## 4          4 Leon Leonidas  Anchovies          Lunch only          &lt;NA&gt; 
## 5          5 Marion Farre   Pizza              Breakfast and Lunch five 
## 6          6 Attila Attilon Ice cream          Lunch only          6</code></pre>
<p>Die Werte sind gleich geblieben, nur der Typ der Variablen (unterhalb
der Namen) hat sich von <em>Character</em> <code>&lt;chr&gt;</code> zu
Faktor <code>&lt;fct&gt;</code> geändert.</p>
<p>Als nächstes wollen wir noch die <code>age</code> Spalte reparieren.
Sein Typ ist <em>Character</em>, weil in einer Zeile <code>five</code>,
statt <code>5</code> steht.</p>
<pre class="r"><code>students &lt;- students |&gt;
  janitor::clean_names() |&gt;
  mutate(
    meal_plan = factor(meal_plan),
    age = parse_number(if_else(age == &quot;five&quot;, &quot;5&quot;, age))
  )

students</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite_food     meal_plan             age
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only              4
## 2          2 Baclay Lynn    French Fries       Lunch only              5
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch     7
## 4          4 Leon Leonidas  Anchovies          Lunch only             NA
## 5          5 Marion Farre   Pizza              Breakfast and Lunch     5
## 6          6 Attila Attilon Ice cream          Lunch only              6</code></pre>
</div>
<div id="andere-argumente" class="section level3" number="6.2.2">
<h3><span class="header-section-number">6.2.2</span> Andere
Argumente</h3>
<p>Ein Trick am Anfang: <code>read_csv()</code> kann in einem
<em>String</em> kreierte csv Dateien lesen:</p>
<pre class="r"><code>read_csv(
  &quot;a,b,c
  1,2,3
  4,5,6&quot;
)</code></pre>
<pre><code>## Rows: 2 Columns: 3
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## dbl (3): a, b, c
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 2 × 3
##       a     b     c
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     3
## 2     4     5     6</code></pre>
<p>Die erste Zeile wird für die Variablen benutzt. Manchmal finden wir
noch davor Metadaten, die du durch <code>skip = n</code> weglassen
kannst. In diesem Fall die ersten n Zeilen. Oder benutze Kommentare wie
folgt:</p>
<pre class="r"><code>read_csv(
  &quot;The first line of metadata
  The second line of metadata
  x,y,z
  1,2,3&quot;,
  skip = 2
)</code></pre>
<pre><code>## Rows: 1 Columns: 3
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## dbl (3): x, y, z
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 1 × 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     3</code></pre>
<pre class="r"><code>read_csv(
  &quot;# A comment I want to skip
  x,y,z
  1,2,3&quot;,
  comment = &quot;#&quot;
)</code></pre>
<pre><code>## Rows: 1 Columns: 3
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## dbl (3): x, y, z
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 1 × 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     3</code></pre>
<p>Manchmal haben Daten keine Spaltennamen. Durch
<code>col_names = FALSE</code> teilst du dies R mit, so dass die erste
Zeile nicht als Kopf benutzt wird, sondern R automatisch Spaltennamen
von <code>X1</code> bis <code>Xn</code> ausgibt.</p>
<pre class="r"><code>read_csv(
  &quot;1,2,3
  4,5,6&quot;,
  col_names = FALSE
)</code></pre>
<pre><code>## Rows: 2 Columns: 3
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## dbl (3): X1, X2, X3
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 2 × 3
##      X1    X2    X3
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     3
## 2     4     5     6</code></pre>
<p>Einen <em>Character</em> Vektor mit Spaltennamen kannst du natürlich
auch an die Tabelle übergeben.</p>
<pre class="r"><code>read_csv(
  &quot;1,2,3
  4,5,6&quot;,
  col_names = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
)</code></pre>
<pre><code>## Rows: 2 Columns: 3
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## dbl (3): x, y, z
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 2 × 3
##       x     y     z
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     2     3
## 2     4     5     6</code></pre>
<p>Für mehr Informationen, schau in der Dokumentation von
<code>read_csv()</code> nach.</p>
</div>
<div id="andere-dateitypen" class="section level3" number="6.2.3">
<h3><span class="header-section-number">6.2.3</span> Andere
Dateitypen</h3>
<p>Hast du bis jetzt alles verstanden, sind andere Typen unkompliziert:
<code>read_csv2()</code>, <code>read_tsv()</code>,
<code>read_delim()</code>, <code>read_fwf()</code>,
<code>read_table()</code>, <code>read_log()</code>.</p>
</div>
</div>
<div id="spaltentypen-kontrollieren" class="section level2"
number="6.3">
<h2><span class="header-section-number">6.3</span> Spaltentypen
kontrollieren</h2>
<p>Der Typ jeder Variable wird von <strong>readr</strong> geraten, da
eine CSV keine Informationen liefert.</p>
<div id="guessing-types" class="section level3" number="6.3.1">
<h3><span class="header-section-number">6.3.1</span> Guessing Types</h3>
<p>Für das Raten wird eine Heuristik von <code>readr</code> genutzt. Es
geht die Reihen durch:</p>
<ul>
<li><p>Gibt es <code>F</code>, <code>T</code>, <code>FALSE</code>,
<code>TRUE</code>? Wenn ja, dann ist der Typ <em>logical</em>.</p></li>
<li><p>Gibt es Zahlen? Dann <em>number</em>.</p></li>
<li><p>Matcht es dem ISO8601 Standard? Dann <em>date</em> oder
<em>date-time</em>.</p></li>
<li><p>Ansonsten muss es wohl ein <em>String</em> sein.</p></li>
</ul>
<pre class="r"><code>read_csv(&quot;
  logical,numeric,date,string
  TRUE,1,2021-01-15,abc
  false,4.5,2021-02-15,def
  T,Inf,2021-02-16,ghi&quot;
)</code></pre>
<pre><code>## Rows: 3 Columns: 4
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr  (1): string
## dbl  (1): numeric
## lgl  (1): logical
## date (1): date
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 3 × 4
##   logical numeric date       string
##   &lt;lgl&gt;     &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt; 
## 1 TRUE        1   2021-01-15 abc   
## 2 FALSE       4.5 2021-02-15 def   
## 3 TRUE      Inf   2021-02-16 ghi</code></pre>
<p>Bei einem “netten” Datensatz funktioniert es. Ansonsten nicht.</p>
</div>
<div id="missing-values-spaltentypen-und-probleme"
class="section level3" number="6.3.2">
<h3><span class="header-section-number">6.3.2</span> Missing Values,
Spaltentypen und Probleme</h3>
<p>Erscheinen unerwartete Werte, so erhalten wir oft einen
<em>Character</em> als Datentyp. Oft ist ein <code>NA</code> dafür
verantwortlich. Schauen wir uns ein einfaches Problem an.</p>
<pre class="r"><code>csv &lt;- &quot;
  x
  10
  .
  20
  30&quot;</code></pre>
<p>Einlesen ergibt:</p>
<pre class="r"><code>df &lt;- read_csv(csv)</code></pre>
<pre><code>## Rows: 4 Columns: 1
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr (1): x
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<p>Der <em>Missing Value</em> ist schnell gefunden <code>.</code>. Bei
Tausenden von Reihen fällt das Aufspüren aber schwerer.<br />
Wir können <code>readr</code> sagen, dass <code>x</code> eine numerische
Spalte ist und dann schauen wo es Probleme gibt. Dies geschieht mit dem
<code>col_types</code> Argument, das eine benannte Liste entgegen
nimmt.</p>
<pre class="r"><code>df &lt;- read_csv(csv, col_types = list(x = col_double()))</code></pre>
<pre><code>## Warning: One or more parsing issues, call `problems()` on your data frame for details,
## e.g.:
##   dat &lt;- vroom(...)
##   problems(dat)</code></pre>
<p>Ein Problem wird angezeigt. Mehr können wir herausfinden mit
<code>problems()</code>:</p>
<pre class="r"><code>problems(df)</code></pre>
<pre><code>## # A tibble: 1 × 5
##     row   col expected actual file                                              
##   &lt;int&gt; &lt;int&gt; &lt;chr&gt;    &lt;chr&gt;  &lt;chr&gt;                                             
## 1     3     1 a double .      C:/Users/nikla/AppData/Local/Temp/Rtmp4Uc8jV/file…</code></pre>
<p><code>readr</code> erwartete ein <code>double</code>, aber bekam ein
<code>.</code>. Das lässt vermuten, dass der Dataset <code>.</code> für
<em>Missing Values</em> benutzt. Wir setzen dafür
<code>na = "."</code>.</p>
<pre class="r"><code>df &lt;- read_csv(csv, na = &quot;.&quot;)</code></pre>
<pre><code>## Rows: 4 Columns: 1
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## dbl (1): x
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
</div>
<div id="spaltentypen" class="section level3" number="6.3.3">
<h3><span class="header-section-number">6.3.3</span> Spaltentypen</h3>
<p><code>readr</code> bietet neun Spaltentypen an:</p>
<ul>
<li><p><code>col_logical()</code> und <code>col_double()</code> liest
<em>logicals</em> und <em>numbers</em>. Sie werden selten gebraucht, da
<code>readr</code> sie meist für uns rät.</p></li>
<li><p><code>col_integer()</code> liest <em>integers</em> (ganze
Zahlen). Sie verbrauchen nur halb so viel Platz wie <em>doubles</em> im
Memory, sind also nicht unwichtig.</p></li>
<li><p><code>col_character()</code> liest <em>Strings</em>.</p></li>
<li><p><code>col_factor()</code>, <code>col_date()</code> und
<code>col_datime()</code> kreieren Faktoren, <em>dates</em> und
<em>date-time</em>.</p></li>
<li><p><code>col_number()</code> ignoriert nicht-numerische
Komponenten.</p></li>
<li><p><code>col_skip()</code> lässt eine Spalte weg.</p></li>
</ul>
<p>Überschreiben vom Spaltentyp ist möglich, durch wechseln von
<code>list()</code> zu <code>cols()</code>.</p>
<pre class="r"><code>csv &lt;- &quot;
x,y,z
1,2,3&quot;

read_csv(csv, col_types = cols(.default = col_character()))</code></pre>
<pre><code>## # A tibble: 1 × 3
##   x     y     z    
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 1     2     3</code></pre>
<p>Oder neu schreiben.</p>
<pre class="r"><code>read_csv(csv, col_types = list(x = col_double(), y = col_integer(), z = col_double()))</code></pre>
<pre><code>## # A tibble: 1 × 3
##       x     y     z
##   &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt;
## 1     1     2     3</code></pre>
<p><code>cols_only()</code> liest nur die gewollte Spalte ein.</p>
<pre class="r"><code>read_csv(
  &quot;x,y,z
  1,2,3&quot;,
  col_types = cols_only(x = col_character())
)</code></pre>
<pre><code>## # A tibble: 1 × 1
##   x    
##   &lt;chr&gt;
## 1 1</code></pre>
</div>
</div>
<div id="daten-aus-multiplen-dateien-einlesen" class="section level2"
number="6.4">
<h2><span class="header-section-number">6.4</span> Daten aus multiplen
Dateien einlesen</h2>
<p>Hast du <em>Sales</em> Daten von verschiedenen Monaten in
verschiedenen Dateien, so kannst du sie zusammenfügen mit
<code>read_csv()</code>.</p>
<pre class="r"><code>sales_files &lt;- c(&quot;data/01-sales.csv&quot;, &quot;data/02-sales.csv&quot;, &quot;data/03-sales.csv&quot;)
read_csv(sales_files, id = &quot;file&quot;)</code></pre>
<p>Der neue Parameter <code>id</code> fügt eine neue Spalte hinzu, der
die Herkunft der Datei angibt.<br />
Es kann mühselig sein die Namen als Liste zu schreiben, wenn man viele
Dateien hat. Benutze <code>list.files()</code> um die Dateien für dich
zu finden. Ein Muster sollte im Namen vorhanden sein.</p>
<pre class="r"><code>sales_files &lt;- list.files(&quot;data&quot;, pattern = &quot;sales\\.csv$&quot;, full.names = TRUE)
sales_files</code></pre>
</div>
<div id="dateien-schreiben" class="section level2" number="6.5">
<h2><span class="header-section-number">6.5</span> Dateien
schreiben</h2>
<p><code>readr</code> bietet zwei Funktionen, um Daten zu schreiben:
<code>write_csv()</code>, <code>write_tsv()</code>. Als Argumente
brauchst du den <em>Data Frame</em> und den Ort.</p>
<pre class="r"><code>write_csv(students, &quot;students.csv&quot;)</code></pre>
<p>Die <em>type information</em> geht beim Schreiben als
<code>csv</code> verloren.</p>
<pre class="r"><code>students</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite_food     meal_plan             age
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only              4
## 2          2 Baclay Lynn    French Fries       Lunch only              5
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch     7
## 4          4 Leon Leonidas  Anchovies          Lunch only             NA
## 5          5 Marion Farre   Pizza              Breakfast and Lunch     5
## 6          6 Attila Attilon Ice cream          Lunch only              6</code></pre>
<pre class="r"><code>write_csv(students, &quot;data/students-2.csv&quot;)
read_csv(&quot;data/students-2.csv&quot;)</code></pre>
<pre><code>## Rows: 6 Columns: 5
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## chr (3): full_name, favourite_food, meal_plan
## dbl (2): student_id, age
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite_food     meal_plan             age
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;chr&gt;               &lt;dbl&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only              4
## 2          2 Baclay Lynn    French Fries       Lunch only              5
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch     7
## 4          4 Leon Leonidas  Anchovies          Lunch only             NA
## 5          5 Marion Farre   Pizza              Breakfast and Lunch     5
## 6          6 Attila Attilon Ice cream          Lunch only              6</code></pre>
<p>Das macht CSVs ein wenig unzuverlässig für Zwischenergebnisse. Du
musst die Spaltenspezifikation jedes mal aufs Neue kreieren. Es gibt
zwei Alternativen:</p>
<ol style="list-style-type: decimal">
<li><code>write_rds()</code> und <code>read_rds()</code>. Sie lagern
Daten in R’s binary Format RDS.</li>
</ol>
<pre class="r"><code>write_rds(students, &quot;data/students.rds&quot;)
read_rds(&quot;data/students.rds&quot;)</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite_food     meal_plan             age
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only              4
## 2          2 Baclay Lynn    French Fries       Lunch only              5
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch     7
## 4          4 Leon Leonidas  Anchovies          Lunch only             NA
## 5          5 Marion Farre   Pizza              Breakfast and Lunch     5
## 6          6 Attila Attilon Ice cream          Lunch only              6</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Das <em>arrow</em> Paket mit <em>parquet</em> Dateien.</li>
</ol>
<pre class="r"><code>library(arrow)</code></pre>
<pre><code>## Warning: Paket &#39;arrow&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## 
## Attache Paket: &#39;arrow&#39;</code></pre>
<pre><code>## Das folgende Objekt ist maskiert &#39;package:lubridate&#39;:
## 
##     duration</code></pre>
<pre><code>## Das folgende Objekt ist maskiert &#39;package:utils&#39;:
## 
##     timestamp</code></pre>
<pre class="r"><code>write_parquet(students, &quot;data/students.parquet&quot;)
read_parquet(&quot;data/students.parquet&quot;)</code></pre>
<pre><code>## # A tibble: 6 × 5
##   student_id full_name      favourite_food     meal_plan             age
##        &lt;dbl&gt; &lt;chr&gt;          &lt;chr&gt;              &lt;fct&gt;               &lt;dbl&gt;
## 1          1 Sunil Huffmann Strawberry yoghurt Lunch only              4
## 2          2 Baclay Lynn    French Fries       Lunch only              5
## 3          3 Peter Pan      &lt;NA&gt;               Breakfast and Lunch     7
## 4          4 Leon Leonidas  Anchovies          Lunch only             NA
## 5          5 Marion Farre   Pizza              Breakfast and Lunch     5
## 6          6 Attila Attilon Ice cream          Lunch only              6</code></pre>
<p><em>Parquets</em> sind schneller als RDS, aber brauchen das
Paket.</p>
</div>
<div id="data-entry" class="section level2" number="6.6">
<h2><span class="header-section-number">6.6</span> Data Entry</h2>
<p>Manchmal musst du ein <code>tibble()</code> mit der Hand
schreiben.</p>
<pre class="r"><code>tibble(
  x = c(1, 2, 5),
  y = c(&quot;h&quot;, &quot;m&quot;, &quot;g&quot;),
  z = c(0.08, 0.83, 0.60)
)</code></pre>
<pre><code>## # A tibble: 3 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     1 h      0.08
## 2     2 m      0.83
## 3     5 g      0.6</code></pre>
<p>Jede Spalte muss natürlich die selbe Länge haben.<br />
<code>tribble()</code> liest die Daten zeilenweise ein. Spaltennamen
starten mit <code>~</code>, Einträge werden durch Komma getrennt.</p>
<pre class="r"><code>tribble(
  ~x, ~y, ~z,
  &quot;h&quot;, 1, 0.08,
  &quot;m&quot;, 2, 0.83,
  &quot;g&quot;, 5, 0.60,
)</code></pre>
<pre><code>## # A tibble: 3 × 3
##   x         y     z
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 h         1  0.08
## 2 m         2  0.83
## 3 g         5  0.6</code></pre>
</div>
</div>
<div id="visualisieren-layers" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Visualisieren:
Layers</h1>
<div id="einleitung-3" class="section level2" number="7.1">
<h2><span class="header-section-number">7.1</span> Einleitung</h2>
<p>In Kapitel 2 haben wir uns mit Plots beschäftigt. In diesem Abschnitt
erweitern wir unser Wissen und lernen etwas über die geschichtete
Grammatik von Grafiken.</p>
<div id="voraussetzung" class="section level3" number="7.1.1">
<h3><span class="header-section-number">7.1.1</span> Voraussetzung</h3>
<p>In diesem Abschnitt konzentrieren wir uns natürlich auf
<code>ggplot2</code>. Lade <code>tidyverse</code>.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
</div>
<div id="aesthetic-mappings" class="section level2" number="7.2">
<h2><span class="header-section-number">7.2</span> Aesthetic
Mappings</h2>
<p>Unser <code>mpg</code> Datensatz (Autos) hat 234 Zeilen und 11
Spalten:</p>
<pre class="r"><code>ggplot2::mpg</code></pre>
<pre><code>## # A tibble: 234 × 11
##    manufacturer model      displ  year   cyl trans drv     cty   hwy fl    class
##    &lt;chr&gt;        &lt;chr&gt;      &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
##  1 audi         a4           1.8  1999     4 auto… f        18    29 p     comp…
##  2 audi         a4           1.8  1999     4 manu… f        21    29 p     comp…
##  3 audi         a4           2    2008     4 manu… f        20    31 p     comp…
##  4 audi         a4           2    2008     4 auto… f        21    30 p     comp…
##  5 audi         a4           2.8  1999     6 auto… f        16    26 p     comp…
##  6 audi         a4           2.8  1999     6 manu… f        18    26 p     comp…
##  7 audi         a4           3.1  2008     6 auto… f        18    27 p     comp…
##  8 audi         a4 quattro   1.8  1999     4 manu… 4        18    26 p     comp…
##  9 audi         a4 quattro   1.8  1999     4 auto… 4        16    25 p     comp…
## 10 audi         a4 quattro   2    2008     4 manu… 4        20    28 p     comp…
## # ℹ 224 more rows</code></pre>
<p>Interessante Variablen für uns sind:</p>
<ol style="list-style-type: decimal">
<li><p><code>displ</code>: Hubraum in Liter. Numerische
Variable.</p></li>
<li><p><code>hwy</code>: Treibstoffeffizienz in Meilen pro Gallone.
Numerische Variable.</p></li>
<li><p><code>class</code>: Autotyp. Kategoriale Variable.</p></li>
</ol>
<p>Mehr zu <code>mpg</code> auf der entsprechenden Hilfsseite über
<code>?mpg</code>.</p>
<p>Zuerst wollen wir die Beziehung zwischen <code>displ</code> und
<code>hwy</code> visualisieren, für die verschiedenen Klassen von Autos.
Ein <em>Scatterplot</em> mit <code>x</code> und <code>y</code>
<code>aes</code> und der kategorialen Variable als <code>color</code>
oder <code>shape</code> überrascht hier weniger.</p>
<pre class="r"><code># Left
ggplot(mpg, aes(x = displ, y = hwy, color = class)) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-125-1.png" width="672" /></p>
<pre class="r"><code># Right
ggplot(mpg, aes(x = displ, y = hwy, shape = class)) +
  geom_point()</code></pre>
<pre><code>## Warning: The shape palette can deal with a maximum of 6 discrete values because
## more than 6 becomes difficult to discriminate; you have 7. Consider
## specifying shapes manually if you must have them.</code></pre>
<pre><code>## Warning: Removed 62 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-125-2.png" width="672" /></p>
<p>Wir kriegen zwei Warnungen. Auf der <code>shape</code> Seite können
wir nur 6 verschiedene Symbole als Punkte darstellen, wir haben aber 7.
Eventuell können wir hier manuell auf 7 kommen.</p>
<p>Zusätzlich werden 62 Zeilen vernachlässigt, da <em>Missing
Values</em> vorliegen. Diese sind die SUVs, die nicht geplotted wurden,
da mehr als 6 Formen nicht mögich sind.<br />
Statt Farben unf Formen können wir auch Größe und Transparenz
plotten.</p>
<pre class="r"><code># Left
ggplot(mpg, aes(x = displ, y = hwy, size = class)) +
  geom_point()</code></pre>
<pre><code>## Warning: Using size for a discrete variable is not advised.</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-126-1.png" width="672" /></p>
<pre class="r"><code># Right
ggplot(mpg, aes(x = displ, y = hwy, alpha = class)) +
  geom_point()</code></pre>
<pre><code>## Warning: Using alpha for a discrete variable is not advised.</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-126-2.png" width="672" /></p>
<p>Warnungen erscheinen ebenfalls. Es ist nicht ratsam eine
nicht-ordinale diskrete Variable mit Hilfe einer geordneten
<code>aes</code> (<code>size</code> oder <code>alpha</code>) abzubilden,
da eine Reihenfolge hier gar nicht existiert. Größe und Transparenz
suggerieren dies aber.<br />
Bilden wir ein <code>aes</code> ab, so sorgt <code>ggplot2</code> für
den Rest. Eine Legende, die die Zuordnung zwischen den Stufen und Werten
erklärt. Diese wird bei uns nicht gebaut, dafür Achsen mit Markierungen
und Werten. Du kannst <code>aes</code> Eigenschaften unseres
<code>geom</code> manuell setzen, wie z.B. blaue Punkte.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(color = &quot;blue&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-127-1.png" width="672" /></p>
<p>Ein <em>aesthetic</em> kannst du setzen durch den Namen als Argument
der <code>geom</code> Funktion, als Wert musst du etwas sinnvolles
finden:</p>
<ul>
<li>Name der Farbe als <em>String</em></li>
<li>Größe des Punktes in mm</li>
<li>Form des Punktes als Zahl (0-20), siehe Hilfeseiten.</li>
</ul>
</div>
<div id="geometrische-objekte" class="section level2" number="7.3">
<h2><span class="header-section-number">7.3</span> Geometrische
Objekte</h2>
<pre class="r"><code># Left
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-128-1.png" width="672" /></p>
<pre class="r"><code># Right
ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-128-2.png" width="672" /></p>
<p>Beide Plots nutzen verschiedene geometrische Objekte (<em>geom</em>),
um die Daten zu repräsentieren:</p>
<p><em>point geom</em> (Punkte) vs. <em>smooth geom</em> (Linie).</p>
<p>Jede <code>geom</code> Funktion in <code>ggplot2</code> nimmt ein
<code>mapping</code> Argument, aber nicht jedes <code>aes</code>
funktioniert mit jedem <code>geom</code>. Den <em>shape</em> einer Linie
zu setzen macht keinen Sinn. Wenn du es versuchst, so ignoriert
<code>ggplot2</code> dieses <em>aes mapping</em>.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy, shape = drv)) + 
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-129-1.png" width="672" /></p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy, linetype = drv)) + 
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-129-2.png" width="672" /></p>
<p>Hier sorgt <code>geom_smooth()</code> für drei Linie, basierend auf
ihrem <code>drv</code> Wert (Antrieb). <code>4</code> steht für
4-Rad-Antrieb, <code>f</code> Vorderantrieb, <code>r</code>
Heckantrieb.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy, linetype = drv, color = drv)) + 
  geom_smooth() +
  geom_point()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-130-1.png" width="672" /></p>
<p>Dieser Plot enthält zwei <code>geoms</code> im selben Graphen. Viele
<code>geoms</code>, wie <code>geom_smooth()</code> geben multiple Reihen
von Daten aus. Für sie kannst du <code>group</code> <code>aes</code> zu
kategorialen Variablen setzen, um multiple Objekte zu zeichnen.
<code>ggplot2</code> zeichnet aber immer ein separates Objekt für jeden
Wert der gruppierenden Variable. Mach davon gebrauch, da der
<code>group</code> aes keine Legende liefert.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-131-1.png" width="672" /></p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(group = drv))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-131-2.png" width="672" /></p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_smooth(aes(color = drv), show.legend = FALSE)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-131-3.png" width="672" /></p>
<p>Wenn du Zuordnungen in einer <code>geom</code> Funktion platzierst,
behandelt <code>ggplot2</code> sie als lokale <em>Mappings</em>. Es
erweitert oder überschreibt die globalen <em>Mappings</em> für diese
Ebene (<em>layer</em>). So kann man verschiedene <code>aes</code> in
verschiedenen Ebenen anzeigen.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(aes(color = class)) + 
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-132-1.png" width="672" /></p>
<p>Diese Idee kannst du genauso benutzen, um verschiedene Daten für jede
Ebene zu benutzen. Rote Punkte und Kreise zeigen Zweisitzer-Autos an.
Das lokale Daten-Argument in <code>geom_smooth()</code> überschreibt das
globale in <code>ggplot2</code> für diese eine Ebene.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_point(
    data = mpg |&gt; filter(class == &quot;2seater&quot;), 
    color = &quot;red&quot;
  ) +
  geom_point(
    data = mpg |&gt; filter(class == &quot;2seater&quot;), 
    shape = &quot;circle open&quot;, size = 3, color = &quot;red&quot;
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-133-1.png" width="672" /></p>
<p><em>Geoms</em> sind die wichtigen Fundamente bei der Erstellung von
<em>ggplots</em>. Der Look des Plots kann komplett durch die Wahl dieser
bestimmt und verändert werden. Unten erkennen wir, dass es zwei
Ausreißer gibt, die Verteilung zweigipflig und rechtsschief ist. Dafür
betrachten wir uns verschiedene Plots.</p>
<pre class="r"><code># Left
ggplot(mpg, aes(x = hwy)) +
  geom_histogram(binwidth = 2)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-134-1.png" width="672" /></p>
<pre class="r"><code># Middle
ggplot(mpg, aes(x = hwy)) +
  geom_density()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-134-2.png" width="672" /></p>
<pre class="r"><code># Right
ggplot(mpg, aes(x = hwy)) +
  geom_boxplot()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-134-3.png" width="672" /></p>
<p><code>ggplot2</code> bietet mehr als 40 <em>geoms</em> an, es gibt
aber natürlich noch mehr Möglichkeiten <a
href="https://exts.ggplot2.tidyverse.org/gallery/">Link</a>.</p>
<p>Die Dichte mithilfe von <em>ridgeline plots</em> zu erstellen ist
sehr chic. <code>fill</code> und <code>color</code> machen die Dichten
bunt und <code>alpha</code> transparent.</p>
<pre class="r"><code>library(ggridges)</code></pre>
<pre><code>## Warning: Paket &#39;ggridges&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre class="r"><code>ggplot(mpg, aes(x = hwy, y = drv, fill = drv, color = drv)) +
  geom_density_ridges(alpha = 0.5, show.legend = FALSE)</code></pre>
<pre><code>## Picking joint bandwidth of 1.28</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-135-1.png" width="672" /></p>
<pre class="r"><code>#&gt; Picking joint bandwidth of 1.28</code></pre>
</div>
<div id="facets" class="section level2" number="7.4">
<h2><span class="header-section-number">7.4</span> Facets</h2>
<p>Schon kennengelernt haben wir <code>facet_wrap()</code>, das Plots in
Unterplots unterteilt, basierend auf einer kategorialen Variable.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_wrap(~cyl)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-136-1.png" width="672" /></p>
<p>Um deinen Plot weiter zu unterteilen auf zwei Variablen, benutze
<code>facet_grid()</code>.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-137-1.png" width="672" /></p>
<p><code>cyl</code> und <code>drv</code> sind kategoriale Variablen. Für
beide werden immer wieder dieselben Achsen x und y gewählt. Die Skala
bleibt unverändert. Setzt du das <code>scales</code> Argument in der
<em>facet</em> Funktion auf <code>"free"</code>, so werden automatisch
verschiedene Bereiche der Achsen gesetzt.<br />
Weitere Arguemnte sind <code>free_x</code> und <code>free_y</code> für
jeweils nur eine der beiden Achsen.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  facet_grid(drv ~ cyl, scales = &quot;free&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-138-1.png" width="672" /></p>
</div>
<div id="statistische-transformationen" class="section level2"
number="7.5">
<h2><span class="header-section-number">7.5</span> Statistische
Transformationen</h2>
<p>Ein Balkendiagramm mit <code>geom_bar()</code> oder
<code>geom_col()</code> ist schnell erstellt. Der <code>cut</code>
unseres Diamantendatensatzes ist schnell visualisiert.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut)) + 
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-139-1.png" width="672" /></p>
<p>Auf der y-Achse wird “<em>count</em>” abgetragen. Diese ist aber
keine Variable in <code>diamonds</code>. Der Algorithmus, der benutzt
wird um neue Werte für jeden Graph zu berechnen, heißt
<strong>stat</strong> (<em>statistical transformation</em>).</p>
<p>Welches <em>stat</em> ein <em>geom</em> benutzt, kannst du am
<em>default</em> Wert sehen. <code>?geom_bar</code> zeigt, dass der
<em>default</em> Wert für <code>stat</code> “<em>count</em>” ist.
<code>geom_bar()</code> benutzt also <code>stat_count()</code>, welches
auf derselben Seite wie <code>geom_bar()</code> dokumentiert ist. Im
Abschnitt “<em>Computed Variables</em>” siehst du, dass zwei neue
Variablen berechnet werden: “<em>count</em>” und “<em>prop</em>”. Jedes
<em>geom</em> hat ein <em>default stat</em> und andersrum. Du brauchst
dir also keine Sorgen über die <em>stats</em> zu machen, wenn du
<em>geoms</em> benutzt. Es gibt jedoch drei Gründe, warum du ein
<em>stat</em> explizit benutzen solltest:</p>
<ol style="list-style-type: decimal">
<li>Weil du den <em>default stat</em> überschreiben willst. So können
wir die Höhe der Balken über die <strong>y</strong> Variable der rohen
Werte darstellen.</li>
</ol>
<pre class="r"><code>cut_frequencies &lt;- tribble(
  ~cut,         ~freq,
  &quot;Fair&quot;,       1610,
  &quot;Good&quot;,       4906,
  &quot;Very Good&quot;,  12082,
  &quot;Premium&quot;,    13791,
  &quot;Ideal&quot;,      21551
)

ggplot(cut_frequencies, aes(x = cut, y = freq)) +
  geom_bar(stat = &quot;identity&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-140-1.png" width="672" /></p>
<ol start="2" style="list-style-type: decimal">
<li>Du willst den <em>default</em> überschreiben, da du z.B. an den
relativen, statt den absoluten Häufigkeiten interessiert bist.</li>
</ol>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, y = after_stat(prop), group = 1)) + 
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-141-1.png" width="672" /></p>
<ol start="3" style="list-style-type: decimal">
<li>Du willst mehr Aufmerksamkeit auf die statistische Transformation
legen. <code>stat_summary()</code> fasst die y-Werte zusammen für jeden
x-Wert und gibt Median, Minimum und Maximum aus.</li>
</ol>
<pre class="r"><code>ggplot(diamonds) + 
  stat_summary(
    aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-142-1.png" width="672" /></p>
<p><code>ggplot2</code> bietet mehr als 20 <em>stats</em> an. Jedes ist
eine Funkton.</p>
</div>
<div id="position-adjustments" class="section level2" number="7.6">
<h2><span class="header-section-number">7.6</span> Position
Adjustments</h2>
<p>Die Farben der Balken kannst du mit <code>color</code> oder
<code>fill</code> gestalten.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, color = cut)) + 
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-143-1.png" width="672" /></p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, fill = cut)) + 
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-143-2.png" width="672" /></p>
<p>Was passiert jetzt, wenn du eine weitere Variable hinzufügst? Die
Balken stapeln sich automatisch. Jedes Rechteck repräsentiert eine
Kombination aus <code>cut</code> und <code>clarity</code>.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, fill = clarity)) + 
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-144-1.png" width="672" /></p>
<p>Das Stapeln wird automatisch durch die <strong>position
adjustment</strong> ausgeführt. Du kannst es auch verhindern, indem du
<code>position</code> auf <code>"identity"</code>, <code>"dodge"</code>,
oder <code>"fill"</code> setzt.</p>
<ol style="list-style-type: decimal">
<li><code>position = "identity"</code> platziert jedes Objekt genau an
der anfallenden Position ohne es zu stapeln. Für Balken ist das
natürlich nicht sehr sinnvoll, da viele Überlappungen entstehen. Wir
können die Balken transparent machen (halb, ganz), um das Diagramm ein
wenig anschaulicher zu gestalten. <code>alpha</code> und
<code>fill = NA</code> helfen.</li>
</ol>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = &quot;identity&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-145-1.png" width="672" /></p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, color = clarity)) + 
  geom_bar(fill = NA, position = &quot;identity&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-145-2.png" width="672" /></p>
<ol start="2" style="list-style-type: decimal">
<li><code>position = "fill"</code> arbeitet wie das Stapeln, nur dass
jedes Set von Balken die gleiche Höhe hat. So lassen sich Anteile
leichter vergleichen.</li>
</ol>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, fill = clarity)) + 
  geom_bar(position = &quot;fill&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-146-1.png" width="672" /></p>
<ol start="3" style="list-style-type: decimal">
<li><code>position = "dodge"</code> platziert die überlappenden Objekte
direkt nebeneinander. So lassen sich die individuellen Werte leichter
vergleichen.</li>
</ol>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, fill = clarity)) + 
  geom_bar(position = &quot;dodge&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-147-1.png" width="672" /></p>
<p>Ein weiteres nützliches <em>Adjustment</em> lässt sich für
Scatterplots finden.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-148-1.png" width="672" /></p>
<p>Hier haben wir 126 Punkte, obwohl 234 Beobachtungen im Datensatz
existieren. Warum?<br />
Weil sich viele Punkte überlappen. Das nennt man
<strong>overplotting</strong>. Die Verteilung der Daten ist so schwerer
zu erkennen. Das lässt sich durch <code>position = "jitter"</code>
vermeiden. Die Punkte werden nahe beieinander platziert.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point(position = &quot;jitter&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-149-1.png" width="672" /></p>
</div>
<div id="koordinatensytem" class="section level2" number="7.7">
<h2><span class="header-section-number">7.7</span> Koordinatensytem</h2>
<p>Das kartesische Koordinatensystem mit x-Achse und y-Achse ist
bekannt. Es gibt aber noch zwei weitere Koordinatensysteme.</p>
<ol style="list-style-type: decimal">
<li><code>coord_quickmap()</code> setzt das Abbildungsverhältnis für
Karten. Das ist bei Geodaten mit <code>ggplot2</code> wichtig. Hier wird
nichts verzerrt, die Proportionen bleiben maßstabsgetreu.</li>
</ol>
<pre class="r"><code>nz &lt;- map_data(&quot;nz&quot;)

ggplot(nz, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = &quot;white&quot;, color = &quot;black&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-150-1.png" width="672" /></p>
<pre class="r"><code>ggplot(nz, aes(x = long, y = lat, group = group)) +
  geom_polygon(fill = &quot;white&quot;, color = &quot;black&quot;) +
  coord_quickmap()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-150-2.png" width="672" /></p>
<ol start="2" style="list-style-type: decimal">
<li><code>coord_polar()</code> benutzt Polarkoordianten. Auch eine
schöne Visualisierung (<em>Coxcomb Chart</em>).</li>
</ol>
<pre class="r"><code>bar &lt;- ggplot(data = diamonds) + 
  geom_bar(
    mapping = aes(x = cut, fill = cut), 
    show.legend = FALSE,
    width = 1
  ) + 
  theme(aspect.ratio = 1) +
  labs(x = NULL, y = NULL)

bar + coord_flip()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-151-1.png" width="672" /></p>
<pre class="r"><code>bar + coord_polar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-151-2.png" width="672" /></p>
</div>
<div id="layered-grammar-of-graphics" class="section level2"
number="7.8">
<h2><span class="header-section-number">7.8</span> Layered Grammar of
Graphics</h2>
<p>Ein <strong>Template</strong> für Grafiken mit <em>Position
Adjustments</em>, <em>stats</em>, Koordinatensystem und
<em>Faceting</em> sieht jetzt so aus.</p>
<pre class="r"><code>ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM_FUNCTION&gt;(
     mapping = aes(&lt;MAPPINGS&gt;),
     stat = &lt;STAT&gt;, 
     position = &lt;POSITION&gt;
  ) +
  &lt;COORDINATE_FUNCTION&gt; +
  &lt;FACET_FUNCTION&gt;</code></pre>
<p>Unser neues Template nimmt sieben Parameter. In der Praxis musst du
natürlich selten alle sieben Parameter nennen für einen Graphen, da
<em>defaults</em> vorhanden sind.</p>
<p>Am Anfang steht der Datensatz, den du so transformierst, dass er die
Informationen enthält, die du brauchst (mit <em>stat</em>). Wähle ein
geometrisches (<em>geom</em>) Objekt, um jede Beobachtung darzustellen.
Benutze die <em>aes</em>, um Variablen darzustellen. Dann folgt das
<em>Mapping</em>, du wählst ein passendes Koordinatensystem für deine
<em>geoms</em>, wählst die Achsen weise.</p>
<p>Du hast einen Graphen, kannst <em>Position Adjustments</em>
vornehmen, den Grapen splitten in Subplots. Mehrere Schichten können
hinzugefügt werden, wobei jede Schicht einen <em>Dataset</em>,
<em>geom</em>, <em>Mappings</em>, <em>stat</em> und <em>Position
Adjustment</em> benutzt. Mit diesem Verfahren kannst du Hunderte von
Plots bauen.</p>
</div>
</div>
<div id="visualisieren-explorative-datenanalyse-eda"
class="section level1" number="8">
<h1><span class="header-section-number">8</span> Visualisieren:
Explorative Datenanalyse (EDA)</h1>
<div id="einleitung-4" class="section level2" number="8.1">
<h2><span class="header-section-number">8.1</span> Einleitung</h2>
<p>In diesem Kapitel werden Daten visualisiert, und transformiert. EDA
ist ein wichtiger Teil der Datenanalyse. <em>Data Cleaning</em> gehört
hier genauso zu, wie die <em>Modelling</em>.</p>
<div id="voraussetzungen-3" class="section level3" number="8.1.1">
<h3><span class="header-section-number">8.1.1</span>
Voraussetzungen</h3>
<p>Alles was wir bisher mithilfe von <code>dplyr</code> und
<code>ggplot2</code> kennengelernt haben, kommt hier zur Anwendung.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
</div>
<div id="fragen-1" class="section level2" number="8.2">
<h2><span class="header-section-number">8.2</span> Fragen</h2>
<p>Das Ziel der EDA ist es ein Verständnis deiner Daten zu entwickeln.
Durch Fragestellungen wird dein Interesse auf einen bestimmten Bereich
gelenkt, so dass diese dir helfen die passenden Graphiken, Modelle und
Transformstionen zu wählen.<br />
Es gibt nicht DIE passende Frage, aber Fragen über die Streuung in den
Variablen und Kovarianz zwischen den Daten zu stellen, ist nie
verkehrt.</p>
</div>
<div id="variation" class="section level2" number="8.3">
<h2><span class="header-section-number">8.3</span> Variation</h2>
<p>Jede Messung stetiger oder diskreter Variablen bringt meist eine
gewisse Streuung mit sich. Gewicht, Größe und Alter in der Bevölkerung
sind nämlich nicht konstant. Jede Variable hat ihr eigenes Muster der
Streuung. Um dieses zu verstehen, hilft es erst einmal es zu
visualisieren.</p>
<p>Wir beginnen mit der Visualisierung von Gewichten
(<code>carat</code>). Unser Diamantendatensatz dürfte mittlerweile
bekannt sein. 54 000 Diamanten liegen vor und <code>carat</code> ist
hierbei eine numerische Variable. Wir können sie somit im Histogramm
darstellen.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = carat)) +
  geom_histogram(binwidth = 0.5)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-154-1.png" width="672" /></p>
<div id="typische-werte" class="section level3" number="8.3.1">
<h3><span class="header-section-number">8.3.1</span> Typische Werte</h3>
<p>Im Balkendiagramm und Histogramm stehen hohe Balken für gewöhnliche
und kurze Balken für seltenen Werte. Liegt kein Balken vor, so fehlen
hier die Ausprägungen.</p>
<ul>
<li>Welche Werte kommen warum am häufigsten vor?<br />
</li>
<li>Welche Werte sind rar und wieso?<br />
</li>
<li>Gibt es ein Muster in den Daten?</li>
</ul>
<p>Bei den Diamanten fragt man sich, wieso es Brüche gibt und warum
ganze Werte überproportional häufig vorkommen. Warum ist die Verteilung
der Peaks rechtsschief?</p>
<pre class="r"><code>smaller &lt;- diamonds |&gt; 
  filter(carat &lt; 3)

ggplot(smaller, aes(x = carat)) +
  geom_histogram(binwidth = 0.01)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-155-1.png" width="672" /></p>
<p>Die Länge von 272 Eruptionen eines Geysirs zeigt ein interessantes
Muster auf.</p>
<pre class="r"><code>ggplot(faithful, aes(x = eruptions)) + 
  geom_histogram(binwidth = 0.25)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-156-1.png" width="672" /></p>
<p>Viele Fragen haben mit der Abhängigkeit von zwei Variablen zu tun.
Eine erklärt das Verhalten der anderen.</p>
</div>
<div id="seltene-werte" class="section level3" number="8.3.2">
<h3><span class="header-section-number">8.3.2</span> Seltene Werte</h3>
<p><strong>Ausreißer</strong> sind unübliche Beobachtungen. Sie scheinen
nicht in das Muster der Verteilung zu passen. Manchmal sind sie
Eintragungsfehler, andere Male geben sie neue Erkenntnisse. Im
Histogramm sind sie manchmal schwer zu entdecken.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = y)) + 
  geom_histogram(binwidth = 0.5)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-157-1.png" width="672" /></p>
<p>Um das Entdecken leichter zu machen, müssen wir ein wenig in die
Daten reinzoomen.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = y)) + 
  geom_histogram(binwidth = 0.5) +
  coord_cartesian(ylim = c(0, 50))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-158-1.png" width="672" /></p>
<p><code>coord_cartesian()</code> hat auch ein <code>xlim()</code>
Argument, so dass du in den Bereich der x-Achse reinzoomen kannst.
<code>ggplot2</code> hat auch <code>xlim()</code> und
<code>ylim()</code> Funktionen, die Daten außerhalb der Grenzen
entsorgen.<br />
So entdecken wir drei unübliche Werte: 0, ~30, ~60.</p>
<pre class="r"><code>unusual &lt;- diamonds |&gt; 
  filter(y &lt; 3 | y &gt; 20) |&gt; 
  select(price, x, y, z) |&gt;
  arrange(y)
unusual</code></pre>
<pre><code>## # A tibble: 9 × 4
##   price     x     y     z
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  5139  0      0    0   
## 2  6381  0      0    0   
## 3 12800  0      0    0   
## 4 15686  0      0    0   
## 5 18034  0      0    0   
## 6  2130  0      0    0   
## 7  2130  0      0    0   
## 8  2075  5.15  31.8  5.12
## 9 12210  8.09  58.9  8.06</code></pre>
<p>Die <code>y</code> Variable misst einer der drei Dimensionen des
Diamanten in mm. Eine Breite von 0 mm ist natürlich nicht möglich, also
falsch. Die großen Diamanten müssen auch falsch sein, da die Kosten
nicht mit der Größe korrelieren.<br />
Die Analyse kann mit und ohne Ausreißer gefahren werden. Hier können sie
rausgenommen werden. Verändern sie das Bild der Daten; so meist nicht.
Welche Gründe gibt es? Ein Ausschluss muss gerechtfertigt sein.</p>
</div>
</div>
<div id="unübliche-werte-bearbeiten" class="section level2"
number="8.4">
<h2><span class="header-section-number">8.4</span> Unübliche Werte
bearbeiten</h2>
<p>Bei der Analyse von unüblichen Werten hast du zwei Möglichkeiten.</p>
<ol style="list-style-type: decimal">
<li>Schließe die ganze Zeile aus:</li>
</ol>
<pre class="r"><code>diamonds2 &lt;- diamonds |&gt; 
  filter(between(y, 3, 20))</code></pre>
<p>Es ist nicht zu empfehlen, da ganze Beobachtungsreihen ausgeschlossen
werden, statt einer defekten. Auch kann dann dein Datensatz zu stark
reduziert sein.</p>
<ol start="2" style="list-style-type: decimal">
<li>Ersetze die ungewöhnlichen Werte durch <em>Missing Values</em>. Dies
geschieht am einfachsten mit <code>mutate()</code>. Der
<code>ifelse()</code> Befehl hilft hier. <code>if_else()</code> ist
nicht <code>ifelse()</code>. Da bei <code>if_else()</code> die
erstellten Variablen von verschiedenem Datentyp sind, müssen wir die
<code>NA</code> auch zum Datentyp <em>double</em> transformieren. Bei
<code>ifelse()</code> ist dies nicht nötig.</li>
</ol>
<pre class="r"><code>diamonds2 &lt;- diamonds |&gt; 
  mutate(y = if_else(y &lt; 3 | y &gt; 20, NA_real_, y))</code></pre>
<p><code>ifelse()</code> hat drei Argumente. Das erste <code>test</code>
sollte ein logischer Vektor sein. Alternativ benutze
<code>case_when()</code>.<br />
Erstellst du einen Plot mit <code>NA</code>’s, so warnt dich
<code>ggplot2</code>, dass sie entfernt wurden.</p>
<pre class="r"><code>ggplot(diamonds2, aes(x = x, y = y)) + 
  geom_point()</code></pre>
<pre><code>## Warning: Removed 9 rows containing missing values (`geom_point()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-162-1.png" width="672" /></p>
<pre class="r"><code>#&gt; Warning: Removed 9 rows containing missing values (`geom_point()`).</code></pre>
<p>Diese Warnung kann mit <code>na.rm = TRUE</code> unterdrückt
werden.</p>
<pre class="r"><code>ggplot(diamonds2, aes(x = x, y = y)) + 
  geom_point(na.rm = TRUE)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-163-1.png" width="672" /></p>
<p>In einem anderen Beispiel wollen wir herausfinden, inwiefern sich
Beobachtugen unterscheiden, bei denen Werte vorliegen im Gegensatz zu
Beobachtungen, bei denen <em>Missing Values</em> vorhanden sind.
<code>nycflights13::flights</code> hat in <code>dep_time</code>
fehlenden Werte, sodass der Flug wahrscheinlich gecancelt wurde.
Vergleichen wir also die planmäßigen Abflugzeiten der Flüge bzw.
abgesagten Flüge.</p>
<pre class="r"><code>nycflights13::flights |&gt;
  mutate(
    cancelled = is.na(dep_time),
    sched_hour = sched_dep_time %/% 100,
    sched_min = sched_dep_time %% 100,
    sched_dep_time = sched_hour + (sched_min / 60)    
  ) |&gt;
  ggplot(aes(x = sched_dep_time)) + 
  geom_freqpoly(aes(color = cancelled), binwidth = 1/4)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-164-1.png" width="672" /></p>
<p>Der Vergleich ist schwierig, da hier viel mehr Flüge als abgesagte
sind.</p>
</div>
<div id="kovariation" class="section level2" number="8.5">
<h2><span class="header-section-number">8.5</span> Kovariation</h2>
<p>Die Variation betrachtet eine Variable, die Kovariation beschreit das
Verhalten zwischen Variablen. Die Beziehung zwischen zwei oder mehr
Variablen zu visualisieren, hilft bei der Analyse natürlich enorm.</p>
<div id="kategoriale-und-numerische-variable" class="section level3"
number="8.5.1">
<h3><span class="header-section-number">8.5.1</span> Kategoriale und
numerische Variable</h3>
<p>Zum Beispiel der Preis eines Diamanten wird mit der Qualität
verglichen (<code>cut</code>).</p>
<pre class="r"><code>ggplot(diamonds, aes(x = price)) + 
  geom_freqpoly(aes(color = cut), binwidth = 500, size = 0.75)</code></pre>
<pre><code>## Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
## ℹ Please use `linewidth` instead.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-165-1.png" width="672" /></p>
<pre class="r"><code>#&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.
#&gt; ℹ Please use `linewidth` instead.</code></pre>
<p>Wieder nicht ideal, da es große Unterschiede in den Häufigkeiten
gibt.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut)) + 
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-166-1.png" width="672" /></p>
<p>Um den Vergleich einfacher zu machen, werden die Werte auf der
y-Achse ausgetauscht. Nehmen wir die Dichte, so ist die Fläche unter dem
Graphen für alle <code>cut</code> Werte immer gleich eins.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = price, y = after_stat(density))) + 
  geom_freqpoly(aes(color = cut), binwidth = 500, size = 0.75)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-167-1.png" width="672" /></p>
<p>Da <code>density</code> keine Variable des <code>diamonds</code>
Datensatzes ist, müssen wir es berechnen. Dafür benutzen wir die
<code>after_stat()</code> Funktion.<br />
Das Ergebnis jedoch überrascht. Es sieht so aus, als ob die niedrigste
(<em>fair</em>) Qualität, den höchsten Durchschnittspreis hat.</p>
<p>Ein visuell einfacher Plot, ist der Boxplot.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, y = price)) +
  geom_boxplot()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-168-1.png" width="672" /></p>
<p>Weniger Informationen sehen wir, aber dafür sind die Boxplots
kompakter. Aber auch hier kann an der These festgehalten werden, dass
qualitativ bessere Diamanten günstiger sind. Warum ist das wohl
so?<br />
<code>cut</code> ist hier ein geordneter Faktor. Viele Variablen haben
nicht eine Anordnung, so dass sie neu sortiert werden müssen. Eine
Möglichkeit ist hier die <code>fct_reorder()</code> Funktion.<br />
Im <code>mpg</code> Datensatz z.B. wollen wir die <em>highway
mileage</em> (Fahrleistung auf Autobahn) je nach <code>class</code>
(<em>type of car</em>) darstellen.</p>
<pre class="r"><code>ggplot(mpg, aes(x = class, y = hwy)) +
  geom_boxplot()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-169-1.png" width="672" /></p>
<p>Sortieren wir <code>class</code> neu, basierend aud dem Median von
<code>hwy</code>:</p>
<pre class="r"><code>ggplot(mpg,
       aes(x = fct_reorder(class, hwy, median), y = hwy)) +
  geom_boxplot()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-170-1.png" width="672" /></p>
<p>Oder:</p>
<pre class="r"><code>ggplot(mpg,
       aes(x = hwy, y = fct_reorder(class, hwy, median))) +
  geom_boxplot()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-171-1.png" width="672" /></p>
</div>
</div>
<div id="zwei-kateroriale-variablen" class="section level2"
number="8.6">
<h2><span class="header-section-number">8.6</span> Zwei kateroriale
Variablen</h2>
<p>Hier musst du für jede Kombination von <em>Levels</em> die
Häufigkeiten zählen.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, y = color)) +
  geom_count()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-172-1.png" width="672" /></p>
<p>Die Größe der Kreise zeigt wie viele Beobachtungen in jedes Paar
fallen.<br />
Mit <code>dplyr</code> lassen sich die <em>Counts</em> bestimmen und mit
<code>geom_tile()</code> visualisieren.</p>
<pre class="r"><code>diamonds |&gt; 
  count(color, cut) |&gt;  
  ggplot(aes(x = color, y = cut)) +
  geom_tile(aes(fill = n))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-173-1.png" width="672" /></p>
<p>Die Reihen und Spalten lassen sich wieder ordnen und eine
<strong>Heatmap</strong> wird visualisiert.</p>
<div id="zwei-numerische-variablen-1" class="section level3"
number="8.6.1">
<h3><span class="header-section-number">8.6.1</span> Zwei numerische
Variablen</h3>
<p>Kovariation kannst du als Muster in den Punkten sehen. Eine
exponentiale Beziehung zwischen Karatgröße und Preis von Diamanten
z.B.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = carat, y = price)) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-174-1.png" width="672" /></p>
<p>Bei großen Datensätzen werden <em>Scatterplots</em> jedoch
unhandlich, da sich Punkte überlappen: der <code>alpha</code>
<em>aesthetic</em> hilft.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = carat, y = price)) + 
  geom_point(alpha = 1 / 100)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-175-1.png" width="672" /></p>
<p>Für große Datensätze kann <em>transparency</em> aber herausfordernd
sein. Wir können aber die Daten gruppieren. Schon kennengelernt haben
wir dafür <code>geom_histogram()</code> und
<code>geom_freqpoly()</code>. Wir haben in eine Dimension gruppiert,
jetzt in zwei Dimensionen (<code>geom_bin2d()</code> und
<code>geom_hex()</code>).<br />
Farben zeigen an, wieviele Punkte in jedes Rechteck fallen. Es wird
zwischen Rechtecken und Sechsecken unterschieden.</p>
<pre class="r"><code>ggplot(smaller, aes(x = carat, y = price)) +
  geom_bin2d()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-176-1.png" width="672" /></p>
<pre class="r"><code># install.packages(&quot;hexbin&quot;)
ggplot(smaller, aes(x = carat, y = price)) +
  geom_hex()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-176-2.png" width="672" /></p>
<p>Eine weitere, gute Möglichkeit ist es stetige als kategoriale
Variablen zu gruppieren und dann entsprechende Grafiken zu wählen, wie
Boxplots.</p>
<pre class="r"><code>ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_width(carat, 0.1)))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-177-1.png" width="672" /></p>
<p><code>cut_width(x, width)</code> unterteilt <code>x</code> in Gruppen
der Breite <code>width</code>. Jedoch erkennen wir nicht wieviele
Beobachtungen in jeden Boxplot fallen, sondern nur die Verteilung. Wir
können jedoch die Breite proportional machen zu der Anzahl der
Beobachtungen, mit <code>varwidth = TRUE</code>.<br />
Ein anderer Ansatz ist es dieselbe Anzahl an Punkten in jeder Gruppe
anzeigen zu lassen. Das macht <code>cut_number()</code>:</p>
<pre class="r"><code>ggplot(smaller, aes(x = carat, y = price)) + 
  geom_boxplot(aes(group = cut_number(carat, 20)))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-178-1.png" width="672" /></p>
</div>
</div>
<div id="muster-und-modelle" class="section level2" number="8.7">
<h2><span class="header-section-number">8.7</span> Muster und
Modelle</h2>
<p>Muster in den Daten geben Hinweise über Zusammenhänge. Wenn ein
Zusammenhang zwischen zwei Variablen existiert, so erscheint dieser auch
als Muster in den Daten. Wenn du ein Muster in den Daten findest, frag
dich:</p>
<ul>
<li>Kann das Muster auf Zufall beruhen?</li>
<li>Wie kannst du den Zusammenhang über das Muster beschreiben?</li>
<li>Wie stark ist dieser?</li>
<li>Welche anderen Variablen beeinflussen den Zusammenhang?</li>
<li>Ändert sich der Zusammenhang, wenn du dir Untergruppen deiner Daten
anschaust?</li>
</ul>
<p>Das Streudiagramm der Eruptionslänge und Eruptionszeit von einem
Geysir zeigt ein Muster auf: längere Wartezeit = längere Eruption. Zwei
Cluster sind klar zu erkennen.</p>
<pre class="r"><code>ggplot(faithful, aes(x = eruptions, y = waiting)) + 
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-179-1.png" width="672" /></p>
<p>Modelle sind Werkzeuge, um Muster aus den Daten zu ziehen. Gucken wir
uns den Diamantendatensatz an. Der Zusammenhang zwischen
<code>cut</code> und <code>price</code> ist schwer zu verstehen, da
<code>cut</code> und <code>carat</code> und <code>carat</code> und
<code>price</code> miteinander korrelieren. Wir können aber über ein
Model die starke Beziehung zwischen Preis und Karat entfernen.</p>
<pre class="r"><code>library(tidymodels)</code></pre>
<pre><code>## Warning: Paket &#39;tidymodels&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## ── Attaching packages ────────────────────────────────────── tidymodels 1.0.0 ──</code></pre>
<pre><code>## ✔ broom        1.0.4     ✔ rsample      1.1.1
## ✔ dials        1.1.0     ✔ tune         1.0.1
## ✔ infer        1.0.4     ✔ workflows    1.1.3
## ✔ modeldata    1.1.0     ✔ workflowsets 1.0.0
## ✔ parsnip      1.0.4     ✔ yardstick    1.1.0
## ✔ recipes      1.0.5</code></pre>
<pre><code>## Warning: Paket &#39;broom&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;parsnip&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;recipes&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;rsample&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: Paket &#39;workflows&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## ── Conflicts ───────────────────────────────────────── tidymodels_conflicts() ──
## ✖ scales::discard() masks purrr::discard()
## ✖ dplyr::filter()   masks stats::filter()
## ✖ recipes::fixed()  masks stringr::fixed()
## ✖ dplyr::lag()      masks stats::lag()
## ✖ yardstick::spec() masks readr::spec()
## ✖ recipes::step()   masks stats::step()
## • Use tidymodels_prefer() to resolve common conflicts.</code></pre>
<pre class="r"><code>diamonds &lt;- diamonds |&gt;
  mutate(
    log_price = log(price),
    log_carat = log(carat)
  )

diamonds_fit &lt;- linear_reg() |&gt;
  fit(log_price ~ log_carat, data = diamonds)

diamonds_aug &lt;- augment(diamonds_fit, new_data = diamonds) |&gt;
  mutate(.resid = exp(.resid))

ggplot(diamonds_aug, aes(x = carat, y = .resid)) + 
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-180-1.png" width="672" /></p>
<p>Jetzt können wir die Beziehng zwischen cut und price herstellen.</p>
<pre class="r"><code>ggplot(diamonds_aug, aes(x = cut, y = .resid)) + 
  geom_boxplot()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-181-1.png" width="672" /></p>
<p>Ein weiteres Beispiel:</p>
<pre class="r"><code>x &lt;- 1:100 
x</code></pre>
<pre><code>##   [1]   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18
##  [19]  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36
##  [37]  37  38  39  40  41  42  43  44  45  46  47  48  49  50  51  52  53  54
##  [55]  55  56  57  58  59  60  61  62  63  64  65  66  67  68  69  70  71  72
##  [73]  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
##  [91]  91  92  93  94  95  96  97  98  99 100</code></pre>
<pre class="r"><code>z &lt;- c(rep(5, 20), rep(10, 20), rep(-1, 20), rep(-5, 20), rep(-2,20))
y &lt;- rnorm(100) + 1:100 + z
y</code></pre>
<pre><code>##   [1]  6.188072  6.651261  9.348569  9.516619  8.508856 12.232239 11.400343
##   [8] 12.277694 13.553421 15.804916 15.927179 16.966653 17.351420 16.929592
##  [15] 20.129306 20.926472 19.300489 23.453125 24.263545 26.478465 31.669872
##  [22] 31.594850 31.951781 33.463937 33.627335 35.387549 38.087060 38.429082
##  [29] 38.572690 38.683814 40.747653 41.537535 44.423693 44.259470 44.639784
##  [36] 45.890418 46.713389 46.945936 49.523042 48.657386 40.655885 40.861718
##  [43] 40.483772 43.962566 43.165010 45.876482 45.601457 46.149808 46.008763
##  [50] 48.890403 50.627348 52.382759 49.872892 53.290696 53.689705 53.195550
##  [57] 56.650358 56.333019 58.808796 59.589704 54.695036 56.955843 56.722155
##  [64] 58.731338 59.360216 60.116872 62.094368 63.152340 63.804054 65.995891
##  [71] 64.292418 66.463159 66.730395 68.184599 70.085693 71.683699 72.840387
##  [78] 72.760886 74.535693 74.499123 79.762804 81.473467 79.995375 82.137284
##  [85] 82.850147 83.163905 84.663713 88.953678 87.798765 87.049370 87.907589
##  [92] 89.368597 92.858413 90.700551 92.119106 93.322457 94.946344 95.256708
##  [99] 96.629049 99.271622</code></pre>
<pre class="r"><code>kat &lt;- c(rep(&quot;blau&quot;, 20), rep(&quot;grün&quot;, 20), rep(&quot;orange&quot;, 20), rep(&quot;rot&quot;, 20), rep(&quot;schwarz&quot;, 20))
df &lt;- tibble(x, y, kat)
df</code></pre>
<pre><code>## # A tibble: 100 × 3
##        x     y kat  
##    &lt;int&gt; &lt;dbl&gt; &lt;chr&gt;
##  1     1  6.19 blau 
##  2     2  6.65 blau 
##  3     3  9.35 blau 
##  4     4  9.52 blau 
##  5     5  8.51 blau 
##  6     6 12.2  blau 
##  7     7 11.4  blau 
##  8     8 12.3  blau 
##  9     9 13.6  blau 
## 10    10 15.8  blau 
## # ℹ 90 more rows</code></pre>
<pre class="r"><code>df |&gt;
  ggplot(aes(x=x,y=y)) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-182-1.png" width="672" /></p>
<pre class="r"><code>d_fit &lt;- linear_reg() |&gt;
  fit(y ~ x, data = df)
  
d_a &lt;- augment(d_fit, new_data = df) |&gt;
mutate(.resid = 1 * .resid)
d_a</code></pre>
<pre><code>## # A tibble: 100 × 5
##        x     y kat   .pred .resid
##    &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1     1  6.19 blau   9.05  -2.86
##  2     2  6.65 blau   9.91  -3.26
##  3     3  9.35 blau  10.8   -1.43
##  4     4  9.52 blau  11.6   -2.12
##  5     5  8.51 blau  12.5   -3.99
##  6     6 12.2  blau  13.4   -1.13
##  7     7 11.4  blau  14.2   -2.82
##  8     8 12.3  blau  15.1   -2.81
##  9     9 13.6  blau  15.9   -2.39
## 10    10 15.8  blau  16.8   -1.01
## # ℹ 90 more rows</code></pre>
<pre class="r"><code>ggplot(d_a, aes(x = x, y = .resid)) + 
  geom_point() +
geom_vline(xintercept = c(20,40,60,80), lty = 4) </code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-182-2.png" width="672" /></p>
<pre class="r"><code>ggplot(d_a, aes(x = kat, y = .resid)) +
geom_boxplot()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-182-3.png" width="672" /></p>
</div>
</div>
<div id="visualisieren-kommunikation" class="section level1" number="9">
<h1><span class="header-section-number">9</span> Visualisieren:
Kommunikation</h1>
<div id="einleitung-5" class="section level2" number="9.1">
<h2><span class="header-section-number">9.1</span> Einleitung</h2>
<p>In jeder tieferen Analyse werden Massen an Plots erstellt, von denen
die meisten schnell wieder verworfen werden. Hast du deine Schlüsse aus
den Daten gezogen, gilt es fast immer sie zu kommunizieren. Das Problem
ist oft, dass dein Publikum nicht so tief in der Analyse, in den Daten,
in der Fachrichtung, drin steckt wie du. So muss es dein Ziel sein,
deine Plots so selbsterklärend wie möglich zu gestalten. In diesem
Abschitt lernst du ein paar Werkzeuge von <code>ggplot2</code> kennen,
die dir dabei helfen.</p>
<div id="voraussetzungen-4" class="section level3" number="9.1.1">
<h3><span class="header-section-number">9.1.1</span>
Voraussetzungen</h3>
<p>Wieder konzentrieren wir uns hier auf <code>ggplot2</code> und die
Pakete <strong>ggrepel</strong>, <strong>patchwork</strong> und
<strong>dplyr</strong>.</p>
<pre class="r"><code>library(ggrepel)</code></pre>
<pre><code>## Warning: Paket &#39;ggrepel&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre class="r"><code>library(patchwork)</code></pre>
<pre><code>## Warning: Paket &#39;patchwork&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
</div>
</div>
<div id="labels" class="section level2" number="9.2">
<h2><span class="header-section-number">9.2</span> Labels</h2>
<p>Etiketten bzw. Labels helfen natürlich immer eine Grafik anschaulich
zu machen. Sie können mithilfe der <code>labs()</code> Funktion
hinzugefügt werden.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(title = &quot;Fuel efficiency generally decreases with engine size&quot;)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-184-1.png" width="672" /></p>
<p>Die Absicht ist es, die Haupterkenntnis zusammenzufassen. Nur den
Plot zu beschreiben sollte man vermeiden. Zwei Möglichkeiten gibt es
etwas hinzuzufügen:</p>
<ul>
<li><p><code>subtitle</code> fügt ein weiteres Detail in kleinerer
Schrift darunter hinzu.</p></li>
<li><p><code>caption</code> fügt Text unterhalb der Grafik rechts vom
Plot hinzu, meist die Quelle der Daten.</p></li>
</ul>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    title = &quot;Fuel efficiency generally decreases with engine size&quot;,
    subtitle = &quot;Two seaters (sports cars) are an exception because of their light weight&quot;,
    caption = &quot;Data from fueleconomy.gov&quot;
  )</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-185-1.png" width="672" /></p>
<p><code>labs()</code> kannst du auch benutzen, um Achsen- und
Legenden-Titel zu ersetzen.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  labs(
    x = &quot;Engine displacement (L)&quot;,
    y = &quot;Highway fuel economy (mpg)&quot;,
    color = &quot;Car type&quot;
  )</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-186-1.png" width="672" /></p>
<p>Mathematische Gleichungen statt <em>Strings</em> können genutzt
werden. Tausche hierfür <code>""</code> aus durch <code>quote()</code>
und schau dir die Optionen in der Hilfe <code>?plotmath</code> an:</p>
<pre class="r"><code>df &lt;- tibble(
  x = 1:10,
  y = x ^ 2
)

ggplot(df, aes(x, y)) +
  geom_point() +
  labs(
    x = quote(sum(x[i] ^ 2, i == 1, n)),
    y = quote(alpha + beta + frac(delta, theta))
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-187-1.png" width="672" /></p>
</div>
<div id="annotationen" class="section level2" number="9.3">
<h2><span class="header-section-number">9.3</span> Annotationen</h2>
<p>Manchmal ist es sinnvoll auch individuelle Beobachtungen oder Gruppen
von Beobachtungen zu labeln. <code>geom_text()</code> ist dabei ähnlich
wie <code>geom_point()</code>, aber es hat einen zusätzlichen
<em>aes</em>: <code>label</code>. Der macht es möglich Text (Labels) zu
deinen Plots hinzuzufügen.<br />
Es gibt zwei mögliche Quellen von Labels. Als erstes könntest du ein
<code>tibble</code> haben, dass Labels anbietet. Im Folgenden schauen
wir uns die Autos mit den größten Hubraum pro Antriebsart an und
speichern die Informationen als neuen <em>Data Frame</em>
<code>label_info</code>. Neue <code>dplyr</code> Funktionen helfen
dabei.</p>
<pre class="r"><code>label_info &lt;- mpg |&gt;
  group_by(drv) |&gt;
  arrange(desc(displ)) |&gt;
  slice_head(n = 1) |&gt;
  mutate(
    drive_type = case_when(
      drv == &quot;f&quot; ~ &quot;front-wheel drive&quot;,
      drv == &quot;r&quot; ~ &quot;rear-wheel drive&quot;,
      drv == &quot;4&quot; ~ &quot;4-wheel drive&quot;
    )
  ) |&gt;
  select(displ, hwy, drv, drive_type)

label_info</code></pre>
<pre><code>## # A tibble: 3 × 4
## # Groups:   drv [3]
##   displ   hwy drv   drive_type       
##   &lt;dbl&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt;            
## 1   6.5    17 4     4-wheel drive    
## 2   5.3    25 f     front-wheel drive
## 3   7      24 r     rear-wheel drive</code></pre>
<p>Diesen neuen Datensatz benutzen wir um die Labels direkt über den
Plots anzuzeigen. Mit <code>fontface</code> und <code>size</code> können
wir den Look der Labels direkt anpassen. Die Ausrichtung der Labels
erfolgt mit <code>hjust</code> (“left”, “center”, “right”) und
<code>vjust</code> (“top”, “center”, “botom”).
<code>theme(legend.position = "none")</code> unterdrückt die Legende.
Sie brauchen wir auf der rechten Seite jetzt natürlich nicht mehr.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_text(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = &quot;bold&quot;, size = 5, hjust = &quot;right&quot;, vjust = &quot;bottom&quot;
  ) +
  theme(legend.position = &quot;none&quot;)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-189-1.png" width="672" /></p>
<pre class="r"><code>#&gt; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p>Durch die Überlappungen ist der beschriftete Plot nicht mehr ganz so
gut zu lesen. Ein Rechteck wird hinter den Text geworfen.
<code>geom_label()</code> hilft. <code>nudge_y</code> hebt die Labels
leicht vor die Punkte des Plots:</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_label(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = &quot;bold&quot;, size = 5, hjust = &quot;right&quot;, alpha = 0.5, nudge_y = 2,
  ) +
  theme(legend.position = &quot;none&quot;)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-190-1.png" width="672" /></p>
<pre class="r"><code>#&gt; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p>Optimal ist es nicht. <code>geom_label_repel()</code> vom
<code>ggrepel</code> Paket sorgt automatisch für eine Platzierung der
Labels, sodass sie nicht überlappen.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy, color = drv)) +
  geom_point(alpha = 0.3) +
  geom_smooth(se = FALSE) +
  geom_label_repel(
    data = label_info, 
    aes(x = displ, y = hwy, label = drive_type),
    fontface = &quot;bold&quot;, size = 5, nudge_y = 2,
  ) +
  theme(legend.position = &quot;none&quot;)</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-191-1.png" width="672" /></p>
<pre class="r"><code>#&gt; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p>Auch können wir gewisse Punkte optisch hervorheben mit
<code>geom_text_repel()</code>. Hier fügen wir sogar zwei Schichten von
Punkten übereinander, um die Punkte hervorzuheben.</p>
<pre class="r"><code>potential_outliers &lt;- mpg |&gt;
  filter(hwy &gt; 40 | (hwy &gt; 20 &amp; displ &gt; 5))
  
ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_text_repel(data = potential_outliers, aes(label = model)) +
  geom_point(data = potential_outliers, color = &quot;red&quot;) +
  geom_point(data = potential_outliers, color = &quot;red&quot;, size = 3, shape = &quot;circle open&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-192-1.png" width="672" /></p>
<p>Ein Label zum Plot kannst du über einen neuen <em>Data Frame</em>
hinzufügen. Bestimme dazu die maximalen Werte von x und y und speichere
diese Koordinaten. Dann setze die Beschriftung dort ein.</p>
<pre class="r"><code>label_info &lt;- mpg |&gt;
  summarize(
    displ = max(displ),
    hwy = max(hwy),
    label = &quot;Increasing engine size is \nrelated to decreasing fuel economy.&quot;
  )

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_text(
    data = label_info, aes(label = label), 
    vjust = &quot;top&quot;, hjust = &quot;right&quot;
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-193-1.png" width="672" /></p>
<p>Direkt in die Ecken können wir den Text setzen über <code>+Inf</code>
und <code>-Inf</code>. Da wir die exakten Positionen nicht brauchen,
ertellen wir den <em>Data Frame</em> mithilfe von
<code>tibble()</code>.</p>
<pre class="r"><code>label_info &lt;- tibble(
  displ = Inf,
  hwy = Inf,
  label = &quot;Increasing engine size is \nrelated to decreasing fuel economy.&quot;
)

ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  geom_text(data = label_info, aes(label = label), vjust = &quot;top&quot;, hjust = &quot;right&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-194-1.png" width="672" /></p>
<p>Ohne einen <em>Data Frame</em> funktioniert das Ganze natürlich auch.
<code>annotate()</code> fügt ein geom zu einem Plot hinzu.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  annotate(
    geom = &quot;text&quot;, x = Inf, y = Inf,
    label = &quot;Increasing engine size is \nrelated to decreasing fuel economy.&quot;,
    vjust = &quot;top&quot;, hjust = &quot;right&quot;
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-195-1.png" width="672" /></p>
<p>Wir können ein <em>Label-geom</em> statt eines <em>Text-geoms</em>
benutzen. Ein <em>Segment-geom</em> mit dem <code>arrow</code> Argument
zieht die Aufmerksamkeit auf sich. <code>x</code> und <code>y</code>
<em>aes</em> definieren den Startpunkt, <code>xend</code> und
<code>yend</code> den Endpunkt.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  annotate(
    geom = &quot;label&quot;, x = 3.5, y = 38,
    label = &quot;Increasing engine size is \nrelated to decreasing fuel economy.&quot;,
    hjust = &quot;left&quot;, color = &quot;red&quot;
  ) +
  annotate(
    geom = &quot;segment&quot;,
    x = 3, y = 35, xend = 5, yend = 25, color = &quot;red&quot;,
    arrow = arrow(type = &quot;closed&quot;)
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-196-1.png" width="672" /></p>
<p><code>"\n"</code> überführt das Label in eine weitere Zeile.
<code>stringr::str_wrap()</code> tut dies automatisch, indem man ihm die
Anzahl der Zeichen vorgibt, pro Zeile.</p>
<pre class="r"><code>&quot;Increasing engine size is related to decreasing fuel economy.&quot; |&gt;
  str_wrap(width = 40) |&gt;
  writeLines()</code></pre>
<pre><code>## Increasing engine size is related to
## decreasing fuel economy.</code></pre>
</div>
<div id="skalen" class="section level2" number="9.4">
<h2><span class="header-section-number">9.4</span> Skalen</h2>
<p>Eine weitere Möglichkeit deinen Plot besser für die Kommunikation zu
machen ist die Anpassung der Skalen.</p>
<div id="default-skalen" class="section level3" number="9.4.1">
<h3><span class="header-section-number">9.4.1</span> <em>Default</em>
Skalen</h3>
<p><code>ggplot2</code> setzt normalerweise die Skalen automatisch für
dich. Wenn du tippst:</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-198-1.png" width="672" /></p>
<p>Dann fügt <code>ggplot2</code> automatisch (hinter dem Vorhang)
<em>default</em> Skalen hinzu.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  scale_x_continuous() +
  scale_y_continuous() +
  scale_color_discrete()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-199-1.png" width="672" /></p>
<p>Die Namensgebung läuft wie folgt ab: <code>scale_</code> folgt der
Names des <code>aes</code>, dann folgt <code>_</code>, dann der Name der
Skala. Die <em>default</em> Skalen sind nach dem Typ der Variablen
benannt: <em>continuous, discrete, datetime, date</em>. Es gibt jedoch
Gründe die <em>defaults</em> zu überschreiben:</p>
<ul>
<li><p>du willst die Parameter der <em>default</em> Skala optimieren. Du
kannst die <em>breaks</em> der Achsen wechseln, oder die Labels der
Legende.</p></li>
<li><p>du willst die Skala komplett ersetzen, und einen anderen
Algorithmus verwenden.</p></li>
</ul>
</div>
<div id="axis-ticks-und-legend-keys" class="section level3"
number="9.4.2">
<h3><span class="header-section-number">9.4.2</span> Axis ticks und
legend keys</h3>
<p>Es gibt zwei Argumente, die das Erscheinen der <em>Ticks</em> auf der
Achse und der <em>keys</em> auf der Legende beeinflussen:
<code>breaks</code> und <code>labels</code>. Breaks kontrollieren die
Position der <em>Ticks</em>. Labels kontrollieren die <em>text
labels</em>. Die gewöhnlichste Anwendung von <code>breaks</code> ist das
Überschreiben des <em>default</em>:</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  scale_y_continuous(breaks = seq(15, 40, by = 5))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-200-1.png" width="672" /></p>
<p><code>labels</code> kannst du genauso benutzen (<em>Character</em>
Vektor derselben Länge wie <code>breaks</code>), du kannst aber auch ihn
auf <code>NULL</code> setzen, um die Labels zu unterdrücken.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point() +
  scale_x_continuous(labels = NULL) +
  scale_y_continuous(labels = NULL)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-201-1.png" width="672" /></p>
<p>Das <code>label</code> Argument kannst du mit der <em>labelling</em>
Funktion vom <em>scales</em> Paket paaren, sodass die Formatierung von
Zahlen wie Währungen und Prozenten leichter fällt. Links wird ein
Dollarzeichen gesetzt, rechts durch 1000 geteilt und ein “K” für 1000
angefügt. Die <em>Breaks</em> werden auch individuell gesetzt.</p>
<pre class="r"><code># Left
ggplot(diamonds, aes(x = cut, y = price)) +
  geom_boxplot(alpha = 0.05) +
  scale_y_continuous(labels = scales::label_dollar())</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-202-1.png" width="672" /></p>
<pre class="r"><code># Right
ggplot(diamonds, aes(x = cut, y = price)) +
  geom_boxplot(alpha = 0.05) +
  scale_y_continuous(
    labels = scales::label_dollar(scale = 1/1000, suffix = &quot;K&quot;), 
    breaks = seq(1000, 19000, by = 6000)
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-202-2.png" width="672" /></p>
<p>Eine weitere nützliche <em>label</em> Funktion ist
<code>label_percent()</code>:</p>
<pre class="r"><code>ggplot(diamonds, aes(x = cut, fill = clarity)) +
  geom_bar(position = &quot;fill&quot;) +
  scale_y_continuous(
    name = &quot;Percentage&quot;, 
    labels = scales::label_percent()
  )</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-203-1.png" width="672" /></p>
<p>Hast du wenig Datenpunkte und willst hervorheben, wo die Beobachtung
exakt angefallen ist, benutze <code>breaks</code>.</p>
<pre class="r"><code>presidential |&gt;
  mutate(id = 33 + row_number()) |&gt;
  ggplot(aes(x = start, y = id)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_x_date(name = NULL, breaks = presidential$start, date_labels = &quot;&#39;%y&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-204-1.png" width="672" /></p>
</div>
<div id="layout-der-legende" class="section level3" number="9.4.3">
<h3><span class="header-section-number">9.4.3</span> Layout der
Legende</h3>
<p>Um die Achsen zu optimieren, nutze meist <code>breaks</code> und
<code>labels</code>. Um die Legenden zu kontrollieren, benutze
<code>theme()</code>. Sie kontrollieren den Nicht-Daten-Bereich.
<code>legend.position</code> kontrolliert wo genau die Legende
gezeichnet wird.</p>
<pre class="r"><code>base &lt;- ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class))

base + theme(legend.position = &quot;left&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-205-1.png" width="672" /></p>
<pre class="r"><code>base + theme(legend.position = &quot;top&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-205-2.png" width="672" /></p>
<pre class="r"><code>base + theme(legend.position = &quot;bottom&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-205-3.png" width="672" /></p>
<pre class="r"><code>base + theme(legend.position = &quot;right&quot;) # the default</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-205-4.png" width="672" /></p>
<p>Mit <code>legend.position = "none"</code> kannst du die Legende
unterdrücken.<br />
Kontrolliere die Anzahl an Zeilen und die Größe der angezeigten Punkte
in der Legende mithilfe von <code>guides()</code>.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme(legend.position = &quot;bottom&quot;) +
  guides(color = guide_legend(nrow = 1, override.aes = list(size = 4)))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-206-1.png" width="672" /></p>
<pre class="r"><code>#&gt; `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
</div>
<div id="ersetzen-einer-skala" class="section level3" number="9.4.4">
<h3><span class="header-section-number">9.4.4</span> Ersetzen einer
Skala</h3>
<p>Oft ist es sinnvoll Transformationen deiner Variable zu plotten. Z.B.
lässt sich so der Zusammenhang zwischen <code>carat</code> und
<code>price</code> besser sehen.</p>
<pre class="r"><code># Left
ggplot(diamonds, aes(x = carat, y = price)) +
  geom_bin2d()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-207-1.png" width="672" /></p>
<pre class="r"><code># Right
ggplot(diamonds, aes(x = log10(carat), y = log10(price))) +
  geom_bin2d()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-207-2.png" width="672" /></p>
<p>Der Nachteil ist natürlich, dass die Achsen mit den transformierten
Werten gelabelt sind. Das macht die Interpretation des Plots schwierig.
Man muss jetzt aber schon genau auf die Achsen schauen.</p>
<pre class="r"><code>ggplot(diamonds, aes(x = carat, y = price)) +
  geom_bin2d() + 
  scale_x_log10() + 
  scale_y_log10()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-208-1.png" width="672" /></p>
<p>Die Farbpalette kann für Menschen mit Farbenblindheit angepasst
werden.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-209-1.png" width="672" /></p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv)) +
  scale_color_brewer(palette = &quot;Set1&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-209-2.png" width="672" /></p>
<p>Ein <em>shape mapping</em> hilft hier natürlich deutlich mehr.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = drv, shape = drv)) +
  scale_color_brewer(palette = &quot;Set1&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-210-1.png" width="672" /></p>
<p>Wenn eine vordefinierte Zuordnung zwischen Werten und Farben
existiert, benutze <code>scale_color_manual()</code>. Die US Präsidenten
können wir so optisch nach Parteizugehörigkeit hervorheben.</p>
<pre class="r"><code>presidential |&gt;
  mutate(id = 33 + row_number()) |&gt;
  ggplot(aes(x = start, y = id, color = party)) +
  geom_point() +
  geom_segment(aes(xend = end, yend = id)) +
  scale_color_manual(values = c(Republican = &quot;red&quot;, Democratic = &quot;blue&quot;))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-211-1.png" width="672" /></p>
<p>Für stetige Farbeverläufe benutze <code>scale_color_gradient()</code>
oder <code>scale_fill_gradient()</code>. Für divergierende Skalen
benutze <code>scale_color_gradient2()</code>. So können die negativen
und positiven Werte verschiedenen Farben übergeben werden.</p>
</div>
<div id="zooming" class="section level3" number="9.4.5">
<h3><span class="header-section-number">9.4.5</span> Zooming</h3>
<p>Es gibt drei Möglichkeiten die Plot Limits zu kontrollieren:</p>
<ol style="list-style-type: decimal">
<li>Anpassen, welche Daten geplottet werden.</li>
<li>Limits in jeder Skala setzen.</li>
<li><code>xlim</code> und <code>ylim</code> im
<code>coord_cartesian()</code> setzen.</li>
</ol>
<p>In eine Region zoomt man am besten über
<code>coord_cartesian()</code>:</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth() +
  coord_cartesian(xlim = c(5, 7), ylim = c(10, 30))</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-212-1.png" width="672" /></p>
<pre class="r"><code>mpg |&gt;
  filter(displ &gt;= 5, displ &lt;= 7, hwy &gt;= 10, hwy &lt;= 30) |&gt;
  ggplot(aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-212-2.png" width="672" /></p>
<p>Die Limits von Plots zu reduzieren ist meist äquivalent zu
<em>Subsetting</em>. Es ist aber nicht selten sinnvoll die Limits zu
erweitern, sodass zwei oder mehrere Plots besser miteinander verglichen
werden können.</p>
<pre class="r"><code>suv &lt;- mpg |&gt; filter(class == &quot;suv&quot;)
compact &lt;- mpg |&gt; filter(class == &quot;compact&quot;)

ggplot(suv, aes(x = displ, y = hwy, color = drv)) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-213-1.png" width="672" /></p>
<pre class="r"><code>ggplot(compact, aes(x = displ, y = hwy, color = drv)) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-213-2.png" width="672" /></p>
<p>Um das Problem zu beheben, können wir den ganzen Datensatz auf die
<code>limits</code> trainieren.</p>
<pre class="r"><code>x_scale &lt;- scale_x_continuous(limits = range(mpg$displ))
y_scale &lt;- scale_y_continuous(limits = range(mpg$hwy))
col_scale &lt;- scale_color_discrete(limits = unique(mpg$drv))

ggplot(suv, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-214-1.png" width="672" /></p>
<pre class="r"><code>ggplot(compact, aes(x = displ, y = hwy, color = drv)) +
  geom_point() +
  x_scale +
  y_scale +
  col_scale</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-214-2.png" width="672" /></p>
</div>
</div>
<div id="themes" class="section level2" number="9.5">
<h2><span class="header-section-number">9.5</span> Themes</h2>
<p>Du kannst die Nicht-Datenelemente deines Plots mit einem
Thema/<em>Theme</em> individuell gestalten.</p>
<pre class="r"><code>ggplot(mpg, aes(x = displ, y = hwy)) +
  geom_point(aes(color = class)) +
  geom_smooth(se = FALSE) +
  theme_bw()</code></pre>
<pre><code>## `geom_smooth()` using method = &#39;loess&#39; and formula = &#39;y ~ x&#39;</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-215-1.png" width="672" /></p>
<p>Acht <em>Themes</em> werden von <code>ggplot2</code> per Default
mitgeliefert. Auch das Paket <strong>ggthemes</strong> und ähnliche
helfen weiter. Mehr dazu über die Hilfeseiten.</p>
</div>
<div id="layout" class="section level2" number="9.6">
<h2><span class="header-section-number">9.6</span> Layout</h2>
<p>Das <em>Patchwork</em> Paket erlaubt es uns mehrere separate Plots in
derselben Graphik zu vereinen. Die erstellten Plots musst du erst als
Objekt speichern und kannst sie dann über <code>+</code>
zusammenfügen.</p>
<pre class="r"><code>p1 &lt;- ggplot(mpg, aes(x = displ, y = hwy)) + 
  geom_point() + 
  labs(title = &quot;Plot 1&quot;)
p2 &lt;- ggplot(mpg, aes(x = drv, y = hwy)) + 
  geom_boxplot() + 
  labs(title = &quot;Plot 2&quot;)
p1 + p2</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-216-1.png" width="672" /></p>
<p>Das Paket hat eine neue Funktionalität dem <code>+</code> Operator
zugefügt. <code>|</code> platziert <code>p1</code> und <code>p3</code>
nebeneinander und <code>/</code> schiebt <code>p2</code> in die nächste
Zeile.</p>
<pre class="r"><code>p3 &lt;- ggplot(mpg, aes(x = cty, y = hwy)) + 
  geom_point() + 
  labs(title = &quot;Plot 3&quot;)
(p1 | p3) / p2</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-217-1.png" width="672" /></p>
<p><em>Patchwork</em> erlaubt es uns die Legenden von mehreren Plots zu
bündeln. Die Platzierung der Legende kann angepasst werden, die
Dimensionen der Plots, ein gemeinsamer Titel, Untertitel, Überschrift,
etc.<br />
Wir haben 5 Plots jetzt, die Legenden wurden unterdrückt und die Legende
oben erstellt mit <code>&amp; theme(legend.position = "top")</code>. Die
Höhe der Plots wurde angepasst.</p>
<pre class="r"><code>p1 &lt;- ggplot(mpg, aes(x = drv, y = cty, color = drv)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = &quot;Plot 1&quot;)

p2 &lt;- ggplot(mpg, aes(x = drv, y = hwy, color = drv)) + 
  geom_boxplot(show.legend = FALSE) + 
  labs(title = &quot;Plot 2&quot;)

p3 &lt;- ggplot(mpg, aes(x = cty, color = drv, fill = drv)) + 
  geom_density(alpha = 0.5) + 
  labs(title = &quot;Plot 3&quot;)

p4 &lt;- ggplot(mpg, aes(x = hwy, color = drv, fill = drv)) + 
  geom_density(alpha = 0.5) + 
  labs(title = &quot;Plot 4&quot;)

p5 &lt;- ggplot(mpg, aes(x = cty, y = hwy, color = drv)) + 
  geom_point(show.legend = FALSE) + 
  facet_wrap(~drv) +
  labs(title = &quot;Plot 5&quot;)

(guide_area() / (p1 + p2) / (p3 + p4) / p5) +
  plot_annotation(
    title = &quot;City and highway mileage for cars with different drive trains&quot;,
    caption = &quot;Source: Source: https://fueleconomy.gov.&quot;
  ) +
  plot_layout(
    guides = &quot;collect&quot;,
    heights = c(1, 3, 2, 4)
    ) &amp;
  theme(legend.position = &quot;bottom&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-218-1.png" width="672" /></p>
<p>Mehr dazu über die Hilfe oder <a
href="https://patchwork.data-imaginist.com">link</a>.</p>
</div>
</div>
<div id="transformieren-logical-vectors" class="section level1"
number="10">
<h1><span class="header-section-number">10</span> Transformieren:
Logical Vectors</h1>
<div id="einleitung-6" class="section level2" number="10.1">
<h2><span class="header-section-number">10.1</span> Einleitung</h2>
<p>In diesem Abschnitt lernen wir Werkzeuge für logische Vektoren
kennen. Sie können nur <code>TRUE</code>, <code>FALSE</code>, oder
<code>NA</code> annehmen. In deiner Analyse findest du sie recht selten,
doch trotzdem werden sie fast immer kreiert und manipuliert.</p>
<div id="voraussetzungen-5" class="section level3" number="10.1.1">
<h3><span class="header-section-number">10.1.1</span>
Voraussetzungen</h3>
<p>Die meisten Funktionen, die wir brauchen, werden natürlich schon von
<strong>Base R</strong> bereitgestellt. Um <em>Data Frames</em> zu
bearbeiten und für Datenbeispiele, laden wir aber dennoch:</p>
<pre class="r"><code>library(tidyverse)
library(nycflights13)</code></pre>
</div>
</div>
<div id="vergleiche" class="section level2" number="10.2">
<h2><span class="header-section-number">10.2</span> Vergleiche</h2>
<p>Ein gewöhnlicher Weg einen logischen Vektor zu erzeugen, ist es
numerische Vergleiche mithilfe von <code>&lt;</code>,
<code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>,
<code>!=</code> und <code>==</code> durchzuführen.<br />
Bisher haben wir logische Variablen erzeugt mithilfe von
<code>filter()</code>. Sie wurden berechnet, benutzt und dann wieder
entsorgt. Im folgenden Beispiel finden sich über den Filter alle Abflüge
am Tag, die ungefähr pünktlich waren.</p>
<pre class="r"><code>flights |&gt; 
  filter(dep_time &gt; 600 &amp; dep_time &lt; 2000 &amp; abs(arr_delay) &lt; 20)</code></pre>
<pre><code>## # A tibble: 172,286 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      601            600         1      844            850
##  2  2013     1     1      602            610        -8      812            820
##  3  2013     1     1      602            605        -3      821            805
##  4  2013     1     1      606            610        -4      858            910
##  5  2013     1     1      606            610        -4      837            845
##  6  2013     1     1      607            607         0      858            915
##  7  2013     1     1      611            600        11      945            931
##  8  2013     1     1      613            610         3      925            921
##  9  2013     1     1      615            615         0      833            842
## 10  2013     1     1      622            630        -8     1017           1014
## # ℹ 172,276 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Die logischen Variablen sind hier nicht sichtbar, wir können sie aber
sichtbar machen mit <code>mutate()</code>:</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    daytime = dep_time &gt; 600 &amp; dep_time &lt; 2000,
    approx_ontime = abs(arr_delay) &lt; 20,
    .keep = &quot;used&quot;
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 4
##    dep_time arr_delay daytime approx_ontime
##       &lt;int&gt;     &lt;dbl&gt; &lt;lgl&gt;   &lt;lgl&gt;        
##  1      517        11 FALSE   TRUE         
##  2      533        20 FALSE   FALSE        
##  3      542        33 FALSE   FALSE        
##  4      544       -18 FALSE   TRUE         
##  5      554       -25 FALSE   FALSE        
##  6      554        12 FALSE   TRUE         
##  7      555        19 FALSE   TRUE         
##  8      557       -14 FALSE   TRUE         
##  9      557        -8 FALSE   TRUE         
## 10      558         8 FALSE   TRUE         
## # ℹ 336,766 more rows</code></pre>
<p>So können wir den Code besser verstehen und überprüfen, ob jeder
Schritt korrekt ausgeführt wurde. Der Filter sieht dann so aus:</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    daytime = dep_time &gt; 600 &amp; dep_time &lt; 2000,
    approx_ontime = abs(arr_delay) &lt; 20,
  ) |&gt; 
  filter(daytime &amp; approx_ontime)</code></pre>
<pre><code>## # A tibble: 172,286 × 21
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      601            600         1      844            850
##  2  2013     1     1      602            610        -8      812            820
##  3  2013     1     1      602            605        -3      821            805
##  4  2013     1     1      606            610        -4      858            910
##  5  2013     1     1      606            610        -4      837            845
##  6  2013     1     1      607            607         0      858            915
##  7  2013     1     1      611            600        11      945            931
##  8  2013     1     1      613            610         3      925            921
##  9  2013     1     1      615            615         0      833            842
## 10  2013     1     1      622            630        -8     1017           1014
## # ℹ 172,276 more rows
## # ℹ 13 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, daytime &lt;lgl&gt;,
## #   approx_ontime &lt;lgl&gt;</code></pre>
<div id="punktvergleiche" class="section level3" number="10.2.1">
<h3><span class="header-section-number">10.2.1</span>
Punktvergleiche</h3>
<p>Punktvergleiche mit <code>==</code> können sehr gefährlich sein, da
sie ein falsches Ergebnis ausgeben können.</p>
<pre class="r"><code>x &lt;- c(1 / 49 * 49, sqrt(2) ^ 2)
x</code></pre>
<pre><code>## [1] 1 2</code></pre>
<pre class="r"><code>x == c(1, 2)</code></pre>
<pre><code>## [1] FALSE FALSE</code></pre>
<p>Es wird von einer festen Anzahl an Nachkommastellen ausgegangen. Bei
Wurzel aber auch mal gerundet.</p>
<pre class="r"><code>print(x, digits = 16)</code></pre>
<pre><code>## [1] 0.9999999999999999 2.0000000000000004</code></pre>
<p>Eine Option ist es <code>dplyr::near()</code> zu nutzen, dass
geringfügige Abweichungen ignoriert.</p>
<pre class="r"><code>near(x, c(1, 2))</code></pre>
<pre><code>## [1] TRUE TRUE</code></pre>
</div>
<div id="missing-values" class="section level3" number="10.2.2">
<h3><span class="header-section-number">10.2.2</span> Missing
Values</h3>
<p>Fast jede Operation, die einen unbekannten Wert involviert, ist
wieder unbekannt.</p>
<pre class="r"><code>NA &gt; 5
10 == NA
NA == NA
# NA</code></pre>
<p>Willst du z.B. alle unbekannte Flüge finden, bei denen
<code>dept_time</code> fehlt, so funktioniert
<code>dept_time == NA</code> nicht, da das Ergebnis immer
<code>NA</code> ist und <code>filter()</code> sortiert automatisch
fehlende Werte aus.</p>
<pre class="r"><code>flights |&gt; 
  filter(dep_time == NA)</code></pre>
</div>
<div id="is.na" class="section level3" number="10.2.3">
<h3><span class="header-section-number">10.2.3</span>
<code>is.na()</code></h3>
<p><code>is.na()</code> funktioniert mit jedem Typ Vektor und gibt
<code>TRUE</code> aus für <em>Missing Values</em> und <code>FALSE</code>
für alles andere.</p>
<pre class="r"><code>is.na(c(TRUE, NA, FALSE))</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>is.na(c(1, NA, 3))</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>is.na(c(&quot;a&quot;, NA, &quot;b&quot;))</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE</code></pre>
<p>Jetzt können wir uns alle Zeilen ausgeben lassen, bei denen in
<code>dept_time</code> <em>Missing Values</em> vorkommen.</p>
<pre class="r"><code>flights |&gt; 
  filter(is.na(dep_time))</code></pre>
<pre><code>## # A tibble: 8,255 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1       NA           1630        NA       NA           1815
##  2  2013     1     1       NA           1935        NA       NA           2240
##  3  2013     1     1       NA           1500        NA       NA           1825
##  4  2013     1     1       NA            600        NA       NA            901
##  5  2013     1     2       NA           1540        NA       NA           1747
##  6  2013     1     2       NA           1620        NA       NA           1746
##  7  2013     1     2       NA           1355        NA       NA           1459
##  8  2013     1     2       NA           1420        NA       NA           1644
##  9  2013     1     2       NA           1321        NA       NA           1536
## 10  2013     1     2       NA           1545        NA       NA           1910
## # ℹ 8,245 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>In <code>arrange()</code> werden alle <em>Missing Values</em> ans
Ende gesetzt. Das kannst du überschreiben, indem du nach
<code>is.na()</code> sotierst.</p>
<pre class="r"><code>flights |&gt; 
  filter(month == 1, day == 1) |&gt; 
  arrange(dep_time)</code></pre>
<pre><code>## # A tibble: 842 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 832 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code>flights |&gt; 
  filter(month == 1, day == 1) |&gt; 
  arrange(desc(is.na(dep_time)), dep_time)</code></pre>
<pre><code>## # A tibble: 842 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1       NA           1630        NA       NA           1815
##  2  2013     1     1       NA           1935        NA       NA           2240
##  3  2013     1     1       NA           1500        NA       NA           1825
##  4  2013     1     1       NA            600        NA       NA            901
##  5  2013     1     1      517            515         2      830            819
##  6  2013     1     1      533            529         4      850            830
##  7  2013     1     1      542            540         2      923            850
##  8  2013     1     1      544            545        -1     1004           1022
##  9  2013     1     1      554            600        -6      812            837
## 10  2013     1     1      554            558        -4      740            728
## # ℹ 832 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
</div>
</div>
<div id="boolsche-algebra" class="section level2" number="10.3">
<h2><span class="header-section-number">10.3</span> Boolsche
Algebra</h2>
<p>Hast du einmal alle <em>logical vectors</em>, so kannst du sie
kombinieren: <code>&amp;</code> ist “and”, <code>|</code> ist “oder”,
<code>!</code> ist “nicht” und <code>xor()</code> ist “exklusives oder”,
also nicht die Schnittmenge.</p>
<div id="missing-values-1" class="section level3" number="10.3.1">
<h3><span class="header-section-number">10.3.1</span> Missing
Values</h3>
<pre class="r"><code>df &lt;- tibble(x = c(TRUE, FALSE, NA))

df |&gt; 
  mutate(
    and = x &amp; NA,
    or = x | NA
  )</code></pre>
<pre><code>## # A tibble: 3 × 3
##   x     and   or   
##   &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;
## 1 TRUE  NA    TRUE 
## 2 FALSE FALSE NA   
## 3 NA    NA    NA</code></pre>
<p>Ein <code>NA</code> in einem logischen Vektor bedeutet entweder
<code>TRUE</code> oder <code>FALSE</code>. <code>TRUE | TRUE</code> und
<code>FALSE | TRUE</code> sind beide <code>TRUE</code>, also muss
<code>NA | TRUE</code> auch <code>TRUE</code> sein. Ähnliches mit
<code>NA &amp; FALSE</code>.</p>
</div>
<div id="vermeide-x-a-b" class="section level3" number="10.3.2">
<h3><span class="header-section-number">10.3.2</span> Vermeide (x == a |
b)</h3>
<pre class="r"><code>flights |&gt; 
   filter(month == 11 | month == 12)</code></pre>
<pre><code>## # A tibble: 55,403 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013    11     1        5           2359         6      352            345
##  2  2013    11     1       35           2250       105      123           2356
##  3  2013    11     1      455            500        -5      641            651
##  4  2013    11     1      539            545        -6      856            827
##  5  2013    11     1      542            545        -3      831            855
##  6  2013    11     1      549            600       -11      912            923
##  7  2013    11     1      550            600       -10      705            659
##  8  2013    11     1      554            600        -6      659            701
##  9  2013    11     1      554            600        -6      826            827
## 10  2013    11     1      554            600        -6      749            751
## # ℹ 55,393 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>funktioniert. Wenn du aber auf der rechten Seite eine Zahl benutzt,
so ist das wie ein <code>TRUE</code>.</p>
<pre class="r"><code>flights |&gt; 
   filter(month == 11 | 12)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Vermeide dies, da jede Zeile dann ausgewählt wird.</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    nov = month == 11,
    final = nov | 12,
    .keep = &quot;used&quot;
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 3
##    month nov   final
##    &lt;int&gt; &lt;lgl&gt; &lt;lgl&gt;
##  1     1 FALSE TRUE 
##  2     1 FALSE TRUE 
##  3     1 FALSE TRUE 
##  4     1 FALSE TRUE 
##  5     1 FALSE TRUE 
##  6     1 FALSE TRUE 
##  7     1 FALSE TRUE 
##  8     1 FALSE TRUE 
##  9     1 FALSE TRUE 
## 10     1 FALSE TRUE 
## # ℹ 336,766 more rows</code></pre>
</div>
<div id="in" class="section level3" number="10.3.3">
<h3><span class="header-section-number">10.3.3</span>
<code>%in%</code></h3>
<p><code>x %in% y</code> gibt einen logischen Vektor der Länge von
<code>x</code> aus, der <code>TRUE</code> ist, wann immer ein Wert
<code>x</code> irgendwo in <code>y</code> ist.</p>
<pre class="r"><code>1:12 %in% c(1, 5, 11)</code></pre>
<pre><code>##  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE</code></pre>
<pre class="r"><code>letters[1:10] %in% c(&quot;a&quot;, &quot;e&quot;, &quot;i&quot;, &quot;o&quot;, &quot;u&quot;)</code></pre>
<pre><code>##  [1]  TRUE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE</code></pre>
<p>Um alle Flüge im November und Dezember zu finden, schreibe:</p>
<pre class="r"><code>flights |&gt; 
  filter(month %in% c(11, 12))</code></pre>
<pre><code>## # A tibble: 55,403 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013    11     1        5           2359         6      352            345
##  2  2013    11     1       35           2250       105      123           2356
##  3  2013    11     1      455            500        -5      641            651
##  4  2013    11     1      539            545        -6      856            827
##  5  2013    11     1      542            545        -3      831            855
##  6  2013    11     1      549            600       -11      912            923
##  7  2013    11     1      550            600       -10      705            659
##  8  2013    11     1      554            600        -6      659            701
##  9  2013    11     1      554            600        -6      826            827
## 10  2013    11     1      554            600        -6      749            751
## # ℹ 55,393 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Hier gelten andere Regeln für <code>NA</code>.</p>
<pre class="r"><code>c(1, 2, NA) == NA
#&gt; [1] NA NA NA
c(1, 2, NA) %in% NA
#&gt; [1] FALSE FALSE  TRUE</code></pre>
<p>So erhalten wir:</p>
<pre class="r"><code>flights |&gt; 
  filter(dep_time %in% c(NA, 0800))</code></pre>
<pre><code>## # A tibble: 8,803 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      800            800         0     1022           1014
##  2  2013     1     1      800            810       -10      949            955
##  3  2013     1     1       NA           1630        NA       NA           1815
##  4  2013     1     1       NA           1935        NA       NA           2240
##  5  2013     1     1       NA           1500        NA       NA           1825
##  6  2013     1     1       NA            600        NA       NA            901
##  7  2013     1     2      800            810       -10     1102           1116
##  8  2013     1     2       NA           1540        NA       NA           1747
##  9  2013     1     2       NA           1620        NA       NA           1746
## 10  2013     1     2       NA           1355        NA       NA           1459
## # ℹ 8,793 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
</div>
</div>
<div id="summaries" class="section level2" number="10.4">
<h2><span class="header-section-number">10.4</span> Summaries</h2>
<p>Nützliche Techniken für das Zusammenfassen von logischen Vektoren
erscheinen jetzt.</p>
<div id="logical-summaries" class="section level3" number="10.4.1">
<h3><span class="header-section-number">10.4.1</span> Logical
Summaries</h3>
<p>Es gibt zwei <em>logical summaries</em>: <code>any()</code> und
<code>all()</code>. <code>any(x)</code> ist das Äquivalent zu
<code>|</code>; es gibt <code>TRUE</code> aus, wenn es irgendein
<code>TRUE</code> in <code>x</code> gibt. <code>all(x)</code> ist
äquivalent zu <code>&amp;</code>. Es gibt <code>TRUE</code> zurück, wenn
alle Werte von <code>x</code> <code>TRUE</code>’s sind. <code>NA</code>
wird ausgegeben, wenn es <em>Missing Values</em> gibt, und zu vermeiden
ist dies mit <code>na.rm = TRUE</code>.<br />
Gibt es Tage, an denen alle Flüge Verspätung hatten?</p>
<pre class="r"><code>flights |&gt; 
  group_by(year, month, day) |&gt; 
  summarize(
    all_delayed = all(arr_delay &gt;= 0, na.rm = TRUE),
    any_delayed = any(arr_delay &gt;= 0, na.rm = TRUE),
    .groups = &quot;drop&quot;
  )</code></pre>
<pre><code>## # A tibble: 365 × 5
##     year month   day all_delayed any_delayed
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;lgl&gt;       &lt;lgl&gt;      
##  1  2013     1     1 FALSE       TRUE       
##  2  2013     1     2 FALSE       TRUE       
##  3  2013     1     3 FALSE       TRUE       
##  4  2013     1     4 FALSE       TRUE       
##  5  2013     1     5 FALSE       TRUE       
##  6  2013     1     6 FALSE       TRUE       
##  7  2013     1     7 FALSE       TRUE       
##  8  2013     1     8 FALSE       TRUE       
##  9  2013     1     9 FALSE       TRUE       
## 10  2013     1    10 FALSE       TRUE       
## # ℹ 355 more rows</code></pre>
</div>
<div id="numeric-summaries-of-logical-vectors" class="section level3"
number="10.4.2">
<h3><span class="header-section-number">10.4.2</span> Numeric Summaries
Of Logical Vectors</h3>
<p>Wenn du einen logischen Vektor in einem numerischen Kontext benutzt,
so wird <code>TRUE</code> zu <code>1</code> und <code>FALSE</code> zu
<code>0</code>. So lassen sich <code>sum()</code> und
<code>mean()</code> sehr nützlich mit logischen Vektoren vereinen, da
die Anzahl an <code>TRUE</code>’s und der Anteil ausgegeben wird.</p>
<pre class="r"><code>flights |&gt; 
  group_by(year, month, day) |&gt; 
  summarize(
    prop_delayed = mean(arr_delay &gt; 0, na.rm = TRUE),
    .groups = &quot;drop&quot;
  ) |&gt; 
  ggplot(aes(x = prop_delayed)) + 
  geom_histogram(binwidth = 0.05)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-241-1.png" width="672" /></p>
<p>Wieviele Flüge sind vor 5 Uhr abgeflogen?</p>
<pre class="r"><code>flights |&gt; 
  group_by(year, month, day) |&gt; 
  summarize(
    n_early = sum(dep_time &lt; 500, na.rm = TRUE),
    .groups = &quot;drop&quot;
  ) |&gt; 
  arrange(desc(n_early))</code></pre>
<pre><code>## # A tibble: 365 × 4
##     year month   day n_early
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;   &lt;int&gt;
##  1  2013     6    28      32
##  2  2013     4    10      30
##  3  2013     7    28      30
##  4  2013     3    18      29
##  5  2013     7     7      29
##  6  2013     7    10      29
##  7  2013     6    27      25
##  8  2013     6    13      24
##  9  2013     3     8      22
## 10  2013     7    22      22
## # ℹ 355 more rows</code></pre>
</div>
<div id="logical-subsetting" class="section level3" number="10.4.3">
<h3><span class="header-section-number">10.4.3</span> Logical
Subsetting</h3>
<p>Wir können <code>logical vector</code> auch in <code>summarize</code>
benutzen, um hier eine einzelne Variable zu filtern. Die Nutzung der
eckigen Klammern hilft.<br />
Wir wollen den durchschnittlichen <em>Delay</em>, also Verspätung,
berechnen. Also nur für Flüge mit Verspätung (&gt;0). Eine
Möglichkeit:</p>
<pre class="r"><code>flights |&gt; 
  filter(arr_delay &gt; 0) |&gt; 
  group_by(year, month, day) |&gt; 
  summarize(
    behind = mean(arr_delay),
    n = n(),
    .groups = &quot;drop&quot;
  )</code></pre>
<pre><code>## # A tibble: 365 × 5
##     year month   day behind     n
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;int&gt;
##  1  2013     1     1   32.5   461
##  2  2013     1     2   32.0   535
##  3  2013     1     3   27.7   460
##  4  2013     1     4   28.3   297
##  5  2013     1     5   22.6   238
##  6  2013     1     6   24.4   381
##  7  2013     1     7   27.8   243
##  8  2013     1     8   20.8   275
##  9  2013     1     9   25.6   287
## 10  2013     1    10   27.3   220
## # ℹ 355 more rows</code></pre>
<p>Aber was, wenn wir auch die durchschnittliche Verspätung für Flüge
berechnen wollen, die zu früh angekommen sind?</p>
<pre class="r"><code>flights |&gt; 
  group_by(year, month, day) |&gt; 
  summarize(
    behind = mean(arr_delay[arr_delay &gt; 0], na.rm = TRUE),
    ahead = mean(arr_delay[arr_delay &lt; 0], na.rm = TRUE),
    n = n(),
    .groups = &quot;drop&quot;
  )</code></pre>
<pre><code>## # A tibble: 365 × 6
##     year month   day behind ahead     n
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;
##  1  2013     1     1   32.5 -12.5   842
##  2  2013     1     2   32.0 -14.3   943
##  3  2013     1     3   27.7 -18.2   914
##  4  2013     1     4   28.3 -17.0   915
##  5  2013     1     5   22.6 -14.0   720
##  6  2013     1     6   24.4 -13.6   832
##  7  2013     1     7   27.8 -17.0   933
##  8  2013     1     8   20.8 -14.3   899
##  9  2013     1     9   25.6 -13.0   902
## 10  2013     1    10   27.3 -16.4   932
## # ℹ 355 more rows</code></pre>
<p>Bedenke auch den Unterschied der Gruppengröße: <em>delayed</em>
vs. <em>total flights</em>.</p>
</div>
</div>
<div id="konditionale-transformationen" class="section level2"
number="10.5">
<h2><span class="header-section-number">10.5</span> Konditionale
Transformationen</h2>
<p>Hier gibt es zwei mächtige Werkzeuge: <code>if_else()</code> und
<code>case_when()</code>.</p>
<div id="if_else" class="section level3" number="10.5.1">
<h3><span class="header-section-number">10.5.1</span>
<code>if_else()</code></h3>
<p>Mit <code>dplyr::if_else()</code> kannst du einen Wert benutzen, wenn
die Bedingung <code>TRUE</code> ist und einen anderen, wenn sie
<code>FALSE</code> ist. Das erste der drei Argumente ist die
<code>condition</code>, ein <em>logical vector</em>. Dann
<code>true</code>, wenn die Bedingung erfüllt ist, und
<code>false</code>, der Output, falls die <em>condition false</em>
ist.</p>
<pre class="r"><code>x &lt;- c(-3:3, NA)
if_else(x &gt; 0, &quot;+ve&quot;, &quot;-ve&quot;)</code></pre>
<pre><code>## [1] &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; &quot;+ve&quot; &quot;+ve&quot; &quot;+ve&quot; NA</code></pre>
<p>Es gibt tatsächlich ein viertes optionales Argument, falls der Input
<code>NA</code> ist.</p>
<pre class="r"><code>if_else(x &gt; 0, &quot;+ve&quot;, &quot;-ve&quot;, &quot;???&quot;)</code></pre>
<pre><code>## [1] &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; &quot;+ve&quot; &quot;+ve&quot; &quot;+ve&quot; &quot;???&quot;</code></pre>
<p>Du kannst anstelle der <code>true</code>, <code>false</code>
Argumente auch Vektoren benutzen.</p>
<pre class="r"><code>if_else(x &lt; 0, -x, x)</code></pre>
<pre><code>## [1]  3  2  1  0  1  2  3 NA</code></pre>
<pre class="r"><code>x1 &lt;- c(NA, 1, 2, NA)
y1 &lt;- c(3, NA, 4, 6)
if_else(is.na(x1), y1, x1)</code></pre>
<pre><code>## [1] 3 1 2 6</code></pre>
<pre class="r"><code>if_else(x == 0, &quot;0&quot;, if_else(x &lt; 0, &quot;-ve&quot;, &quot;+ve&quot;), &quot;???&quot;)</code></pre>
<pre><code>## [1] &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; &quot;0&quot;   &quot;+ve&quot; &quot;+ve&quot; &quot;+ve&quot; &quot;???&quot;</code></pre>
<p>Die letzte Zeile ist hart zu lesen, deshalb wechseln wir lieber zu
<code>dplyr::case_when()</code>.</p>
</div>
<div id="case_when" class="section level3" number="10.5.2">
<h3><span class="header-section-number">10.5.2</span>
<code>case_when()</code></h3>
<p>Eine spezielle Syntax haben wir hier. Sie nimmt Paare vor:
<code>condition ~ output</code>. <code>condition</code> muss ein
<em>logical vector</em> sein. Bei Erfüllung wird <code>output</code>
genutzt.</p>
<pre class="r"><code>case_when(
  x == 0   ~ &quot;0&quot;,
  x &lt; 0    ~ &quot;-ve&quot;, 
  x &gt; 0    ~ &quot;+ve&quot;,
  is.na(x) ~ &quot;???&quot;
)</code></pre>
<pre><code>## [1] &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; &quot;0&quot;   &quot;+ve&quot; &quot;+ve&quot; &quot;+ve&quot; &quot;???&quot;</code></pre>
<p>Wenn kein Fall passt, erhalten wir ein <code>NA</code>.</p>
<pre class="r"><code>case_when(
  x &lt; 0 ~ &quot;-ve&quot;,
  x &gt; 0 ~ &quot;+ve&quot;
)</code></pre>
<pre><code>## [1] &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; NA    &quot;+ve&quot; &quot;+ve&quot; &quot;+ve&quot; NA</code></pre>
<p>Für einen <em>default</em>, nutze <code>TRUE</code> auf der linken
Seite.</p>
<pre class="r"><code>case_when(
  x &lt; 0 ~ &quot;-ve&quot;,
  x &gt; 0 ~ &quot;+ve&quot;,
  TRUE ~ &quot;???&quot;
)</code></pre>
<pre><code>## [1] &quot;-ve&quot; &quot;-ve&quot; &quot;-ve&quot; &quot;???&quot; &quot;+ve&quot; &quot;+ve&quot; &quot;+ve&quot; &quot;???&quot;</code></pre>
<p>Sind mehrere Bedingungen erfüllt, so wird nur der erste genutzt.</p>
<pre class="r"><code>case_when(
  x &gt; 0 ~ &quot;+ve&quot;,
  x &gt; 3 ~ &quot;big&quot;
)</code></pre>
<pre><code>## [1] NA    NA    NA    NA    &quot;+ve&quot; &quot;+ve&quot; &quot;+ve&quot; NA</code></pre>
<p>Etwas so schönes können wir bauen:</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    status = case_when(
      is.na(arr_delay)      ~ &quot;cancelled&quot;,
      arr_delay &lt; -30       ~ &quot;very early&quot;,
      arr_delay &lt; -15       ~ &quot;early&quot;,
      abs(arr_delay) &lt;= 15  ~ &quot;on time&quot;,
      arr_delay &gt; 15        ~ &quot;late&quot;,
      arr_delay &gt; 60        ~ &quot;very late&quot;,
    ),
    .keep = &quot;used&quot;
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 2
##    arr_delay status 
##        &lt;dbl&gt; &lt;chr&gt;  
##  1        11 on time
##  2        20 late   
##  3        33 late   
##  4       -18 early  
##  5       -25 early  
##  6        12 on time
##  7        19 late   
##  8       -14 on time
##  9        -8 on time
## 10         8 on time
## # ℹ 336,766 more rows</code></pre>
</div>
<div id="kompatible-typen" class="section level3" number="10.5.3">
<h3><span class="header-section-number">10.5.3</span> Kompatible
Typen</h3>
<p><code>ifelse()</code> und <code>case_when()</code> erfordern passende
Typen. Passen sie nicht, gibt es Fehlermeldungen.</p>
<pre class="r"><code>if_else(c(TRUE,FALSE), &quot;a&quot;, 2)</code></pre>
<p>Kompatibel sind:</p>
<ul>
<li>numerische und logische Vektoren.</li>
<li><em>Strings</em> und Faktoren. Denke bei einem Faktor an einen
<em>String</em> mit begrenzten Werten.</li>
<li><em>Dates</em> und <em>date-times</em>.</li>
<li><code>NA</code>-ä- ist kompatibel mit allem.</li>
</ul>
</div>
</div>
</div>
<div id="transformieren-zahlen" class="section level1" number="11">
<h1><span class="header-section-number">11</span> Transformieren:
Zahlen</h1>
<div id="einleitung-7" class="section level2" number="11.1">
<h2><span class="header-section-number">11.1</span> Einleitung</h2>
<p>Das Rückgrat der <strong>Data Science</strong> sind natürlich Zahlen.
Was kannst du in R alles mit ihnen machen?</p>
<div id="voraussetzungen-6" class="section level3" number="11.1.1">
<h3><span class="header-section-number">11.1.1</span>
Voraussetzungen</h3>
<pre class="r"><code>library(tidyverse)
library(nycflights13)</code></pre>
</div>
</div>
<div id="zahlen-machen" class="section level2" number="11.2">
<h2><span class="header-section-number">11.2</span> Zahlen machen</h2>
<p><code>readr</code> bietet zwei wichtige Funktionen für die
Transformation von <em>Strings</em> in Zahlen:
<code>parse_double()</code> und <code>parse_number()</code>. Benutze
<code>parse_double()</code>, wenn du Zahlen als <em>Strings</em>
geschrieben hast.</p>
<pre class="r"><code>x &lt;- c(&quot;1.2&quot;, &quot;5.6&quot;, &quot;1e3&quot;)
parse_double(x)</code></pre>
<pre><code>## [1]    1.2    5.6 1000.0</code></pre>
<p>Benutze <code>parse_number()</code>, wenn dein <em>String</em>
nicht-numerischen Text enthält, den du ignorieren willst.</p>
<pre class="r"><code>x &lt;- c(&quot;$1,234&quot;, &quot;USD 3,513&quot;, &quot;59%&quot;)
parse_number(x)</code></pre>
<pre><code>## [1] 1234 3513   59</code></pre>
</div>
<div id="counts" class="section level2" number="11.3">
<h2><span class="header-section-number">11.3</span> Counts</h2>
<p>Für schnelle Entdeckungen und Checken ist diese Funktion
<code>count()</code> genial. Auch sortieren geht rasch.</p>
<pre class="r"><code>flights |&gt;
  print(n = 10)</code></pre>
<pre><code>## # A tibble: 336,776 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      533            529         4      850            830
##  3  2013     1     1      542            540         2      923            850
##  4  2013     1     1      544            545        -1     1004           1022
##  5  2013     1     1      554            600        -6      812            837
##  6  2013     1     1      554            558        -4      740            728
##  7  2013     1     1      555            600        -5      913            854
##  8  2013     1     1      557            600        -3      709            723
##  9  2013     1     1      557            600        -3      838            846
## 10  2013     1     1      558            600        -2      753            745
## # ℹ 336,766 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<pre class="r"><code>flights |&gt; count(dest)</code></pre>
<pre><code>## # A tibble: 105 × 2
##    dest      n
##    &lt;chr&gt; &lt;int&gt;
##  1 ABQ     254
##  2 ACK     265
##  3 ALB     439
##  4 ANC       8
##  5 ATL   17215
##  6 AUS    2439
##  7 AVL     275
##  8 BDL     443
##  9 BGR     375
## 10 BHM     297
## # ℹ 95 more rows</code></pre>
<pre class="r"><code>flights |&gt; count(dest, sort = TRUE)</code></pre>
<pre><code>## # A tibble: 105 × 2
##    dest      n
##    &lt;chr&gt; &lt;int&gt;
##  1 ORD   17283
##  2 ATL   17215
##  3 LAX   16174
##  4 BOS   15508
##  5 MCO   14082
##  6 CLT   14064
##  7 SFO   13331
##  8 FLL   12055
##  9 MIA   11728
## 10 DCA    9705
## # ℹ 95 more rows</code></pre>
<p>Dieselbe Berechnung kannst du per Hand mit <code>group_by()</code>
und <code>summarize()</code> und <code>n()</code> vornehmen. Jetzt
kannst du auch andere <em>Summaries</em> vornehmen.</p>
<pre class="r"><code>flights |&gt; 
  group_by(dest) |&gt; 
  summarize(
    n = n(),
    delay = mean(arr_delay, na.rm = TRUE)
  )</code></pre>
<pre><code>## # A tibble: 105 × 3
##    dest      n delay
##    &lt;chr&gt; &lt;int&gt; &lt;dbl&gt;
##  1 ABQ     254  4.38
##  2 ACK     265  4.85
##  3 ALB     439 14.4 
##  4 ANC       8 -2.5 
##  5 ATL   17215 11.3 
##  6 AUS    2439  6.02
##  7 AVL     275  8.00
##  8 BDL     443  7.05
##  9 BGR     375  8.03
## 10 BHM     297 16.9 
## # ℹ 95 more rows</code></pre>
<p><code>n()</code> funktioniert natürlich nur in der <code>dplyr</code>
Umgebung und brauch keine Argumente. Es gibt jedoch ein paar Varianten
von <code>n()</code>:</p>
<ul>
<li><code>n_distinct(x)</code> zählt die Anzahl einzigartiger Werte
einer oder mehrerer Variablen. Welche Ziele werden von den meisten
Fluglinien angesteuert?</li>
</ul>
<pre class="r"><code>flights |&gt; 
  group_by(dest) |&gt; 
  summarize(
    carriers = n_distinct(carrier)
  ) |&gt; 
  arrange(desc(carriers))</code></pre>
<pre><code>## # A tibble: 105 × 2
##    dest  carriers
##    &lt;chr&gt;    &lt;int&gt;
##  1 ATL          7
##  2 BOS          7
##  3 CLT          7
##  4 ORD          7
##  5 TPA          7
##  6 AUS          6
##  7 DCA          6
##  8 DTW          6
##  9 IAD          6
## 10 MSP          6
## # ℹ 95 more rows</code></pre>
<ul>
<li>Ein gewichteter <em>Count</em> ist eine Summe. Wieviel Meilen ist
jedes Flugzeug geflogen?</li>
</ul>
<pre class="r"><code>flights |&gt; 
  group_by(tailnum) |&gt; 
  summarize(miles = sum(distance))</code></pre>
<pre><code>## # A tibble: 4,044 × 2
##    tailnum  miles
##    &lt;chr&gt;    &lt;dbl&gt;
##  1 D942DN    3418
##  2 N0EGMQ  250866
##  3 N10156  115966
##  4 N102UW   25722
##  5 N103US   24619
##  6 N104UW   25157
##  7 N10575  150194
##  8 N105UW   23618
##  9 N107US   21677
## 10 N108UW   32070
## # ℹ 4,034 more rows</code></pre>
<p><code>count()</code> mit dem Argument <code>wt</code> macht
dasselbe.</p>
<pre class="r"><code>flights |&gt; count(tailnum, wt = distance)</code></pre>
<pre><code>## # A tibble: 4,044 × 2
##    tailnum      n
##    &lt;chr&gt;    &lt;dbl&gt;
##  1 D942DN    3418
##  2 N0EGMQ  250866
##  3 N10156  115966
##  4 N102UW   25722
##  5 N103US   24619
##  6 N104UW   25157
##  7 N10575  150194
##  8 N105UW   23618
##  9 N107US   21677
## 10 N108UW   32070
## # ℹ 4,034 more rows</code></pre>
<p><em>Missing Values</em> kannst du zählen durch Kombinieren von
<code>sum()</code> und <code>is.na()</code>. Im <code>flights</code>
Datensatz sind es die gecancellten Flüge.</p>
<pre class="r"><code>flights |&gt; 
  group_by(dest) |&gt; 
  summarize(n_cancelled = sum(is.na(dep_time))) </code></pre>
<pre><code>## # A tibble: 105 × 2
##    dest  n_cancelled
##    &lt;chr&gt;       &lt;int&gt;
##  1 ABQ             0
##  2 ACK             0
##  3 ALB            20
##  4 ANC             0
##  5 ATL           317
##  6 AUS            21
##  7 AVL            12
##  8 BDL            31
##  9 BGR            15
## 10 BHM            25
## # ℹ 95 more rows</code></pre>
</div>
<div id="numerische-transformationen" class="section level2"
number="11.4">
<h2><span class="header-section-number">11.4</span> Numerische
Transformationen</h2>
<p>Transformationsfunktionen funktionieren sehr gut mit
<code>mutate()</code>, weil ihr Output dieselbe Länge wie ihr Input
hat.</p>
<div id="arithmetische-und-recycling-regeln" class="section level3"
number="11.4.1">
<h3><span class="header-section-number">11.4.1</span> Arithmetische und
recycling Regeln</h3>
<p>Die Basics wie Addition usw. sind bekannt. Was aber passiert, wenn
linke und rechte Seite verschiedene Längen haben?
<code>flights |&gt; mutate(air_time = air_time / 60)</code>. 336 766
Zahlen links und eine rechts. Der kürzere Vektor wird wiederholt.</p>
<pre class="r"><code>x &lt;- c(1, 2, 10, 20)
x / 5</code></pre>
<pre><code>## [1] 0.2 0.4 2.0 4.0</code></pre>
<pre class="r"><code>x / c(5, 5, 5, 5)</code></pre>
<pre><code>## [1] 0.2 0.4 2.0 4.0</code></pre>
<p>Eine Warnung wird ausgegeben, wenn der längere kein Vielfaches des
kürzeren Vektors ist.</p>
<pre class="r"><code>x * c(1, 2, 3)
#&gt; Warning in x * c(1, 2, 3): longer object length is not a multiple of shorter</code></pre>
<p>Diese <em>recycling rules</em> werden auch auf logische Vergleiche
angewendet (<code>==</code>, <code>&lt;</code>, <code>&lt;=</code>,
<code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>) und führen zu
überraschenden Ergebnissen, wenn man fälschlicherweise <code>==</code>
statt <code>%in%</code> anwendet.</p>
<pre class="r"><code>flights |&gt; 
  filter(month == c(1, 2))</code></pre>
<pre><code>## # A tibble: 25,977 × 19
##     year month   day dep_time sched_dep_time dep_delay arr_time sched_arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;          &lt;int&gt;
##  1  2013     1     1      517            515         2      830            819
##  2  2013     1     1      542            540         2      923            850
##  3  2013     1     1      554            600        -6      812            837
##  4  2013     1     1      555            600        -5      913            854
##  5  2013     1     1      557            600        -3      838            846
##  6  2013     1     1      558            600        -2      849            851
##  7  2013     1     1      558            600        -2      924            917
##  8  2013     1     1      559            600        -1      941            910
##  9  2013     1     1      559            600        -1      854            902
## 10  2013     1     1      600            600         0      837            825
## # ℹ 25,967 more rows
## # ℹ 11 more variables: arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;,
## #   tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;,
## #   hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Es findet natürlich nur Flüge in ungeraden Zeilen, die im Januar, und
Flüge in geraden Zeilen, die im Februar geflogen sind. Um uns vor
solchen Fehlern zu schützen: die meisten <code>tidyverse</code>
Funktionen benutzen eine striktere Form von Recycling, das nur einzelne
Werte recyclt.</p>
</div>
<div id="minimum-und-maximum" class="section level3" number="11.4.2">
<h3><span class="header-section-number">11.4.2</span> Minimum und
Maximum</h3>
<p>Arithmetische Funktionen funktionieren gut mit Paaren von Variablen.
<code>pmin()</code> und <code>pmax()</code> geben den kleinsten oder
größten Wert in jeder Zeile zurück.</p>
<pre class="r"><code>df &lt;- tribble(
  ~x, ~y,
  1,  3,
  5,  2,
  7, NA,
)

df |&gt; 
  mutate(
    min = pmin(x, y, na.rm = TRUE),
    max = pmax(x, y, na.rm = TRUE)
  )</code></pre>
<pre><code>## # A tibble: 3 × 4
##       x     y   min   max
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     3     1     3
## 2     5     2     2     5
## 3     7    NA     7     7</code></pre>
<p>Sie sind ungleich <code>min()</code> und <code>max()</code>.</p>
<pre class="r"><code>df |&gt; 
  mutate(
    min = min(x, y, na.rm = TRUE),
    max = max(x, y, na.rm = TRUE)
  )</code></pre>
<pre><code>## # A tibble: 3 × 4
##       x     y   min   max
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1     3     1     7
## 2     5     2     1     7
## 3     7    NA     1     7</code></pre>
</div>
<div id="modulare-arithmetic" class="section level3" number="11.4.3">
<h3><span class="header-section-number">11.4.3</span> Modulare
Arithmetic</h3>
<pre class="r"><code>1:10 %/% 3 # Ganze Zahl bei Division vor dem Komma</code></pre>
<pre><code>##  [1] 0 0 1 1 1 2 2 2 3 3</code></pre>
<pre class="r"><code>1:10 %% 3 # Nachkommazahl bzw. Rest</code></pre>
<pre><code>##  [1] 1 2 0 1 2 0 1 2 0 1</code></pre>
<p>Moduare Arithmetic ist für die Flüge nützlich, da die Zeitvarable
<code>sched_dep_time</code> in <code>hour</code> und <code>minute</code>
umgerechnet werden kann:</p>
<pre class="r"><code>flights |&gt; 
  mutate(
    hour = sched_dep_time %/% 100,
    minute = sched_dep_time %% 100,
    .keep = &quot;used&quot;
  )</code></pre>
<pre><code>## # A tibble: 336,776 × 3
##    sched_dep_time  hour minute
##             &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1            515     5     15
##  2            529     5     29
##  3            540     5     40
##  4            545     5     45
##  5            600     6      0
##  6            558     5     58
##  7            600     6      0
##  8            600     6      0
##  9            600     6      0
## 10            600     6      0
## # ℹ 336,766 more rows</code></pre>
<p>So können wir den Anteil der gestrichenen Flüge über den Tag
berechnen.</p>
<pre class="r"><code>flights |&gt; 
  group_by(hour = sched_dep_time %/% 100) |&gt; 
  summarize(prop_cancelled = mean(is.na(dep_time)), n = n()) |&gt; 
  filter(hour &gt; 1) |&gt; 
  ggplot(aes(x = hour, y = prop_cancelled)) +
  geom_line(color = &quot;grey50&quot;) + 
  geom_point(aes(size = n))</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-270-1.png" width="672" /></p>
</div>
<div id="logarithmus" class="section level3" number="11.4.4">
<h3><span class="header-section-number">11.4.4</span> Logarithmus</h3>
<pre class="r"><code>starting &lt;- 100
interest &lt;- 1.05

money &lt;- tibble(
  year = 1:50,
  money = starting * interest ^ year
)</code></pre>
<p>Eine Exponentialkurve zeigt dein Geldwachstum an.</p>
<pre class="r"><code>ggplot(money, aes(x = year, y = money)) +
  geom_line()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-272-1.png" width="672" /></p>
<p>Logarithmische Transformation der y-Achse zeigt eine gerade
Linie.</p>
<pre class="r"><code>ggplot(money, aes(x = year, y = money)) +
  geom_line() + 
  scale_y_log10()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-273-1.png" width="672" /></p>
</div>
<div id="runden" class="section level3" number="11.4.5">
<h3><span class="header-section-number">11.4.5</span> Runden</h3>
<p>Benutze <code>round(x)</code> zum Runden zum nächsten Nachbarn.</p>
<pre class="r"><code>round(123.456)</code></pre>
<pre><code>## [1] 123</code></pre>
<p>Präzisiere das Ganze über ein zweites Argument.</p>
<pre class="r"><code>round(123.456, 2)  # two digits</code></pre>
<pre><code>## [1] 123.46</code></pre>
<pre class="r"><code>round(123.456, 1)  # one digit</code></pre>
<pre><code>## [1] 123.5</code></pre>
<pre class="r"><code>round(123.456, -1) # round to nearest ten</code></pre>
<pre><code>## [1] 120</code></pre>
<pre class="r"><code>round(123.456, -2) # round to nearest hundred</code></pre>
<pre><code>## [1] 100</code></pre>
<p>Es wird bei .5 immer zur geraden Zahl gerundet. Abrunden und
Aufrunden durch <code>floor()</code> und <code>ceiling()</code>.</p>
<pre class="r"><code>x &lt;- 123.456
floor(x)</code></pre>
<pre><code>## [1] 123</code></pre>
<pre class="r"><code>ceiling(x)</code></pre>
<pre><code>## [1] 124</code></pre>
</div>
<div id="zahlen-in-intervalle-einteilen" class="section level3"
number="11.4.6">
<h3><span class="header-section-number">11.4.6</span> Zahlen in
Intervalle einteilen</h3>
<pre class="r"><code>x &lt;- c(1, 2, 5, 10, 15, 20)
cut(x, breaks = c(0, 5, 10, 15, 20))</code></pre>
<pre><code>## [1] (0,5]   (0,5]   (0,5]   (5,10]  (10,15] (15,20]
## Levels: (0,5] (5,10] (10,15] (15,20]</code></pre>
<pre class="r"><code>cut(x, breaks = c(0, 5, 10, 100))</code></pre>
<pre><code>## [1] (0,5]    (0,5]    (0,5]    (5,10]   (10,100] (10,100]
## Levels: (0,5] (5,10] (10,100]</code></pre>
<p>Benutze deine eigenen Labels, aber immer eins weniger als
<code>breaks</code>.</p>
<pre class="r"><code>cut(x, 
  breaks = c(0, 5, 10, 15, 20), 
  labels = c(&quot;sm&quot;, &quot;md&quot;, &quot;lg&quot;, &quot;xl&quot;)
)</code></pre>
<pre><code>## [1] sm sm sm md lg xl
## Levels: sm md lg xl</code></pre>
<p>Jeder Wert, der nicht im Intervall ist, bekommt ein
<code>NA</code>.</p>
<pre class="r"><code>y &lt;- c(NA, -10, 5, 10, 30)
cut(y, breaks = c(0, 5, 10, 15, 20))</code></pre>
<pre><code>## [1] &lt;NA&gt;   &lt;NA&gt;   (0,5]  (5,10] &lt;NA&gt;  
## Levels: (0,5] (5,10] (10,15] (15,20]</code></pre>
</div>
<div id="kummulieren-und-aggregieren" class="section level3"
number="11.4.7">
<h3><span class="header-section-number">11.4.7</span> Kummulieren und
Aggregieren</h3>
<pre class="r"><code>x &lt;- 1:10
cumsum(x)</code></pre>
<pre><code>##  [1]  1  3  6 10 15 21 28 36 45 55</code></pre>
<p>Im <strong>slider</strong> Paket gibt es komplexere Aggregate.</p>
</div>
</div>
<div id="generelle-transformationen" class="section level2"
number="11.5">
<h2><span class="header-section-number">11.5</span> Generelle
Transformationen</h2>
<div id="ränge" class="section level3" number="11.5.1">
<h3><span class="header-section-number">11.5.1</span> Ränge</h3>
<p><code>dplyr::min_rank()</code> behandelt Bindungen als 1. 2. 2.
4.</p>
<pre class="r"><code>x &lt;- c(1, 4, 2, 3, 2, NA)
min_rank(x)</code></pre>
<pre><code>## [1]  1  5  2  4  2 NA</code></pre>
<pre class="r"><code>min_rank(desc(x))</code></pre>
<pre><code>## [1]  5  1  3  2  3 NA</code></pre>
<p>Ähnliche Varianten findest du in der Dokumentation.</p>
<pre class="r"><code>df &lt;- tibble(x = x)
df |&gt; 
  mutate(
    row_number = row_number(x),
    dense_rank = dense_rank(x),
    percent_rank = percent_rank(x),
    cume_dist = cume_dist(x)
  )</code></pre>
<pre><code>## # A tibble: 6 × 5
##       x row_number dense_rank percent_rank cume_dist
##   &lt;dbl&gt;      &lt;int&gt;      &lt;int&gt;        &lt;dbl&gt;     &lt;dbl&gt;
## 1     1          1          1         0          0.2
## 2     4          5          4         1          1  
## 3     2          2          2         0.25       0.6
## 4     3          4          3         0.75       0.8
## 5     2          3          2         0.25       0.6
## 6    NA         NA         NA        NA         NA</code></pre>
</div>
<div id="verschiebungen" class="section level3" number="11.5.2">
<h3><span class="header-section-number">11.5.2</span>
Verschiebungen</h3>
<pre class="r"><code>x &lt;- c(2, 5, 11, 11, 19, 35)
lag(x) # Verschebung eins nach rechts</code></pre>
<pre><code>## [1] NA  2  5 11 11 19</code></pre>
<pre class="r"><code>lead(x) # Verschiebung eins nach links</code></pre>
<pre><code>## [1]  5 11 11 19 35 NA</code></pre>
<pre class="r"><code>x - lag(x) # Differenz zwischen aktuellem Wert und Vorgänger</code></pre>
<pre><code>## [1] NA  3  6  0  8 16</code></pre>
<pre class="r"><code>x == lag(x) # wechselt der aktuelle Wert?</code></pre>
<pre><code>## [1]    NA FALSE FALSE  TRUE FALSE FALSE</code></pre>
<p>Über ein zweites Agument kannst du den “Lag” per Hand bestimmen.</p>
</div>
<div id="consecutive_id" class="section level3" number="11.5.3">
<h3><span class="header-section-number">11.5.3</span>
<code>consecutive_id()</code></h3>
<p>Zeiten, wann eine Website besucht wird:</p>
<pre class="r"><code>events &lt;- tibble(
  time = c(0, 1, 2, 3, 5, 10, 12, 15, 17, 19, 20, 27, 28, 30)
)</code></pre>
<p>Zeit zwischen zwei Besuchen, “gap” größer gleich 5 soll identifiziert
werden.</p>
<pre class="r"><code>events &lt;- events |&gt; 
  mutate(
    diff = time - lag(time, default = first(time)),
    gap = diff &gt;= 5
  )
events</code></pre>
<pre><code>## # A tibble: 14 × 3
##     time  diff gap  
##    &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
##  1     0     0 FALSE
##  2     1     1 FALSE
##  3     2     1 FALSE
##  4     3     1 FALSE
##  5     5     2 FALSE
##  6    10     5 TRUE 
##  7    12     2 FALSE
##  8    15     3 FALSE
##  9    17     2 FALSE
## 10    19     2 FALSE
## 11    20     1 FALSE
## 12    27     7 TRUE 
## 13    28     1 FALSE
## 14    30     2 FALSE</code></pre>
<p>Vom logischen Vektor wollen wir zu einer Gruppierungsvariable: mit
<code>cur_group_id()</code>:</p>
<pre class="r"><code>events &lt;- events |&gt;
group_by(gap) |&gt;
mutate(group = cur_group_id())
events</code></pre>
<pre><code>## # A tibble: 14 × 4
## # Groups:   gap [2]
##     time  diff gap   group
##    &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;int&gt;
##  1     0     0 FALSE     1
##  2     1     1 FALSE     1
##  3     2     1 FALSE     1
##  4     3     1 FALSE     1
##  5     5     2 FALSE     1
##  6    10     5 TRUE      2
##  7    12     2 FALSE     1
##  8    15     3 FALSE     1
##  9    17     2 FALSE     1
## 10    19     2 FALSE     1
## 11    20     1 FALSE     1
## 12    27     7 TRUE      2
## 13    28     1 FALSE     1
## 14    30     2 FALSE     1</code></pre>
</div>
</div>
<div id="numerische-zusammenfassungen" class="section level2"
number="11.6">
<h2><span class="header-section-number">11.6</span> Numerische
Zusammenfassungen</h2>
<div id="zentrieren" class="section level3" number="11.6.1">
<h3><span class="header-section-number">11.6.1</span> Zentrieren</h3>
<p><code>mean()</code> vs. <code>median()</code>. Je nach Ausreißer und
Form erhalten wir verschiedenen Ergebnisse. Bedenke die
Einkommensverteilung. Hier ist der <code>mean</code> mit Sicherheit
größer.<br />
Bei unseren Flugverspätungen eben.</p>
<pre class="r"><code>flights |&gt;
  group_by(year, month, day) |&gt;
  summarize(
    mean = mean(dep_delay, na.rm = TRUE),
    median = median(dep_delay, na.rm = TRUE),
    n = n(),
    .groups = &quot;drop&quot;
  ) |&gt; 
  ggplot(aes(x = mean, y = median)) + 
  geom_abline(slope = 1, intercept = 0, color = &quot;white&quot;, size = 2) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-288-1.png" width="672" /></p>
<pre class="r"><code>flights |&gt;
  group_by(year, month, day) |&gt;
  summarize(
    mean = mean(dep_delay, na.rm = TRUE),
    median = median(dep_delay, na.rm = TRUE),
    n = n(),
    .groups = &quot;drop&quot;
  )</code></pre>
<pre><code>## # A tibble: 365 × 6
##     year month   day  mean median     n
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;
##  1  2013     1     1 11.5      -1   842
##  2  2013     1     2 13.9       0   943
##  3  2013     1     3 11.0       0   914
##  4  2013     1     4  8.95     -1   915
##  5  2013     1     5  5.73     -1   720
##  6  2013     1     6  7.15     -1   832
##  7  2013     1     7  5.42     -2   933
##  8  2013     1     8  2.55     -2   899
##  9  2013     1     9  2.28     -4   902
## 10  2013     1    10  2.84     -4   932
## # ℹ 355 more rows</code></pre>
</div>
<div id="minimum-maximum-und-quantile" class="section level3"
number="11.6.2">
<h3><span class="header-section-number">11.6.2</span> Minimum, Maximum
und Quantile</h3>
<p><code>quantile(x, 0.25)</code>, <code>quantile(x, 0.5)</code>,
<code>quantile(x, 0.95)</code> sind selbsterklärend.</p>
<pre class="r"><code>flights |&gt;
  group_by(year, month, day) |&gt;
  summarize(
    max = max(dep_delay, na.rm = TRUE),
    q95 = quantile(dep_delay, 0.95, na.rm = TRUE),
    .groups = &quot;drop&quot;
  )</code></pre>
<pre><code>## # A tibble: 365 × 5
##     year month   day   max   q95
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  2013     1     1   853  70.1
##  2  2013     1     2   379  85  
##  3  2013     1     3   291  68  
##  4  2013     1     4   288  60  
##  5  2013     1     5   327  41  
##  6  2013     1     6   202  51  
##  7  2013     1     7   366  51.6
##  8  2013     1     8   188  35.3
##  9  2013     1     9  1301  27.2
## 10  2013     1    10  1126  31  
## # ℹ 355 more rows</code></pre>
</div>
<div id="streuung" class="section level3" number="11.6.3">
<h3><span class="header-section-number">11.6.3</span> Streuung</h3>
<p>Standardabweichung <code>sd(x)</code>, Interquartilsabstand
<code>IQR()</code>. IGQ ist das 75% - 25% Quantil.</p>
<pre class="r"><code>flights |&gt; 
  group_by(origin, dest) |&gt; 
  summarize(
    distance_sd = IQR(distance), 
    n = n(),
    .groups = &quot;drop&quot;
  ) |&gt; 
  filter(distance_sd &gt; 0)</code></pre>
<pre><code>## # A tibble: 2 × 4
##   origin dest  distance_sd     n
##   &lt;chr&gt;  &lt;chr&gt;       &lt;dbl&gt; &lt;int&gt;
## 1 EWR    EGE             1   110
## 2 JFK    EGE             1   103</code></pre>
</div>
<div id="verteilungen" class="section level3" number="11.6.4">
<h3><span class="header-section-number">11.6.4</span> Verteilungen</h3>
<p>Visualisiere die Verteilung bevor du zusammenfassende Statistiken
berechnest.</p>
<pre class="r"><code>flights |&gt;
  ggplot(aes(x = dep_delay)) + 
  geom_histogram(binwidth = 15)</code></pre>
<pre><code>## Warning: Removed 8255 rows containing non-finite values (`stat_bin()`).</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-292-1.png" width="672" /></p>
<pre class="r"><code>flights |&gt;
  filter(dep_delay &lt; 120) |&gt; 
  ggplot(aes(x = dep_delay)) + 
  geom_histogram(binwidth = 5)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-292-2.png" width="672" /></p>
<p>Checke, ob die Untergruppen die ganze Verteilung für alle
wiederspiegeln.</p>
<pre class="r"><code>flights |&gt;
  filter(dep_delay &lt; 120) |&gt; 
  ggplot(aes(x = dep_delay, group = interaction(day, month))) + 
  geom_freqpoly(binwidth = 5, alpha = 1/5)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-293-1.png" width="672" /></p>
</div>
<div id="positionen" class="section level3" number="11.6.5">
<h3><span class="header-section-number">11.6.5</span> Positionen</h3>
<p>Es gibt drei Funktionen, die man benutzen kann, um Werte zu
extrahieren, die an einer speziellen Position stehen:
<code>first(x)</code>, <code>last(x)</code>, <code>nth(x)</code>.</p>
<pre class="r"><code>flights |&gt; 
  group_by(year, month, day) |&gt; 
  summarize(
    first_dep = first(dep_time), 
    fifth_dep = nth(dep_time, 5),
    last_dep = last(dep_time)
  )</code></pre>
<p>Hier fehlt ein <code>na.rm = T</code>, daher benutze ich auf den
ganzen Datensatz ein <code>na.omit()</code>.</p>
<pre class="r"><code>flights |&gt; 
  na.omit() |&gt;
  group_by(year, month, day) |&gt; 
  summarize(
    last_dep = last(dep_time)
  ) </code></pre>
<pre><code>## `summarise()` has grouped output by &#39;year&#39;, &#39;month&#39;. You can override using the
## `.groups` argument.</code></pre>
<pre><code>## # A tibble: 365 × 4
## # Groups:   year, month [12]
##     year month   day last_dep
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;
##  1  2013     1     1     2356
##  2  2013     1     2     2354
##  3  2013     1     3     2349
##  4  2013     1     4     2358
##  5  2013     1     5     2357
##  6  2013     1     6     2355
##  7  2013     1     7     2359
##  8  2013     1     8     2351
##  9  2013     1     9     2252
## 10  2013     1    10     2320
## # ℹ 355 more rows</code></pre>
<p>Werte aus Positionen ziehen, ist komplementär zu Filtern auf Rängen.
Filtern gibt uns alle Variablen, mit jeder Beobachtung in einer eigenen
Reihe.</p>
<pre class="r"><code>flights |&gt; 
  group_by(year, month, day) |&gt; 
  mutate(r = min_rank(desc(sched_dep_time)), .keep = &quot;used&quot;) |&gt; 
  filter(r %in% c(1, max(r)))</code></pre>
<pre><code>## # A tibble: 1,195 × 5
## # Groups:   year, month, day [365]
##     year month   day sched_dep_time     r
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;          &lt;int&gt; &lt;int&gt;
##  1  2013     1     1            515   842
##  2  2013     1     1           2359     1
##  3  2013     1     1           2359     1
##  4  2013     1     1           2359     1
##  5  2013     1     2           2359     1
##  6  2013     1     2            500   943
##  7  2013     1     2           2359     1
##  8  2013     1     2           2359     1
##  9  2013     1     3           2359     1
## 10  2013     1     3           2359     1
## # ℹ 1,185 more rows</code></pre>
</div>
<div id="mit-mutate" class="section level3" number="11.6.6">
<h3><span class="header-section-number">11.6.6</span> Mit
<code>mutate()</code></h3>
<p><em>Summary Functions</em> werden normalerweise mit
<code>summarize()</code> gepaart. Aufgrund der* <em>recycling rules</em>
aber auch mit <code>mutate()</code>, besonders bei Standardisierung:</p>
<ul>
<li><code>x / sum(x)</code> - Anteil.</li>
<li><code>(x - mean(x)) / sd(x)</code> - Z-Score.</li>
<li><code>x / first(x)</code> - Index basierend auf erster
Beobachtung.</li>
</ul>
</div>
</div>
</div>
<div id="strings" class="section level1" number="12">
<h1><span class="header-section-number">12</span> Strings</h1>
<div id="einleitung-8" class="section level2" number="12.1">
<h2><span class="header-section-number">12.1</span> Einleitung</h2>
<p>Hier lernen wir etwas über
<em>String</em>-Manipulationswerkzeuge.</p>
<div id="voraussetzungen-7" class="section level3" number="12.1.1">
<h3><span class="header-section-number">12.1.1</span>
Voraussetzungen</h3>
<pre class="r"><code>library(babynames)</code></pre>
<pre><code>## Warning: Paket &#39;babynames&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<p>Das <strong>stringr</strong> Paket ist Teil des
<code>tidyverse</code>. Alle <code>stringr</code> Funktionen starten mit
<code>str_</code>.</p>
</div>
</div>
<div id="einen-string-kreieren" class="section level2" number="12.2">
<h2><span class="header-section-number">12.2</span> Einen String
kreieren</h2>
<pre class="r"><code>string1 &lt;- &quot;This is a string&quot;
string2 &lt;- &#39;If I want to include a &quot;quote&quot; inside a string, I use single quotes&#39;</code></pre>
<p>Vergisst du einen Ausdruck zu schließen, so erscheint ein
<code>+</code>.</p>
<div id="escapes" class="section level3" number="12.2.1">
<h3><span class="header-section-number">12.2.1</span> Escapes</h3>
<pre class="r"><code>double_quote &lt;- &quot;\&quot;&quot; # or &#39;&quot;&#39;
single_quote &lt;- &#39;\&#39;&#39; # or &quot;&#39;&quot;
backslash &lt;- &quot;\\&quot;</code></pre>
<pre class="r"><code>x &lt;- c(single_quote, double_quote, backslash)
x</code></pre>
<pre><code>## [1] &quot;&#39;&quot;  &quot;\&quot;&quot; &quot;\\&quot;</code></pre>
<pre class="r"><code>str_view(x)</code></pre>
<pre><code>## [1] │ &#39;
## [2] │ &quot;
## [3] │ \</code></pre>
</div>
<div id="rohe-strings" class="section level3" number="12.2.2">
<h3><span class="header-section-number">12.2.2</span> Rohe Strings</h3>
<pre class="r"><code>tricky &lt;- &quot;double_quote &lt;- \&quot;\\\&quot;\&quot; # or &#39;\&quot;&#39;
single_quote &lt;- &#39;\\&#39;&#39; # or \&quot;&#39;\&quot;&quot;
str_view(tricky)</code></pre>
<pre><code>## [1] │ double_quote &lt;- &quot;\&quot;&quot; # or &#39;&quot;&#39;
##     │ single_quote &lt;- &#39;\&#39;&#39; # or &quot;&#39;&quot;</code></pre>
<pre class="r"><code>#&gt; [1] │ double_quote &lt;- &quot;\&quot;&quot; # or &#39;&quot;&#39;
#&gt;     │ single_quote &lt;- &#39;\&#39;&#39; # or &quot;&#39;&quot;</code></pre>
<p>Zu viele Backslashs. Statt dessen, nutze einen <strong>raw
string</strong> durch <code>r"(</code> und beende mit
<code>)"</code>.</p>
<pre class="r"><code>tricky &lt;- r&quot;(double_quote &lt;- &quot;\&quot;&quot; # or &#39;&quot;&#39;
single_quote &lt;- &#39;\&#39;&#39; # or &quot;&#39;&quot;)&quot;
str_view(tricky)</code></pre>
<pre><code>## [1] │ double_quote &lt;- &quot;\&quot;&quot; # or &#39;&quot;&#39;
##     │ single_quote &lt;- &#39;\&#39;&#39; # or &quot;&#39;&quot;</code></pre>
<pre class="r"><code>#&gt; [1] │ double_quote &lt;- &quot;\&quot;&quot; # or &#39;&quot;&#39;
#&gt;     │ single_quote &lt;- &#39;\&#39;&#39; # or &quot;&#39;&quot;</code></pre>
</div>
<div id="weitere-spezielle-characters" class="section level3"
number="12.2.3">
<h3><span class="header-section-number">12.2.3</span> Weitere spezielle
Characters</h3>
<p><code>\n</code> - neue Zeile.<br />
<code>\t</code> - Tab. <code>\u</code> <code>\U</code> - nicht-englische
<em>Characters</em>.</p>
<pre class="r"><code>x &lt;- c(&quot;one\ntwo&quot;, &quot;one\ttwo&quot;, &quot;\u00b5&quot;, &quot;\U0001f604&quot;)
x</code></pre>
<pre><code>## [1] &quot;one\ntwo&quot; &quot;one\ttwo&quot; &quot;µ&quot;        &quot;😄&quot;</code></pre>
<pre class="r"><code>#&gt; [1] &quot;one\ntwo&quot; &quot;one\ttwo&quot; &quot;µ&quot;        &quot;😄&quot;
str_view(x)</code></pre>
<pre><code>## [1] │ one
##     │ two
## [2] │ one{\t}two
## [3] │ µ
## [4] │ 😄</code></pre>
<pre class="r"><code>#&gt; [1] │ one
#&gt;     │ two
#&gt; [2] │ one{\t}two
#&gt; [3] │ µ
#&gt; [4] │ 😄</code></pre>
</div>
</div>
<div id="viele-strings-kreieren" class="section level2" number="12.3">
<h2><span class="header-section-number">12.3</span> Viele Strings
kreieren</h2>
<div id="str_c" class="section level3" number="12.3.1">
<h3><span class="header-section-number">12.3.1</span>
<code>str_c()</code></h3>
<p>Nimmt Vektoren an und gibt einen <em>Character Vector</em> aus.</p>
<pre class="r"><code>str_c(&quot;x&quot;, &quot;y&quot;)</code></pre>
<pre><code>## [1] &quot;xy&quot;</code></pre>
<pre class="r"><code>str_c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)</code></pre>
<pre><code>## [1] &quot;xyz&quot;</code></pre>
<pre class="r"><code>str_c(&quot;Hello &quot;, c(&quot;John&quot;, &quot;Susan&quot;))</code></pre>
<pre><code>## [1] &quot;Hello John&quot;  &quot;Hello Susan&quot;</code></pre>
<pre class="r"><code>str_c(c(&quot;Hallo &quot;, &quot;Servus &quot;), c(&quot;Andi &quot;, &quot;Andrea &quot;), c(&quot;Ciao&quot;, &quot;Servus&quot;), c(&quot; Adios&quot;, &quot; Cheers&quot;))</code></pre>
<pre><code>## [1] &quot;Hallo Andi Ciao Adios&quot;       &quot;Servus Andrea Servus Cheers&quot;</code></pre>
<p><code>str_c()</code> ist designt, um mit <code>mutate()</code>
genutzt werden und gehorcht so den gewöhnlichen Regeln für
<em>recycling</em> und <em>Missing Values</em>.</p>
<pre class="r"><code>set.seed(1410)
df &lt;- tibble(name = c(wakefield::name(3), NA))
df |&gt; mutate(greeting = str_c(&quot;Hi &quot;, name, &quot;!&quot;))</code></pre>
<pre><code>## # A tibble: 4 × 2
##   name       greeting      
##   &lt;chr&gt;      &lt;chr&gt;         
## 1 Ilena      Hi Ilena!     
## 2 Sacramento Hi Sacramento!
## 3 Graylon    Hi Graylon!   
## 4 &lt;NA&gt;       &lt;NA&gt;</code></pre>
<p>Benutze <code>coalesce()</code>, um statt <em>Missing Values</em>
Alternativen ausgeben zu lassen.</p>
<pre class="r"><code>df |&gt; 
  mutate(
    greeting1 = str_c(&quot;Hi &quot;, coalesce(name, &quot;you&quot;), &quot;!&quot;),
    greeting2 = coalesce(str_c(&quot;Hi &quot;, name, &quot;!&quot;), &quot;Hi!&quot;)
  )</code></pre>
<pre><code>## # A tibble: 4 × 3
##   name       greeting1      greeting2     
##   &lt;chr&gt;      &lt;chr&gt;          &lt;chr&gt;         
## 1 Ilena      Hi Ilena!      Hi Ilena!     
## 2 Sacramento Hi Sacramento! Hi Sacramento!
## 3 Graylon    Hi Graylon!    Hi Graylon!   
## 4 &lt;NA&gt;       Hi you!        Hi!</code></pre>
</div>
<div id="str_glue" class="section level3" number="12.3.2">
<h3><span class="header-section-number">12.3.2</span>
<code>str_glue()</code></h3>
<p>Viele Gänsefüßchen mussten wir verwenden. Dies ist vermeidbar, wenn
wir <code>str_glue()</code> aus dem <strong>glue</strong> Paket
benutzen. Alles innerhalb <code>{}</code> wird bewertet, als wäre es
außerhalb der Anführungszeichen.</p>
<pre class="r"><code>df |&gt; mutate(greeting = str_glue(&quot;Hi {name}!&quot;))</code></pre>
<pre><code>## # A tibble: 4 × 2
##   name       greeting      
##   &lt;chr&gt;      &lt;glue&gt;        
## 1 Ilena      Hi Ilena!     
## 2 Sacramento Hi Sacramento!
## 3 Graylon    Hi Graylon!   
## 4 &lt;NA&gt;       Hi NA!</code></pre>
<p><code>str_glue()</code> konvertiert <em>Missing Values</em> zu
<code>"NA"</code>. Jetzt ist es inkonsistent zu <code>str_c()</code>.
Wenn du <code>{</code> oder <code>}</code> einfühgen willst, nutze
<code>{{</code> bzw. <code>}}</code>.</p>
<pre class="r"><code>df |&gt; mutate(greeting = str_glue(&quot;{{Hi {name}!}}&quot;))</code></pre>
<pre><code>## # A tibble: 4 × 2
##   name       greeting        
##   &lt;chr&gt;      &lt;glue&gt;          
## 1 Ilena      {Hi Ilena!}     
## 2 Sacramento {Hi Sacramento!}
## 3 Graylon    {Hi Graylon!}   
## 4 &lt;NA&gt;       {Hi NA!}</code></pre>
</div>
<div id="str_flatten" class="section level3" number="12.3.3">
<h3><span class="header-section-number">12.3.3</span>
<code>str_flatten()</code></h3>
<p><code>str_c()</code> und <code>glue()</code> funktionieren gut mit
<code>mutate()</code>, weil ihr Output dieselbe Länge wie Input hat. Was
aber, wenn du nur einen einzelnen <em>String</em> ausgegeben haben
willst. <code>str_flatten()</code> nimmt einen <em>Character</em> Vektor
und kombiniert jedes Element des Vektors in einen <em>single
String</em>:</p>
<pre class="r"><code>detach(&quot;package:tidyverse&quot;, unload = TRUE)
library(tidytable)</code></pre>
<pre><code>## Warning: Paket &#39;tidytable&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## Warning: tidytable was loaded after dplyr.
## This can lead to most dplyr functions being overwritten by tidytable functions.</code></pre>
<pre><code>## Warning: tidytable was loaded after tidyr.
## This can lead to most tidyr functions being overwritten by tidytable functions.</code></pre>
<pre><code>## 
## Attache Paket: &#39;tidytable&#39;</code></pre>
<pre><code>## Die folgenden Objekte sind maskiert von &#39;package:dplyr&#39;:
## 
##     across, add_count, add_tally, anti_join, arrange, between,
##     bind_cols, bind_rows, c_across, case_match, case_when, coalesce,
##     consecutive_id, count, cross_join, cume_dist, cur_column, cur_data,
##     cur_group_id, cur_group_rows, dense_rank, desc, distinct, filter,
##     first, full_join, group_by, group_cols, group_split, group_vars,
##     if_all, if_any, if_else, inner_join, is_grouped_df, lag, last,
##     lead, left_join, min_rank, mutate, n, n_distinct, na_if, nest_by,
##     nest_join, nth, percent_rank, pick, pull, recode, reframe,
##     relocate, rename, rename_with, right_join, row_number, rowwise,
##     select, semi_join, slice, slice_head, slice_max, slice_min,
##     slice_sample, slice_tail, summarise, summarize, tally, top_n,
##     transmute, tribble, ungroup</code></pre>
<pre><code>## Die folgenden Objekte sind maskiert von &#39;package:purrr&#39;:
## 
##     map, map_chr, map_dbl, map_df, map_dfc, map_dfr, map_int, map_lgl,
##     map_vec, map2, map2_chr, map2_dbl, map2_df, map2_dfc, map2_dfr,
##     map2_int, map2_lgl, map2_vec, pmap, pmap_chr, pmap_dbl, pmap_df,
##     pmap_dfc, pmap_dfr, pmap_int, pmap_lgl, pmap_vec, walk</code></pre>
<pre><code>## Die folgenden Objekte sind maskiert von &#39;package:tidyr&#39;:
## 
##     complete, crossing, drop_na, expand, expand_grid, extract, fill,
##     nest, nesting, pivot_longer, pivot_wider, replace_na, separate,
##     separate_longer_delim, separate_rows, separate_wider_delim,
##     separate_wider_regex, tribble, uncount, unite, unnest,
##     unnest_longer, unnest_wider</code></pre>
<pre><code>## Die folgenden Objekte sind maskiert von &#39;package:tibble&#39;:
## 
##     enframe, tribble</code></pre>
<pre><code>## Die folgenden Objekte sind maskiert von &#39;package:stats&#39;:
## 
##     dt, filter, lag</code></pre>
<pre><code>## Das folgende Objekt ist maskiert &#39;package:base&#39;:
## 
##     %in%</code></pre>
<pre class="r"><code>str_flatten(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;))</code></pre>
<pre><code>## [1] &quot;xyz&quot;</code></pre>
<pre class="r"><code>str_flatten(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), &quot;, &quot;)</code></pre>
<pre><code>## [1] &quot;x, y, z&quot;</code></pre>
<pre class="r"><code># str_flatten(c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;), &quot;, &quot;, last = &quot;, and &quot;)</code></pre>
<p>Dadurch lässt es sich gut mit <code>summarize()</code> arbeiten:</p>
<pre class="r"><code>df &lt;- tribble(
  ~ name, ~ fruit,
  &quot;Carmen&quot;, &quot;banana&quot;,
  &quot;Carmen&quot;, &quot;apple&quot;,
  &quot;Marvin&quot;, &quot;nectarine&quot;,
  &quot;Terence&quot;, &quot;cantaloupe&quot;,
  &quot;Terence&quot;, &quot;papaya&quot;,
  &quot;Terence&quot;, &quot;madarine&quot;
)
df |&gt;
  group_by(name) |&gt; 
  summarize(fruits = str_flatten(fruit, &quot;, &quot;))</code></pre>
<pre><code>## # A tidytable: 3 × 2
##   name    fruits                      
##   &lt;chr&gt;   &lt;chr&gt;                       
## 1 Carmen  banana, apple               
## 2 Marvin  nectarine                   
## 3 Terence cantaloupe, papaya, madarine</code></pre>
</div>
</div>
<div id="daten-aus-strings-ziehen" class="section level2" number="12.4">
<h2><span class="header-section-number">12.4</span> Daten aus Strings
ziehen</h2>
<ul>
<li><code>df |&gt;</code>
<code>separate_longer_delim(col, delim)</code></li>
<li><code>df |&gt;</code>
<code>separate_longer_position(col, width)</code></li>
<li><code>df |&gt;</code>
<code>separate_wider_delim(col, delim, names)</code></li>
<li><code>df |&gt;</code>
<code>separate_wider_position(col, widths)</code></li>
</ul>
<div id="separieren-in-reihen" class="section level3" number="12.4.1">
<h3><span class="header-section-number">12.4.1</span> Separieren in
Reihen</h3>
<pre class="r"><code>df1 &lt;- tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f&quot;))
df1 |&gt; 
  separate_longer_delim(x, delim = &quot;,&quot;)</code></pre>
<pre><code>## # A tidytable: 6 × 1
##   x    
##   &lt;chr&gt;
## 1 a    
## 2 b    
## 3 c    
## 4 d    
## 5 e    
## 6 f</code></pre>
<pre class="r"><code>#&gt; # A tibble: 6 × 1
#&gt;   x    
#&gt;   &lt;chr&gt;
#&gt; 1 a    
#&gt; 2 b    
#&gt; 3 c    
#&gt; 4 d    
#&gt; 5 e    
#&gt; 6 f</code></pre>
<pre class="r"><code>df2 &lt;- tibble(x = c(&quot;1211&quot;, &quot;131&quot;, &quot;21&quot;))
df2 |&gt; 
  separate_longer_position(x, width = 1)</code></pre>
<pre><code>## # A tibble: 9 × 1
##   x    
##   &lt;chr&gt;
## 1 1    
## 2 2    
## 3 1    
## 4 1    
## 5 1    
## 6 3    
## 7 1    
## 8 2    
## 9 1</code></pre>
<pre class="r"><code>#&gt; # A tibble: 9 × 1
#&gt;   x    
#&gt;   &lt;chr&gt;
#&gt; 1 1    
#&gt; 2 2    
#&gt; 3 1    
#&gt; 4 1    
#&gt; 5 1    
#&gt; 6 3    
#&gt; # … with 3 more rows</code></pre>
</div>
<div id="separieren-in-spalten" class="section level3" number="12.4.2">
<h3><span class="header-section-number">12.4.2</span> Separieren in
Spalten</h3>
<pre class="r"><code>df3 &lt;- tibble(x = c(&quot;a10.1.2022&quot;, &quot;b10.2.2011&quot;, &quot;e15.1.2015&quot;))
df3 |&gt; 
  separate_wider_delim(
    x,
    delim = &quot;.&quot;,
    names = c(&quot;code&quot;, &quot;edition&quot;, &quot;year&quot;)
  )</code></pre>
<pre><code>## # A tidytable: 3 × 3
##   code  edition year 
##   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;
## 1 a10   1       2022 
## 2 b10   2       2011 
## 3 e15   1       2015</code></pre>
<pre class="r"><code>#&gt; # A tibble: 3 × 3
#&gt;   code  edition year 
#&gt;   &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;
#&gt; 1 a10   1       2022 
#&gt; 2 b10   2       2011 
#&gt; 3 e15   1       2015</code></pre>
<pre class="r"><code>df3 |&gt; 
  separate_wider_delim(
    x,
    delim = &quot;.&quot;,
    names = c(&quot;code&quot;, NA, &quot;year&quot;)
  )</code></pre>
<pre><code>## # A tidytable: 3 × 2
##   code  year 
##   &lt;chr&gt; &lt;chr&gt;
## 1 a10   2022 
## 2 b10   2011 
## 3 e15   2015</code></pre>
<pre class="r"><code>#&gt; # A tibble: 3 × 2
#&gt;   code  year 
#&gt;   &lt;chr&gt; &lt;chr&gt;
#&gt; 1 a10   2022 
#&gt; 2 b10   2011 
#&gt; 3 e15   2015</code></pre>
<pre class="r"><code>df4 &lt;- tibble(x = c(&quot;202215TX&quot;, &quot;202122LA&quot;, &quot;202325CA&quot;)) 
df4 |&gt; 
  separate_wider_position(
    x,
    widths = c(year = 4, age = 2, state = 2)
  )</code></pre>
<pre><code>## # A tibble: 3 × 3
##   year  age   state
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 2022  15    TX   
## 2 2021  22    LA   
## 3 2023  25    CA</code></pre>
<pre class="r"><code>#&gt; # A tibble: 3 × 3
#&gt;   year  age   state
#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
#&gt; 1 2022  15    TX   
#&gt; 2 2021  22    LA   
#&gt; 3 2023  25    CA</code></pre>
</div>
<div id="separate_wider_delim" class="section level3" number="12.4.3">
<h3><span class="header-section-number">12.4.3</span>
<code>separate_wider_delim()</code></h3>
<pre class="r"><code>df &lt;- tibble(x = c(&quot;1-1-1&quot;, &quot;1-1-2&quot;, &quot;1-3&quot;, &quot;1-3-2&quot;, &quot;1&quot;))

df |&gt; 
  separate_wider_delim(
    x,
    delim = &quot;-&quot;,
    names = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
  )</code></pre>
<pre><code>## # A tidytable: 5 × 3
##   x     y     z    
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 1     1     1    
## 2 1     1     2    
## 3 1     3     &lt;NA&gt; 
## 4 1     3     2    
## 5 1     &lt;NA&gt;  &lt;NA&gt;</code></pre>
<pre class="r"><code>df &lt;- tibble(x = c(&quot;1-1-1&quot;, &quot;1-1-2&quot;, &quot;1-3-5-6&quot;, &quot;1-3-2&quot;, &quot;1-3-5-7-9&quot;))

df |&gt; 
  separate_wider_delim(
    x,
    delim = &quot;-&quot;,
    names = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;)
  )</code></pre>
<pre><code>## # A tidytable: 5 × 3
##   x     y     z    
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 1     1     1    
## 2 1     1     2    
## 3 1     3     5    
## 4 1     3     2    
## 5 1     3     5</code></pre>
<pre class="r"><code>detach(&quot;package:tidytable&quot;, unload = TRUE)
library(tidyverse)</code></pre>
<pre><code>## Warning: Paket &#39;tidyverse&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre><code>## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
## ✖ scales::col_factor() masks readr::col_factor()
## ✖ scales::discard()    masks purrr::discard()
## ✖ arrow::duration()    masks lubridate::duration()
## ✖ dplyr::filter()      masks stats::filter()
## ✖ recipes::fixed()     masks stringr::fixed()
## ✖ dplyr::lag()         masks stats::lag()
## ✖ yardstick::spec()    masks readr::spec()
## ℹ Use the conflicted package (&lt;http://conflicted.r-lib.org/&gt;) to force all conflicts to become errors</code></pre>
<pre class="r"><code>df</code></pre>
<pre><code>## # A tibble: 5 × 1
##   x        
##   &lt;chr&gt;    
## 1 1-1-1    
## 2 1-1-2    
## 3 1-3-5-6  
## 4 1-3-2    
## 5 1-3-5-7-9</code></pre>
<pre class="r"><code>df |&gt; 
  separate_wider_delim(
    x,
    delim = &quot;-&quot;,
    names = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;),
    too_many = &quot;drop&quot;
  )</code></pre>
<pre><code>## # A tibble: 5 × 3
##   x     y     z    
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 1     1     1    
## 2 1     1     2    
## 3 1     3     5    
## 4 1     3     2    
## 5 1     3     5</code></pre>
<pre class="r"><code>df |&gt; 
  separate_wider_delim(
    x,
    delim = &quot;-&quot;,
    names = c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;),
    too_many = &quot;merge&quot;
  )</code></pre>
<pre><code>## # A tibble: 5 × 3
##   x     y     z    
##   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1 1     1     1    
## 2 1     1     2    
## 3 1     3     5-6  
## 4 1     3     2    
## 5 1     3     5-7-9</code></pre>
</div>
</div>
<div id="buchstaben" class="section level2" number="12.5">
<h2><span class="header-section-number">12.5</span> Buchstaben</h2>
<p>In diesem Abschnitt stellen wir Funktionen vor, die es uns erlauben
die Buchstaben innerhalb eines <em>Strings</em> zu bearbeiten.</p>
<div id="länge" class="section level3" number="12.5.1">
<h3><span class="header-section-number">12.5.1</span> Länge</h3>
<p><code>str_length()</code> gibt die Anzahl der Buchstaben eines
<em>Strings</em> aus.</p>
<pre class="r"><code>str_length(c(&quot;a&quot;, &quot;R for data science&quot;, NA))</code></pre>
<pre><code>## [1]  1 18 NA</code></pre>
<p>Du kannst die <code>count()</code> Funktion nutzen, um die Anzahl der
Buchstaben von Babynamen zu bestimmen.</p>
<pre class="r"><code>library(babynames)
babynames |&gt;
  count(length = str_length(name), wt = n)</code></pre>
<pre><code>## # A tibble: 14 × 2
##    length        n
##     &lt;int&gt;    &lt;int&gt;
##  1      2   338150
##  2      3  8589596
##  3      4 48506739
##  4      5 87011607
##  5      6 90749404
##  6      7 72120767
##  7      8 25404066
##  8      9 11926551
##  9     10  1306159
## 10     11  2135827
## 11     12    16295
## 12     13    10845
## 13     14     3681
## 14     15      830</code></pre>
<pre class="r"><code>babynames |&gt; 
  filter(str_length(name) == 15) |&gt; 
  count(name, wt = n, sort = TRUE)</code></pre>
<pre><code>## # A tibble: 34 × 2
##    name                n
##    &lt;chr&gt;           &lt;int&gt;
##  1 Franciscojavier   123
##  2 Christopherjohn   118
##  3 Johnchristopher   118
##  4 Christopherjame   108
##  5 Christophermich    52
##  6 Ryanchristopher    45
##  7 Mariadelosangel    28
##  8 Jonathanmichael    25
##  9 Christianjoseph    22
## 10 Christopherjose    22
## # ℹ 24 more rows</code></pre>
</div>
<div id="subsetting" class="section level3" number="12.5.2">
<h3><span class="header-section-number">12.5.2</span> Subsetting</h3>
<p>Sage bitte, wie die ersten drei Buchstaben eines <em>Substrings</em>
lauten (<code>str_sub(string, start, end)</code>).</p>
<pre class="r"><code>x &lt;- c(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;)
str_sub(x, 1, 3)</code></pre>
<pre><code>## [1] &quot;App&quot; &quot;Ban&quot; &quot;Pea&quot;</code></pre>
<p>Negative Zahlen kannst du benutzen, um vom Ende zurück zu zählen.</p>
<pre class="r"><code>str_sub(x, -3, -1)</code></pre>
<pre><code>## [1] &quot;ple&quot; &quot;ana&quot; &quot;ear&quot;</code></pre>
<p>Wir können <code>str_sub()</code> mit <code>mutate()</code> benutzen,
um den ersten und letzten Buchstaben eines jeden Namens zu finden.</p>
<pre class="r"><code>babynames |&gt; 
  mutate(
    first = str_sub(name, 1, 1),
    last = str_sub(name, -1, -1)
  )</code></pre>
<pre><code>## # A tibble: 1,924,665 × 7
##     year sex   name          n   prop first last 
##    &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;     &lt;int&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;
##  1  1880 F     Mary       7065 0.0724 M     y    
##  2  1880 F     Anna       2604 0.0267 A     a    
##  3  1880 F     Emma       2003 0.0205 E     a    
##  4  1880 F     Elizabeth  1939 0.0199 E     h    
##  5  1880 F     Minnie     1746 0.0179 M     e    
##  6  1880 F     Margaret   1578 0.0162 M     t    
##  7  1880 F     Ida        1472 0.0151 I     a    
##  8  1880 F     Alice      1414 0.0145 A     e    
##  9  1880 F     Bertha     1320 0.0135 B     a    
## 10  1880 F     Sarah      1288 0.0132 S     h    
## # ℹ 1,924,655 more rows</code></pre>
</div>
<div id="lange-strings" class="section level3" number="12.5.3">
<h3><span class="header-section-number">12.5.3</span> Lange Strings</h3>
<p><code>str_trunc(x, 30)</code>: kein <em>String</em> hat mehr Zeichen,
als 30. Alles dahinter wird durch <code>...</code> ersetzt.<br />
<code>str_wrap(x, 30)</code> gibt einem <em>String</em>, der “zu lang”
ist, eine neue Zeile.</p>
<pre class="r"><code>x &lt;- &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.&quot;

str_view(str_trunc(x, 30), &quot;[aeiou]&quot;)</code></pre>
<pre><code>## [1] │ L&lt;o&gt;r&lt;e&gt;m &lt;i&gt;ps&lt;u&gt;m d&lt;o&gt;l&lt;o&gt;r s&lt;i&gt;t &lt;a&gt;m&lt;e&gt;t,...</code></pre>
<pre class="r"><code>str_view(str_wrap(x, 30), &quot;[aeiou]&quot;)</code></pre>
<pre><code>## [1] │ L&lt;o&gt;r&lt;e&gt;m &lt;i&gt;ps&lt;u&gt;m d&lt;o&gt;l&lt;o&gt;r s&lt;i&gt;t &lt;a&gt;m&lt;e&gt;t,
##     │ c&lt;o&gt;ns&lt;e&gt;ct&lt;e&gt;t&lt;u&gt;r &lt;a&gt;d&lt;i&gt;p&lt;i&gt;sc&lt;i&gt;ng
##     │ &lt;e&gt;l&lt;i&gt;t, s&lt;e&gt;d d&lt;o&gt; &lt;e&gt;&lt;i&gt;&lt;u&gt;sm&lt;o&gt;d t&lt;e&gt;mp&lt;o&gt;r
##     │ &lt;i&gt;nc&lt;i&gt;d&lt;i&gt;d&lt;u&gt;nt &lt;u&gt;t l&lt;a&gt;b&lt;o&gt;r&lt;e&gt; &lt;e&gt;t d&lt;o&gt;l&lt;o&gt;r&lt;e&gt;
##     │ m&lt;a&gt;gn&lt;a&gt; &lt;a&gt;l&lt;i&gt;q&lt;u&gt;&lt;a&gt;. Ut &lt;e&gt;n&lt;i&gt;m &lt;a&gt;d
##     │ m&lt;i&gt;n&lt;i&gt;m v&lt;e&gt;n&lt;i&gt;&lt;a&gt;m, q&lt;u&gt;&lt;i&gt;s n&lt;o&gt;str&lt;u&gt;d
##     │ &lt;e&gt;x&lt;e&gt;rc&lt;i&gt;t&lt;a&gt;t&lt;i&gt;&lt;o&gt;n &lt;u&gt;ll&lt;a&gt;mc&lt;o&gt; l&lt;a&gt;b&lt;o&gt;r&lt;i&gt;s
##     │ n&lt;i&gt;s&lt;i&gt; &lt;u&gt;t &lt;a&gt;l&lt;i&gt;q&lt;u&gt;&lt;i&gt;p &lt;e&gt;x &lt;e&gt;&lt;a&gt; c&lt;o&gt;mm&lt;o&gt;d&lt;o&gt;
##     │ c&lt;o&gt;ns&lt;e&gt;q&lt;u&gt;&lt;a&gt;t.</code></pre>
</div>
</div>
</div>
<div id="reguläre-ausdrücke" class="section level1" number="13">
<h1><span class="header-section-number">13</span> Reguläre
Ausdrücke</h1>
<div id="einleitung-9" class="section level2" number="13.1">
<h2><span class="header-section-number">13.1</span> Einleitung</h2>
<p>In diesem Kapitel konzentrieren wir uns auf Funktionen, die
<strong>Regular Expressions</strong> benutzen. Eine mächtige Sprache, um
Muster innerhalb von <em>Strings</em> zu beschreiben.</p>
<div id="voraussetzungen-8" class="section level3" number="13.1.1">
<h3><span class="header-section-number">13.1.1</span>
Voraussetzungen</h3>
<pre class="r"><code>library(tidyverse)
library(babynames)</code></pre>
</div>
</div>
<div id="muster-basics" class="section level2" number="13.2">
<h2><span class="header-section-number">13.2</span> Muster: Basics</h2>
<p>Das zweite Argument wird optisch in der Ausgabe hervorgehoben. Hier
also z.B. blackberry durch blau und &lt;…&gt;.</p>
<pre class="r"><code>str_view(fruit, &quot;berry&quot;)</code></pre>
<pre><code>##  [6] │ bil&lt;berry&gt;
##  [7] │ black&lt;berry&gt;
## [10] │ blue&lt;berry&gt;
## [11] │ boysen&lt;berry&gt;
## [19] │ cloud&lt;berry&gt;
## [21] │ cran&lt;berry&gt;
## [29] │ elder&lt;berry&gt;
## [32] │ goji &lt;berry&gt;
## [33] │ goose&lt;berry&gt;
## [38] │ huckle&lt;berry&gt;
## [50] │ mul&lt;berry&gt;
## [70] │ rasp&lt;berry&gt;
## [73] │ salal &lt;berry&gt;
## [76] │ straw&lt;berry&gt;</code></pre>
<pre class="r"><code>#&gt;  [6] │ bil&lt;berry&gt;
#&gt;  [7] │ black&lt;berry&gt;
#&gt; [10] │ blue&lt;berry&gt;
#&gt; [11] │ boysen&lt;berry&gt;
#&gt; [19] │ cloud&lt;berry&gt;
#&gt; [21] │ cran&lt;berry&gt;
#&gt; [29] │ elder&lt;berry&gt;
#&gt; [32] │ goji &lt;berry&gt;
#&gt; [33] │ goose&lt;berry&gt;
#&gt; [38] │ huckle&lt;berry&gt;
#&gt; ... and 4 more</code></pre>
<p><code>a.</code> matcht jeden <em>String</em>, der ein “a” enthält,
gefolgt von weiterem <em>Character</em>.</p>
<pre class="r"><code>str_view(c(&quot;a&quot;, &quot;ab&quot;, &quot;ae&quot;, &quot;bd&quot;, &quot;ea&quot;, &quot;eab&quot;), &quot;a.&quot;)</code></pre>
<pre><code>## [2] │ &lt;ab&gt;
## [3] │ &lt;ae&gt;
## [6] │ e&lt;ab&gt;</code></pre>
<pre class="r"><code>#&gt; [2] │ &lt;ab&gt;
#&gt; [3] │ &lt;ae&gt;
#&gt; [6] │ e&lt;ab&gt;</code></pre>
<p>Wir können alle Früchte finden, die ein “a” enthalten, gefolgt von
drei Buchstaben, gefolgt von einem “e”.</p>
<pre class="r"><code>str_view(fruit, &quot;a...e&quot;)</code></pre>
<pre><code>##  [1] │ &lt;apple&gt;
##  [7] │ bl&lt;ackbe&gt;rry
## [48] │ mand&lt;arine&gt;
## [51] │ nect&lt;arine&gt;
## [62] │ pine&lt;apple&gt;
## [64] │ pomegr&lt;anate&gt;
## [70] │ r&lt;aspbe&gt;rry
## [73] │ sal&lt;al be&gt;rry</code></pre>
<pre class="r"><code>#&gt;  [1] │ &lt;apple&gt;
#&gt;  [7] │ bl&lt;ackbe&gt;rry
#&gt; [48] │ mand&lt;arine&gt;
#&gt; [51] │ nect&lt;arine&gt;
#&gt; [62] │ pine&lt;apple&gt;
#&gt; [64] │ pomegr&lt;anate&gt;
#&gt; [70] │ r&lt;aspbe&gt;rry
#&gt; [73] │ sal&lt;al be&gt;rry</code></pre>
<p><strong>Quantifiers</strong> kontrollieren wie oft ein Muster
zutrifft.</p>
<ul>
<li><code>?</code>: Muster optional - trifft 0 oder 1 mal zu</li>
<li><code>+</code>: Muster wiederholt sich - es trifft mind. einmal
zu</li>
<li><code>*</code>: Muster optional oder wiederholt sich</li>
</ul>
<pre class="r"><code># ab? matches an &quot;a&quot;, optionally followed by a &quot;b&quot;.
str_view(c(&quot;a&quot;, &quot;ab&quot;, &quot;abb&quot;), &quot;ab?&quot;)</code></pre>
<pre><code>## [1] │ &lt;a&gt;
## [2] │ &lt;ab&gt;
## [3] │ &lt;ab&gt;b</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;a&gt;
#&gt; [2] │ &lt;ab&gt;
#&gt; [3] │ &lt;ab&gt;b

# ab+ matches an &quot;a&quot;, followed by at least one &quot;b&quot;.
str_view(c(&quot;a&quot;, &quot;ab&quot;, &quot;abb&quot;), &quot;ab+&quot;)</code></pre>
<pre><code>## [2] │ &lt;ab&gt;
## [3] │ &lt;abb&gt;</code></pre>
<pre class="r"><code>#&gt; [2] │ &lt;ab&gt;
#&gt; [3] │ &lt;abb&gt;

# ab* matches an &quot;a&quot;, followed by any number of &quot;b&quot;s.
str_view(c(&quot;a&quot;, &quot;ab&quot;, &quot;abb&quot;), &quot;ab*&quot;)</code></pre>
<pre><code>## [1] │ &lt;a&gt;
## [2] │ &lt;ab&gt;
## [3] │ &lt;abb&gt;</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;a&gt;
#&gt; [2] │ &lt;ab&gt;
#&gt; [3] │ &lt;abb&gt;</code></pre>
<p><strong>Character classes</strong> sind durch <code>[]</code>
definiert. Buchstaben darin enthalten matchen: <code>[abcd]</code> -
“a”, “b”, “c”, “d”. Alles außer “a”, “b”, “c”, “d” matcht:
<code>[^abcd]</code>. Finde Wörter mit 3 Vokalen bzw. 4 Konsonanten
hintereinander.</p>
<pre class="r"><code>str_view(words, &quot;[aeiou][aeiou][aeiou]&quot;)</code></pre>
<pre><code>##  [79] │ b&lt;eau&gt;ty
## [565] │ obv&lt;iou&gt;s
## [644] │ prev&lt;iou&gt;s
## [670] │ q&lt;uie&gt;t
## [741] │ ser&lt;iou&gt;s
## [915] │ var&lt;iou&gt;s</code></pre>
<pre class="r"><code>#&gt;  [79] │ b&lt;eau&gt;ty
#&gt; [565] │ obv&lt;iou&gt;s
#&gt; [644] │ prev&lt;iou&gt;s
#&gt; [670] │ q&lt;uie&gt;t
#&gt; [741] │ ser&lt;iou&gt;s
#&gt; [915] │ var&lt;iou&gt;s
str_view(words, &quot;[^aeiou][^aeiou][^aeiou][^aeiou]&quot;)</code></pre>
<pre><code>##  [45] │ a&lt;pply&gt;
## [198] │ cou&lt;ntry&gt;
## [424] │ indu&lt;stry&gt;
## [830] │ su&lt;pply&gt;
## [836] │ &lt;syst&gt;em</code></pre>
<pre class="r"><code>#&gt;  [45] │ a&lt;pply&gt;
#&gt; [198] │ cou&lt;ntry&gt;
#&gt; [424] │ indu&lt;stry&gt;
#&gt; [830] │ su&lt;pply&gt;
#&gt; [836] │ &lt;syst&gt;em</code></pre>
<p>Zwei Vokale gefolgt von mind. zwei Konsonanten:</p>
<pre class="r"><code>str_view(words, &quot;[aeiou][aeiou][^aeiou][^aeiou]+&quot;)</code></pre>
<pre><code>##   [6] │ acc&lt;ount&gt;
##  [21] │ ag&lt;ainst&gt;
##  [31] │ alr&lt;eady&gt;
##  [34] │ alth&lt;ough&gt;
##  [37] │ am&lt;ount&gt;
##  [46] │ app&lt;oint&gt;
##  [47] │ appr&lt;oach&gt;
##  [52] │ ar&lt;ound&gt;
##  [61] │ &lt;auth&gt;ority
##  [79] │ be&lt;auty&gt;
## [100] │ b&lt;oard&gt;
## [112] │ brill&lt;iant&gt;
## [117] │ b&lt;uild&gt;
## [139] │ ch&lt;airm&gt;an
## [158] │ cl&lt;ient&gt;
## [195] │ c&lt;ould&gt;
## [196] │ c&lt;ounc&gt;il
## [197] │ c&lt;ount&gt;
## [198] │ c&lt;ountry&gt;
## [199] │ c&lt;ounty&gt;
## ... and 52 more</code></pre>
<pre class="r"><code>#&gt;  [6] │ acc&lt;ount&gt;
#&gt; [21] │ ag&lt;ainst&gt;
#&gt; [31] │ alr&lt;eady&gt;
#&gt; [34] │ alth&lt;ough&gt;
#&gt; [37] │ am&lt;ount&gt;
#&gt; [46] │ app&lt;oint&gt;
#&gt; [47] │ appr&lt;oach&gt;
#&gt; [52] │ ar&lt;ound&gt;
#&gt; [61] │ &lt;auth&gt;ority
#&gt; [79] │ be&lt;auty&gt;
#&gt; ... and 62 more</code></pre>
<p><strong>Alternation</strong>, <code>|</code> sucht zwischen Mustern.
“apple”, “pear”, “banana”. Oder ein wiederholter Vokal.</p>
<pre class="r"><code>str_view(fruit, &quot;apple|pear|banana&quot;)
#&gt;  [1] │ &lt;apple&gt;
#&gt;  [4] │ &lt;banana&gt;
#&gt; [59] │ &lt;pear&gt;
#&gt; [62] │ pine&lt;apple&gt;
str_view(fruit, &quot;aa|ee|ii|oo|uu&quot;)
#&gt;  [9] │ bl&lt;oo&gt;d orange
#&gt; [33] │ g&lt;oo&gt;seberry
#&gt; [47] │ lych&lt;ee&gt;
#&gt; [66] │ purple mangost&lt;ee&gt;n</code></pre>
</div>
<div id="key-funktionen" class="section level2" number="13.3">
<h2><span class="header-section-number">13.3</span> Key Funktionen</h2>
<p>Da die Basics sitzen, benutzen wir sie zusammen mit
<code>stringr</code> und <code>tidyr</code> Funktionen: <em>detect,
count, replace und extract</em>.</p>
<div id="detect-matches" class="section level3" number="13.3.1">
<h3><span class="header-section-number">13.3.1</span> Detect
Matches</h3>
<p><code>str_detect()</code> gibt einen <em>logical vector</em>, der
<code>TRUE</code> ist aus, wenn das Muster ein Elemment des
<em>Character Vectors</em> trifft, ansonsten <code>FALSE</code>.</p>
<pre class="r"><code>str_detect(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;[aeiou]&quot;)</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE</code></pre>
<p>Da <code>str_detect()</code> einen <em>logical vector</em> ausgibt,
passt es gut zu <code>filter()</code>. Der Code findet alle Namen, die
ein kleines “x” enthalten.</p>
<pre class="r"><code>babynames |&gt; 
  filter(str_detect(name, &quot;x&quot;)) |&gt; 
  count(name, wt = n, sort = TRUE)</code></pre>
<pre><code>## # A tibble: 974 × 2
##    name            n
##    &lt;chr&gt;       &lt;int&gt;
##  1 Alexander  665492
##  2 Alexis     399551
##  3 Alex       278705
##  4 Alexandra  232223
##  5 Max        148787
##  6 Alexa      123032
##  7 Maxine     112261
##  8 Alexandria  97679
##  9 Maxwell     90486
## 10 Jaxon       71234
## # ℹ 964 more rows</code></pre>
<p><code>str_detect()</code> können wir auch mit
<code>summarize()</code> nutzen:
<code>sum(str_detect(x, pattern))</code> gibt die Anzahl der
Beobachtungen aus, die matchen und mit <code>mean(...)</code> die
Anteile.</p>
<pre class="r"><code>babynames |&gt; 
  group_by(year) |&gt; 
  summarize(prop_x = mean(str_detect(name, &quot;x&quot;))) |&gt; 
  ggplot(aes(x = year, y = prop_x)) + 
  geom_line()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-336-1.png" width="672" /></p>
<p>Zwei Funktionen sind eng verwandt mit <code>str_detect()</code>:
<code>str_subst()</code>, das die treffenden <em>Strings</em> ausgibt
und <code>str_which()</code>, das die treffenden Indices ausgibt.</p>
<pre class="r"><code>str_subset(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;[aeiou]&quot;)</code></pre>
<pre><code>## [1] &quot;a&quot;</code></pre>
<pre class="r"><code>str_which(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), &quot;[aeiou]&quot;)</code></pre>
<pre><code>## [1] 1</code></pre>
</div>
<div id="count-matches" class="section level3" number="13.3.2">
<h3><span class="header-section-number">13.3.2</span> Count Matches</h3>
<p><code>str_count()</code> sagt uns, wieviele Matches in jedem
<em>String</em> sind.</p>
<pre class="r"><code>x &lt;- c(&quot;apple&quot;, &quot;banana&quot;, &quot;pear&quot;)
str_count(x, &quot;p&quot;)</code></pre>
<pre><code>## [1] 2 0 1</code></pre>
<p>Wieviele Vokale und Konsonante sind in jedem Namen?</p>
<pre class="r"><code>babynames |&gt; 
  count(name) |&gt; 
  mutate(
    vowels = str_count(name, &quot;[aeiou]&quot;),
    consonants = str_count(name, &quot;[^aeiou]&quot;)
  )</code></pre>
<pre><code>## # A tibble: 97,310 × 4
##    name          n vowels consonants
##    &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
##  1 Aaban        10      2          3
##  2 Aabha         5      2          3
##  3 Aabid         2      2          3
##  4 Aabir         1      2          3
##  5 Aabriella     5      4          5
##  6 Aada          1      2          2
##  7 Aadam        26      2          3
##  8 Aadan        11      2          3
##  9 Aadarsh      17      2          5
## 10 Aaden        18      2          3
## # ℹ 97,300 more rows</code></pre>
<p><em>Regular Expressions</em> sind <em>case sensitive</em>! Drei
Möglichkeiten es zu beheben:</p>
<ul>
<li><code>str_count(name, "[aeiouAEIOU]")</code>.</li>
<li><code>str_count(regex(name, ignore_case = TRUE), "[aeiou]")</code>
ignoriere Case.</li>
<li>nutze <code>str_to_lower()</code>, um die Namen in lower case zu
konvertieren:
<code>str_count(str_to_lower(name), "[aeiou]")</code>.</li>
</ul>
<pre class="r"><code>babynames |&gt; 
  count(name) |&gt; 
  mutate(
    name = str_to_lower(name),
    vowels = str_count(name, &quot;[aeiou]&quot;),
    consonants = str_count(name, &quot;[^aeiou]&quot;)
  )</code></pre>
<pre><code>## # A tibble: 97,310 × 4
##    name          n vowels consonants
##    &lt;chr&gt;     &lt;int&gt;  &lt;int&gt;      &lt;int&gt;
##  1 aaban        10      3          2
##  2 aabha         5      3          2
##  3 aabid         2      3          2
##  4 aabir         1      3          2
##  5 aabriella     5      5          4
##  6 aada          1      3          1
##  7 aadam        26      3          2
##  8 aadan        11      3          2
##  9 aadarsh      17      3          4
## 10 aaden        18      3          2
## # ℹ 97,300 more rows</code></pre>
</div>
<div id="werte-ersetzen" class="section level3" number="13.3.3">
<h3><span class="header-section-number">13.3.3</span> Werte
ersetzen</h3>
<p>Wir können Matches modifizieren mit <code>str_replace()</code> und
<code>str_replace_all()</code>.</p>
<pre class="r"><code>x &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;)
str_replace_all(x, &quot;[aeiou]&quot;, &quot;-&quot;)</code></pre>
<pre><code>## [1] &quot;-ppl-&quot;  &quot;p--r&quot;   &quot;b-n-n-&quot;</code></pre>
<p><code>str_remove()</code> und <code>str_remove_all()</code> sind
Abkürzungen für <code>str_replace(x, pattern, "")</code>.</p>
<pre class="r"><code>x &lt;- c(&quot;apple&quot;, &quot;pear&quot;, &quot;banana&quot;)
str_remove_all(x, &quot;[aeiou]&quot;)</code></pre>
<pre><code>## [1] &quot;ppl&quot; &quot;pr&quot;  &quot;bnn&quot;</code></pre>
</div>
<div id="variablen-extrahieren" class="section level3" number="13.3.4">
<h3><span class="header-section-number">13.3.4</span> Variablen
extrahieren</h3>
</div>
</div>
<div id="muster---details" class="section level2" number="13.4">
<h2><span class="header-section-number">13.4</span> Muster -
Details</h2>
<div id="escaping" class="section level3" number="13.4.1">
<h3><span class="header-section-number">13.4.1</span> Escaping</h3>
<pre class="r"><code># To create the regular expression \., we need to use \\.
dot &lt;- &quot;\\.&quot;

# But the expression itself only contains one \
str_view(dot)</code></pre>
<pre><code>## [1] │ \.</code></pre>
<pre class="r"><code>#&gt; [1] │ \.

# And this tells R to look for an explicit .
str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;bef&quot;), &quot;a\\.c&quot;)</code></pre>
<pre><code>## [2] │ &lt;a.c&gt;</code></pre>
<pre class="r"><code>#&gt; [2] │ &lt;a.c&gt;</code></pre>
<pre class="r"><code>x &lt;- &quot;a\\b&quot;
str_view(x)</code></pre>
<pre><code>## [1] │ a\b</code></pre>
<pre class="r"><code>#&gt; [1] │ a\b
str_view(x, &quot;\\\\&quot;)</code></pre>
<pre><code>## [1] │ a&lt;\&gt;b</code></pre>
<pre class="r"><code>#&gt; [1] │ a&lt;\&gt;b</code></pre>
<pre class="r"><code>str_view(x, r&quot;{\\}&quot;)</code></pre>
<pre><code>## [1] │ a&lt;\&gt;b</code></pre>
<pre class="r"><code>#&gt; [1] │ a&lt;\&gt;b</code></pre>
<p>Wenn du versuchst ein Buchtabnesymbol (Literal) zu matchen
(<code>.</code>, <code>$</code>, <code>|</code>, <code>*</code>,
<code>+</code>, <code>?</code>, <code>{</code>, <code>}</code>,
<code>(</code>, <code>)</code>), dann gibt es eine Alternative zur
Nutzung des  Escape: <code>[.]</code>, <code>[$]</code>, …</p>
<pre class="r"><code>str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;a[.]c&quot;)</code></pre>
<pre><code>## [2] │ &lt;a.c&gt;</code></pre>
<pre class="r"><code>#&gt; [2] │ &lt;a.c&gt;
str_view(c(&quot;abc&quot;, &quot;a.c&quot;, &quot;a*c&quot;, &quot;a c&quot;), &quot;.[*]c&quot;)</code></pre>
<pre><code>## [3] │ &lt;a*c&gt;</code></pre>
<pre class="r"><code>#&gt; [3] │ &lt;a*c&gt;</code></pre>
</div>
<div id="anker" class="section level3" number="13.4.2">
<h3><span class="header-section-number">13.4.2</span> Anker</h3>
<p>Wenn du am Anfang matchen willst: <code>^</code>, am Ende:
<code>$</code>.</p>
<pre class="r"><code>str_view(fruit, &quot;^a&quot;)</code></pre>
<pre><code>## [1] │ &lt;a&gt;pple
## [2] │ &lt;a&gt;pricot
## [3] │ &lt;a&gt;vocado</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;a&gt;pple
#&gt; [2] │ &lt;a&gt;pricot
#&gt; [3] │ &lt;a&gt;vocado
str_view(fruit, &quot;a$&quot;)</code></pre>
<pre><code>##  [4] │ banan&lt;a&gt;
## [15] │ cherimoy&lt;a&gt;
## [30] │ feijo&lt;a&gt;
## [36] │ guav&lt;a&gt;
## [56] │ papay&lt;a&gt;
## [74] │ satsum&lt;a&gt;</code></pre>
<pre class="r"><code>#&gt;  [4] │ banan&lt;a&gt;
#&gt; [15] │ cherimoy&lt;a&gt;
#&gt; [30] │ feijo&lt;a&gt;
#&gt; [36] │ guav&lt;a&gt;
#&gt; [56] │ papay&lt;a&gt;
#&gt; [74] │ satsum&lt;a&gt;</code></pre>
<p><em>Full String</em> mit <code>^</code> und <code>$</code>:</p>
<pre class="r"><code>str_view(fruit, &quot;apple&quot;)</code></pre>
<pre><code>##  [1] │ &lt;apple&gt;
## [62] │ pine&lt;apple&gt;</code></pre>
<pre class="r"><code>#&gt;  [1] │ &lt;apple&gt;
#&gt; [62] │ pine&lt;apple&gt;
str_view(fruit, &quot;^apple$&quot;)</code></pre>
<pre><code>## [1] │ &lt;apple&gt;</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;apple&gt;</code></pre>
<p>Matche die Grenze zwischen zwei Wörtern (Start, Ende) mit
<code>\b</code>. Finde so alle Nutzungen von <code>sum()</code>. Suche
nach <code>\bsum\b</code>, um <code>summarize</code>,
<code>rowsum</code> oder ähnliches zu vermeiden.</p>
<pre class="r"><code>x &lt;- c(&quot;summary(x)&quot;, &quot;summarize(df)&quot;, &quot;rowsum(x)&quot;, &quot;sum(x)&quot;)
str_view(x, &quot;sum&quot;)</code></pre>
<pre><code>## [1] │ &lt;sum&gt;mary(x)
## [2] │ &lt;sum&gt;marize(df)
## [3] │ row&lt;sum&gt;(x)
## [4] │ &lt;sum&gt;(x)</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;sum&gt;mary(x)
#&gt; [2] │ &lt;sum&gt;marize(df)
#&gt; [3] │ row&lt;sum&gt;(x)
#&gt; [4] │ &lt;sum&gt;(x)
str_view(x, &quot;\\bsum\\b&quot;)</code></pre>
<pre><code>## [4] │ &lt;sum&gt;(x)</code></pre>
<pre class="r"><code>#&gt; [4] │ &lt;sum&gt;(x)</code></pre>
<pre class="r"><code>str_view(&quot;abc&quot;, c(&quot;$&quot;, &quot;^&quot;, &quot;\\b&quot;))</code></pre>
<pre><code>## [1] │ abc&lt;&gt;
## [2] │ &lt;&gt;abc
## [3] │ &lt;&gt;abc&lt;&gt;</code></pre>
<pre class="r"><code>#&gt; [1] │ abc&lt;&gt;
#&gt; [2] │ &lt;&gt;abc
#&gt; [3] │ &lt;&gt;abc&lt;&gt;</code></pre>
<pre class="r"><code>str_replace_all(&quot;abc&quot;, c(&quot;$&quot;, &quot;^&quot;, &quot;\\b&quot;), &quot;--&quot;)</code></pre>
<pre><code>## [1] &quot;abc--&quot;   &quot;--abc&quot;   &quot;--abc--&quot;</code></pre>
</div>
<div id="character---klassen" class="section level3" number="13.4.3">
<h3><span class="header-section-number">13.4.3</span> Character -
Klassen</h3>
<p>Du kannst deine eigenen Mengen mit <code>[]</code> konstruieren, wo
<code>[abc]</code> a, b, oder c matcht. Es gibt drei
<code>Character</code>, die innerhalb der eckigen Klammern eine
spezielle Bedeutung haben:</p>
<ul>
<li>eine Spanne wird definiert <code>[a-z]</code>, die Kleinbuchstaben
matcht und <code>[0-9]</code> Zahlen.</li>
<li><code>^</code> Inverse nimmt ales bis auf a, b oder c auf:
<code>[^abc]</code>.</li>
<li><code>\</code> trennt Zeichen, so dass <code>^</code> oder
<code>-</code> oder <code>]</code> matcht: <code>[\^\-\]]</code>.</li>
</ul>
<pre class="r"><code>x &lt;- &quot;abcd ABCD 12345 -!@#%.&quot;
str_view(x, &quot;[abc]+&quot;)</code></pre>
<pre><code>## [1] │ &lt;abc&gt;d ABCD 12345 -!@#%.</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;abc&gt;d ABCD 12345 -!@#%.
str_view(x, &quot;[a-z]+&quot;)</code></pre>
<pre><code>## [1] │ &lt;abcd&gt; ABCD 12345 -!@#%.</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;abcd&gt; ABCD 12345 -!@#%.
str_view(x, &quot;[^a-z0-9]+&quot;)</code></pre>
<pre><code>## [1] │ abcd&lt; ABCD &gt;12345&lt; -!@#%.&gt;</code></pre>
<pre class="r"><code>#&gt; [1] │ abcd&lt; ABCD &gt;12345&lt; -!@#%.&gt;

# You need an escape to match characters that are otherwise
# special inside of []
str_view(&quot;a-b-c&quot;, &quot;[a-c]&quot;)</code></pre>
<pre><code>## [1] │ &lt;a&gt;-&lt;b&gt;-&lt;c&gt;</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;a&gt;-&lt;b&gt;-&lt;c&gt;
str_view(&quot;a-b-c&quot;, &quot;[a\\-c]&quot;)</code></pre>
<pre><code>## [1] │ &lt;a&gt;&lt;-&gt;b&lt;-&gt;&lt;c&gt;</code></pre>
<pre class="r"><code>#&gt; [1] │ &lt;a&gt;&lt;-&gt;b&lt;-&gt;&lt;c&gt;</code></pre>
</div>
</div>
</div>
<div id="factors---faktoren" class="section level1" number="14">
<h1><span class="header-section-number">14</span> Factors -
Faktoren</h1>
<div id="einleitung-10" class="section level2" number="14.1">
<h2><span class="header-section-number">14.1</span> Einleitung</h2>
<p>Faktoren werden für kategoriale Variablen genutzt; Variablen, die
eine feste Menge an möglichen Werten haben.</p>
<div id="voraussetzungen-9" class="section level3" number="14.1.1">
<h3><span class="header-section-number">14.1.1</span>
Voraussetzungen</h3>
<p>Das <strong>forcats</strong> Paket ist Teil von
<code>tidyverse</code>.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
</div>
<div id="faktoren---basics" class="section level2" number="14.2">
<h2><span class="header-section-number">14.2</span> Faktoren -
Basics</h2>
<pre class="r"><code>x1 &lt;- c(&quot;Dec&quot;, &quot;Apr&quot;, &quot;Jan&quot;, &quot;Mar&quot;)</code></pre>
<p>Als <em>String</em> diese Werte aufzunehmen, hat zwei Probleme:</p>
<ol style="list-style-type: decimal">
<li>Tippfehler</li>
</ol>
<pre class="r"><code>x2 &lt;- c(&quot;Dec&quot;, &quot;Apr&quot;, &quot;Jam&quot;, &quot;Mar&quot;)</code></pre>
<ol start="2" style="list-style-type: decimal">
<li>Sortieren</li>
</ol>
<pre class="r"><code>sort(x1)</code></pre>
<pre><code>## [1] &quot;Apr&quot; &quot;Dec&quot; &quot;Jan&quot; &quot;Mar&quot;</code></pre>
<p>Um einen Faktor zu kreieren, starte mit einer Liste valider
<strong>levels</strong>:</p>
<pre class="r"><code>month_levels &lt;- c(
  &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, 
  &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;
)</code></pre>
<p>Daraus kannst du einen Faktor bauen:</p>
<pre class="r"><code>y1 &lt;- factor(x1, levels = month_levels)
y1</code></pre>
<pre><code>## [1] Dec Apr Jan Mar
## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</code></pre>
<pre class="r"><code>sort(y1)</code></pre>
<pre><code>## [1] Jan Mar Apr Dec
## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</code></pre>
<p>Jeder Wert, der sich nicht in <em>levels</em> befindet, wird zu
<code>NA</code> konvertiert.</p>
<pre class="r"><code>y2 &lt;- factor(x2, levels = month_levels)
y2</code></pre>
<pre><code>## [1] Dec  Apr  &lt;NA&gt; Mar 
## Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</code></pre>
<p>In alphabetischer Reihenfolge werden die Daten genommen, wenn du die
Levels vergisst.</p>
<pre class="r"><code>factor(x1)</code></pre>
<pre><code>## [1] Dec Apr Jan Mar
## Levels: Apr Dec Jan Mar</code></pre>
<p>Du kannst die Reihenfolge nach dem erstmaligen Erscheinen
festlegen:</p>
<pre class="r"><code>f1 &lt;- factor(x1, levels = unique(x1))
f1</code></pre>
<pre><code>## [1] Dec Apr Jan Mar
## Levels: Dec Apr Jan Mar</code></pre>
<pre class="r"><code>f2 &lt;- x1 |&gt; factor() |&gt; fct_inorder()
f2</code></pre>
<pre><code>## [1] Dec Apr Jan Mar
## Levels: Dec Apr Jan Mar</code></pre>
<p>Beim Einlesen der Daten kannst du direkt einen Faktor erzeugen mit
<code>col_factor()</code>:</p>
<pre class="r"><code>library(readr)
month_levels &lt;- c(
  &quot;Jan&quot;, &quot;Feb&quot;, &quot;Mar&quot;, &quot;Apr&quot;, &quot;May&quot;, &quot;Jun&quot;, 
  &quot;Jul&quot;, &quot;Aug&quot;, &quot;Sep&quot;, &quot;Oct&quot;, &quot;Nov&quot;, &quot;Dec&quot;
)

csv &lt;- &quot;
month,value
Jan,12
Feb,56
Mar,12&quot;

df &lt;- read_csv(csv, col_types = cols(month = col_factor(month_levels)))
df$month
#&gt; [1] Jan Feb Mar
#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec</code></pre>
</div>
<div id="general-social-survey" class="section level2" number="14.3">
<h2><span class="header-section-number">14.3</span> General Social
Survey</h2>
<p>Wir benutzen: <code>forcats::gss_cat</code>. Der Survey hat Tausende
von Fragen.</p>
<pre class="r"><code>gss_cat</code></pre>
<pre><code>## # A tibble: 21,483 × 9
##     year marital         age race  rincome        partyid    relig denom tvhours
##    &lt;int&gt; &lt;fct&gt;         &lt;int&gt; &lt;fct&gt; &lt;fct&gt;          &lt;fct&gt;      &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;
##  1  2000 Never married    26 White $8000 to 9999  Ind,near … Prot… Sout…      12
##  2  2000 Divorced         48 White $8000 to 9999  Not str r… Prot… Bapt…      NA
##  3  2000 Widowed          67 White Not applicable Independe… Prot… No d…       2
##  4  2000 Never married    39 White Not applicable Ind,near … Orth… Not …       4
##  5  2000 Divorced         25 White Not applicable Not str d… None  Not …       1
##  6  2000 Married          25 White $20000 - 24999 Strong de… Prot… Sout…      NA
##  7  2000 Never married    36 White $25000 or more Not str r… Chri… Not …       3
##  8  2000 Divorced         44 White $7000 to 7999  Ind,near … Prot… Luth…      NA
##  9  2000 Married          44 White $25000 or more Not str d… Prot… Other       0
## 10  2000 Married          47 White $25000 or more Strong re… Prot… Sout…       3
## # ℹ 21,473 more rows</code></pre>
<p>In einem tibble kannst du die Level mit <code>count()</code>
sehen.</p>
<pre class="r"><code>gss_cat |&gt;
  count(race)</code></pre>
<pre><code>## # A tibble: 3 × 2
##   race      n
##   &lt;fct&gt; &lt;int&gt;
## 1 Other  1959
## 2 Black  3129
## 3 White 16395</code></pre>
<p>Oder mit einem Säulendiagramm:</p>
<pre class="r"><code>ggplot(gss_cat, aes(x = race)) +
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-365-1.png" width="672" /></p>
</div>
<div id="reihenfolge-der-factors-ändern" class="section level2"
number="14.4">
<h2><span class="header-section-number">14.4</span> Reihenfolge der
factors ändern</h2>
<p>Manchmal macht es Sinn die Reihenfolge der Faktoren zu ändern.
Schauen wir uns die durchschnittliche TV Zeit pro Tag und Religionen
an.</p>
<pre class="r"><code>relig_summary &lt;- gss_cat |&gt;
  group_by(relig) |&gt;
  summarize(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )

ggplot(relig_summary, aes(x = tvhours, y = relig)) + 
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-366-1.png" width="672" /></p>
<p>Der Plot ist schwer zu lesen, da es hier kein Muster gibt.
<code>fct_reorder()</code> sortiert um, und nimmt dabei drei Argumente
an:</p>
<ul>
<li><code>f</code>, der Faktor, wessen Levels du modifizieren
willst.</li>
<li><code>x</code>, ein numerischer Vektor, den du benutzt, um die
Reihenfolge zu bestimmen.</li>
<li>optional: <code>fun</code>, eine Funktion, wenn es multiple Werte
von <code>x</code> gibt, für jeden Wert von <code>f</code>. Default ist
Median.</li>
</ul>
<pre class="r"><code>ggplot(relig_summary, aes(x = tvhours, y = fct_reorder(relig, tvhours))) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-367-1.png" width="672" /></p>
<p>Bei komplizierten Transformationen empfehlen wir sie aus
<code>aes()</code> zu nehmen und in ein separates <code>mutate()</code>
zu stecken.</p>
<pre class="r"><code>relig_summary |&gt;
  mutate(
    relig = fct_reorder(relig, tvhours)
  ) |&gt;
  ggplot(aes(x = tvhours, y = relig)) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-368-1.png" width="672" /></p>
<p>Wie sieht es mit der Altersverteilung in bestimmten Einkommensstufen
aus?</p>
<pre class="r"><code>rincome_summary &lt;- gss_cat |&gt;
  group_by(rincome) |&gt;
  summarize(
    age = mean(age, na.rm = TRUE),
    tvhours = mean(tvhours, na.rm = TRUE),
    n = n()
  )
rincome_summary</code></pre>
<pre><code>## # A tibble: 16 × 4
##    rincome          age tvhours     n
##    &lt;fct&gt;          &lt;dbl&gt;   &lt;dbl&gt; &lt;int&gt;
##  1 No answer       45.5    2.90   183
##  2 Don&#39;t know      45.6    3.41   267
##  3 Refused         47.6    2.48   975
##  4 $25000 or more  44.2    2.23  7363
##  5 $20000 - 24999  41.5    2.78  1283
##  6 $15000 - 19999  40.0    2.91  1048
##  7 $10000 - 14999  41.1    3.02  1168
##  8 $8000 to 9999   41.1    3.15   340
##  9 $7000 to 7999   38.2    2.65   188
## 10 $6000 to 6999   40.3    3.17   215
## 11 $5000 to 5999   37.8    3.16   227
## 12 $4000 to 4999   38.9    3.15   226
## 13 $3000 to 3999   37.8    3.31   276
## 14 $1000 to 2999   34.5    3.00   395
## 15 Lt $1000        40.5    3.36   286
## 16 Not applicable  56.1    3.79  7043</code></pre>
<p>Und dann bitte nett darstellen.</p>
<pre class="r"><code>ggplot(rincome_summary, aes(x = age, y = fct_reorder(rincome, age))) + 
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-370-1.png" width="672" /></p>
<p>Die Reihenfolge hier sollte jedoch noch einmal überdacht werden. Am
Anfang sollte jedoch “Not applicable” stehen. Nutze
<code>fct_relevel()</code>. Es nimmt einen Faktor <code>f</code>, dann
jede Anzahl an Levels, die du in die erste Zeile(n) schreiben
willst.</p>
<pre class="r"><code>ggplot(rincome_summary, aes(x = age, y = fct_relevel(rincome, &quot;Not applicable&quot;))) +
  geom_point()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-371-1.png" width="672" /></p>
<p>Ein anderer Typ der Umordnung ist nützlich, wenn du die Linien eines
Plots farblich einfärbst. Durch die Umsortierung passen sich die Farben
des Plots auf der rechten Seite der Legende an.</p>
<pre class="r"><code>by_age &lt;- gss_cat |&gt;
  filter(!is.na(age)) |&gt;
  count(age, marital) |&gt;
  group_by(age) |&gt;
  mutate(
    prop = n / sum(n)
  )

ggplot(by_age, aes(x = age, y = prop, color = marital)) +
  geom_line(na.rm = TRUE)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-372-1.png" width="672" /></p>
<pre class="r"><code>ggplot(by_age, aes(x = age, y = prop, color = fct_reorder2(marital, age, prop))) +
  geom_line() +
  labs(color = &quot;marital&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-372-2.png" width="672" /></p>
<p>Für Balkendiagramme kannst du <code>fct_infreq()</code> benutzen, um
Levels Nach Häufigkeit zu sortieren. Kombiniere es mit
<code>fct_rev()</code>, wenn du den häufigsten Wert auf der rechten,
statt auf der linken Seite haben willst.</p>
<pre class="r"><code>gss_cat |&gt;
  mutate(marital = marital |&gt; fct_infreq() |&gt; fct_rev()) |&gt;
  ggplot(aes(x = marital)) +
  geom_bar()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-373-1.png" width="672" /></p>
</div>
<div id="faktorlevel-modifizieren" class="section level2" number="14.5">
<h2><span class="header-section-number">14.5</span> Faktorlevel
modifizieren</h2>
<p>Mächtiger als die Reihenfolge zu verändern ist es, ihre Werte zu
wechseln. Das mächtigste Werkzeug ist <code>fct_recode()</code>. Es
wechselt den Wert von jedem Level.</p>
<pre class="r"><code>gss_cat |&gt; count(partyid)</code></pre>
<pre><code>## # A tibble: 10 × 2
##    partyid                n
##    &lt;fct&gt;              &lt;int&gt;
##  1 No answer            154
##  2 Don&#39;t know             1
##  3 Other party          393
##  4 Strong republican   2314
##  5 Not str republican  3032
##  6 Ind,near rep        1791
##  7 Independent         4119
##  8 Ind,near dem        2499
##  9 Not str democrat    3690
## 10 Strong democrat     3490</code></pre>
<p>Die Level sind lapidar und inkonsistent. Die neuen Werte stehen auf
der linken und die alten Werte auf der rechten Seite.</p>
<pre class="r"><code>gss_cat |&gt;
  mutate(
    partyid = fct_recode(partyid,
      &quot;Republican, strong&quot;    = &quot;Strong republican&quot;,
      &quot;Republican, weak&quot;      = &quot;Not str republican&quot;,
      &quot;Independent, near rep&quot; = &quot;Ind,near rep&quot;,
      &quot;Independent, near dem&quot; = &quot;Ind,near dem&quot;,
      &quot;Democrat, weak&quot;        = &quot;Not str democrat&quot;,
      &quot;Democrat, strong&quot;      = &quot;Strong democrat&quot;
    )
  ) |&gt;
  count(partyid)</code></pre>
<pre><code>## # A tibble: 10 × 2
##    partyid                   n
##    &lt;fct&gt;                 &lt;int&gt;
##  1 No answer               154
##  2 Don&#39;t know                1
##  3 Other party             393
##  4 Republican, strong     2314
##  5 Republican, weak       3032
##  6 Independent, near rep  1791
##  7 Independent            4119
##  8 Independent, near dem  2499
##  9 Democrat, weak         3690
## 10 Democrat, strong       3490</code></pre>
<p>Um Gruppen zu kombinieren, kannst du einfach verschiedenen alten
Level, gleiche neue verpassen.</p>
<pre class="r"><code>gss_cat |&gt;
  mutate(
    partyid = fct_recode(partyid,
      &quot;Republican, strong&quot;    = &quot;Strong republican&quot;,
      &quot;Republican, weak&quot;      = &quot;Not str republican&quot;,
      &quot;Independent, near rep&quot; = &quot;Ind,near rep&quot;,
      &quot;Independent, near dem&quot; = &quot;Ind,near dem&quot;,
      &quot;Democrat, weak&quot;        = &quot;Not str democrat&quot;,
      &quot;Democrat, strong&quot;      = &quot;Strong democrat&quot;,
      &quot;Other&quot;                 = &quot;No answer&quot;,
      &quot;Other&quot;                 = &quot;Don&#39;t know&quot;,
      &quot;Other&quot;                 = &quot;Other party&quot;
    )
  ) |&gt;
  count(partyid)</code></pre>
<pre><code>## # A tibble: 8 × 2
##   partyid                   n
##   &lt;fct&gt;                 &lt;int&gt;
## 1 Other                   548
## 2 Republican, strong     2314
## 3 Republican, weak       3032
## 4 Independent, near rep  1791
## 5 Independent            4119
## 6 Independent, near dem  2499
## 7 Democrat, weak         3690
## 8 Democrat, strong       3490</code></pre>
<p><code>fct_collapse()</code> ist eine Variante, wenn du sehr viele
Level zusammenfassen willst.</p>
<pre class="r"><code>gss_cat |&gt;
  mutate(
    partyid = fct_collapse(partyid,
      &quot;other&quot; = c(&quot;No answer&quot;, &quot;Don&#39;t know&quot;, &quot;Other party&quot;),
      &quot;rep&quot; = c(&quot;Strong republican&quot;, &quot;Not str republican&quot;),
      &quot;ind&quot; = c(&quot;Ind,near rep&quot;, &quot;Independent&quot;, &quot;Ind,near dem&quot;),
      &quot;dem&quot; = c(&quot;Not str democrat&quot;, &quot;Strong democrat&quot;)
    )
  ) |&gt;
  count(partyid)</code></pre>
<pre><code>## # A tibble: 4 × 2
##   partyid     n
##   &lt;fct&gt;   &lt;int&gt;
## 1 other     548
## 2 rep      5346
## 3 ind      8409
## 4 dem      7180</code></pre>
<p>Manchmal willst du kleine Gruppen zusammenwerfen. Diesen Job macht
<code>fct_lump_*()</code>. <code>fct_lump_lowfreq()</code> schmeißt die
kleinsten Gruppen in eine “Other” Kategorie.</p>
<pre class="r"><code>gss_cat |&gt;
  mutate(relig = fct_lump_lowfreq(relig)) |&gt;
  count(relig)</code></pre>
<pre><code>## # A tibble: 2 × 2
##   relig          n
##   &lt;fct&gt;      &lt;int&gt;
## 1 Protestant 10846
## 2 Other      10637</code></pre>
<p>Ein bisschen mehr Details wollen wir schon sehen! Wir wollen genau
n=10 Gruppen sehen, mit <code>fct_lump_n()</code>.</p>
<pre class="r"><code>gss_cat |&gt;
  mutate(relig = fct_lump_n(relig, n = 10)) |&gt;
  count(relig, sort = TRUE) |&gt;
  print(n = Inf)</code></pre>
<pre><code>## # A tibble: 10 × 2
##    relig                       n
##    &lt;fct&gt;                   &lt;int&gt;
##  1 Protestant              10846
##  2 Catholic                 5124
##  3 None                     3523
##  4 Christian                 689
##  5 Other                     458
##  6 Jewish                    388
##  7 Buddhism                  147
##  8 Inter-nondenominational   109
##  9 Moslem/islam              104
## 10 Orthodox-christian         95</code></pre>
</div>
</div>
<div id="dates-und-zeiten" class="section level1" number="15">
<h1><span class="header-section-number">15</span> Dates und Zeiten</h1>
<div id="einleitung-11" class="section level2" number="15.1">
<h2><span class="header-section-number">15.1</span> Einleitung</h2>
<div id="voraussetzungen-10" class="section level3" number="15.1.1">
<h3><span class="header-section-number">15.1.1</span>
Voraussetzungen</h3>
<p>Wir konzentrieren uns auf das <strong>lubridate</strong> Paket.</p>
<pre class="r"><code>library(tidyverse)
library(lubridate)
library(nycflights13)</code></pre>
</div>
</div>
<div id="kreieren-von-datetimes" class="section level2" number="15.2">
<h2><span class="header-section-number">15.2</span> Kreieren von
date/times</h2>
<p>Drei Typen von date/time beziehen sich auf den Moment der Zeit:</p>
<p><strong>date</strong> - Tibble als <code>&lt;date&gt;</code><br />
<strong>time</strong> - Tibble als <code>&lt;time&gt;</code><br />
<strong>date-time</strong> - Tibble als <code>&lt;dttm&gt;</code></p>
<p>Für das aktuelle Datum oder date-time, nutze <code>today()</code>
oder <code>now()</code>:</p>
<pre class="r"><code>today()</code></pre>
<pre><code>## [1] &quot;2023-10-09&quot;</code></pre>
<pre class="r"><code>now()</code></pre>
<pre><code>## [1] &quot;2023-10-09 00:54:27 CEST&quot;</code></pre>
<p>Die folgenden Abschnitte beschreiben vier weitere Möglichkeiten.</p>
<div id="während-import-mit-readr" class="section level3"
number="15.2.1">
<h3><span class="header-section-number">15.2.1</span> Während Import mit
readr</h3>
<pre class="r"><code>csv &lt;- &quot;
  date,datetime
  2022-01-02,2022-01-02 05:12
&quot;
read_csv(csv)</code></pre>
<pre><code>## Rows: 1 Columns: 2
## ── Column specification ────────────────────────────────────────────────────────
## Delimiter: &quot;,&quot;
## dttm (1): datetime
## date (1): date
## 
## ℹ Use `spec()` to retrieve the full column specification for this data.
## ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.</code></pre>
<pre><code>## # A tibble: 1 × 2
##   date       datetime           
##   &lt;date&gt;     &lt;dttm&gt;             
## 1 2022-01-02 2022-01-02 05:12:00</code></pre>
<p>Das Ausgabeformat kannst du individuell bestimmen.</p>
<pre class="r"><code>csv &lt;- &quot;
  date
  01/02/15
&quot;

read_csv(csv, col_types = cols(date = col_date(&quot;%m/%d/%y&quot;)))</code></pre>
<pre><code>## # A tibble: 1 × 1
##   date      
##   &lt;date&gt;    
## 1 2015-01-02</code></pre>
<pre class="r"><code>read_csv(csv, col_types = cols(date = col_date(&quot;%d/%m/%y&quot;)))</code></pre>
<pre><code>## # A tibble: 1 × 1
##   date      
##   &lt;date&gt;    
## 1 2015-02-01</code></pre>
<pre class="r"><code>read_csv(csv, col_types = cols(date = col_date(&quot;%y/%m/%d&quot;)))</code></pre>
<pre><code>## # A tibble: 1 × 1
##   date      
##   &lt;date&gt;    
## 1 2001-02-15</code></pre>
</div>
<div id="von-strings" class="section level3" number="15.2.2">
<h3><span class="header-section-number">15.2.2</span> Von Strings</h3>
<pre class="r"><code>ymd(&quot;2017-01-31&quot;)</code></pre>
<pre><code>## [1] &quot;2017-01-31&quot;</code></pre>
<pre class="r"><code>mdy(&quot;January 31st, 2017&quot;)</code></pre>
<pre><code>## [1] &quot;2017-01-31&quot;</code></pre>
<pre class="r"><code>dmy(&quot;31-Jan-2017&quot;)</code></pre>
<pre><code>## [1] &quot;2017-01-31&quot;</code></pre>
<p>Um ein date-time zu kreieren, füge _ und mind. “h”, “m” oder “s”
hinzu:</p>
<pre class="r"><code>ymd_hms(&quot;2017-01-31 20:11:59&quot;)
#&gt; [1] &quot;2017-01-31 20:11:59 UTC&quot;
mdy_hm(&quot;01/31/2017 08:01&quot;)
#&gt; [1] &quot;2017-01-31 08:01:00 UTC&quot;</code></pre>
</div>
<div id="von-individuellen-komponenten" class="section level3"
number="15.2.3">
<h3><span class="header-section-number">15.2.3</span> Von individuellen
Komponenten</h3>
<pre class="r"><code>flights |&gt; 
  select(year, month, day, hour, minute)</code></pre>
<pre><code>## # A tibble: 336,776 × 5
##     year month   day  hour minute
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;
##  1  2013     1     1     5     15
##  2  2013     1     1     5     29
##  3  2013     1     1     5     40
##  4  2013     1     1     5     45
##  5  2013     1     1     6      0
##  6  2013     1     1     5     58
##  7  2013     1     1     6      0
##  8  2013     1     1     6      0
##  9  2013     1     1     6      0
## 10  2013     1     1     6      0
## # ℹ 336,766 more rows</code></pre>
<pre class="r"><code>flights |&gt; 
  select(year, month, day, hour, minute) |&gt; 
  mutate(departure = make_datetime(year, month, day, hour, minute))</code></pre>
<pre><code>## # A tibble: 336,776 × 6
##     year month   day  hour minute departure          
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dttm&gt;             
##  1  2013     1     1     5     15 2013-01-01 05:15:00
##  2  2013     1     1     5     29 2013-01-01 05:29:00
##  3  2013     1     1     5     40 2013-01-01 05:40:00
##  4  2013     1     1     5     45 2013-01-01 05:45:00
##  5  2013     1     1     6      0 2013-01-01 06:00:00
##  6  2013     1     1     5     58 2013-01-01 05:58:00
##  7  2013     1     1     6      0 2013-01-01 06:00:00
##  8  2013     1     1     6      0 2013-01-01 06:00:00
##  9  2013     1     1     6      0 2013-01-01 06:00:00
## 10  2013     1     1     6      0 2013-01-01 06:00:00
## # ℹ 336,766 more rows</code></pre>
</div>
</div>
</div>
<div id="missing-values-2" class="section level1" number="16">
<h1><span class="header-section-number">16</span> Missing Values</h1>
<div id="einleitung-12" class="section level2" number="16.1">
<h2><span class="header-section-number">16.1</span> Einleitung</h2>
<p>Ein paar Basics haben wir schon kennengelernt, jetzt gehen wir ins
Detail.</p>
<div id="voraussetzungen-11" class="section level3" number="16.1.1">
<h3><span class="header-section-number">16.1.1</span>
Voraussetzungen</h3>
<p>Die meisten Funktionen kommen von <strong>dplyr</strong> und
<strong>tidyr</strong>, die Teil des <strong>tidyverse</strong>
sind.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
</div>
<div id="eindeutig-missing-values" class="section level2" number="16.2">
<h2><span class="header-section-number">16.2</span> Eindeutig Missing
Values</h2>
<p>Ein paar handliche Werkzeuge, um <em>Missing Values</em> zu kreieren
oder zu eliminieren. Zellen mit <code>NA</code>.</p>
<div id="last-obversation-carried-forward" class="section level3"
number="16.2.1">
<h3><span class="header-section-number">16.2.1</span> Last Obversation
carried forward</h3>
<p>Manchmal zeigt ein <code>NA</code>, dass der Wert der vorangehenden
Zeile wiederholt wurde.</p>
<pre class="r"><code>treatment &lt;- tribble(
  ~person,           ~treatment, ~response,
  &quot;Derrick Whitmore&quot;, 1,         7,
  NA,                 2,         10,
  NA,                 3,         NA,
  &quot;Katherine Burke&quot;,  1,         4
)</code></pre>
<p>Diese <code>NA</code> kann man füllen mit <code>tidyr::fill()</code>.
Es nimmt eine Menge von Spalten auf.</p>
<pre class="r"><code>treatment |&gt;
  fill(everything())</code></pre>
<pre><code>## # A tibble: 4 × 3
##   person           treatment response
##   &lt;chr&gt;                &lt;dbl&gt;    &lt;dbl&gt;
## 1 Derrick Whitmore         1        7
## 2 Derrick Whitmore         2       10
## 3 Derrick Whitmore         3       10
## 4 Katherine Burke          1        4</code></pre>
</div>
<div id="feste-werte" class="section level3" number="16.2.2">
<h3><span class="header-section-number">16.2.2</span> Feste Werte</h3>
<p>Manchmal werden <code>NA</code>’s ersetzt durch feste, bekannte Werte
wie 0. Benutze <code>dplyr:: coalesce()</code>, um die <code>NA</code>’s
zu ersetzen:</p>
<pre class="r"><code>x &lt;- c(1, 4, 5, 7, NA)
coalesce(x, 0)</code></pre>
<pre><code>## [1] 1 4 5 7 0</code></pre>
<p>Oft wird eine Zahl wie die -99 als <code>NA</code> geschrieben.
Ersetze sie durch NA mit der Funktion <code>dplyr::na_if()</code>:</p>
<pre class="r"><code>x &lt;- c(1, 4, 5, 7, -99)
na_if(x, -99)</code></pre>
<pre><code>## [1]  1  4  5  7 NA</code></pre>
</div>
<div id="nan" class="section level3" number="16.2.3">
<h3><span class="header-section-number">16.2.3</span> NaN</h3>
<p>Ein spezieller Typ von <em>Missing Values</em> ist <code>NaN</code>,
er verhält sich wie <code>NA</code>:</p>
<pre class="r"><code>x &lt;- c(NA, NaN)
x * 10</code></pre>
<pre><code>## [1]  NA NaN</code></pre>
<pre class="r"><code>x == 1</code></pre>
<pre><code>## [1] NA NA</code></pre>
<pre class="r"><code>is.na(x)</code></pre>
<pre><code>## [1] TRUE TRUE</code></pre>
<p><code>NaN</code> trifft häufig bei mathematischen Operationen
auf:</p>
<pre class="r"><code>0 / 0 </code></pre>
<pre><code>## [1] NaN</code></pre>
<pre class="r"><code>0 * Inf</code></pre>
<pre><code>## [1] NaN</code></pre>
<pre class="r"><code>Inf - Inf</code></pre>
<pre><code>## [1] NaN</code></pre>
</div>
</div>
<div id="implizierte-missing-values" class="section level2"
number="16.3">
<h2><span class="header-section-number">16.3</span> Implizierte Missing
Values</h2>
<p><strong>Explizite</strong> <em>Missing Values</em> kannst du durch
ein <code>NA</code> lokalisieren. Implizierte <em>Missing Values</em>
zeichnen sich dadurch aus, dass ganze Zeilen oder Spalten fehlen.</p>
<pre class="r"><code>stocks &lt;- tibble(
  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),
  qtr   = c(   1,    2,    3,    4,    2,    3,    4),
  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)
)</code></pre>
<div id="pivoting" class="section level3" number="16.3.1">
<h3><span class="header-section-number">16.3.1</span> Pivoting</h3>
<p>Ein Werkzeug kann implizierte <em>Missings</em> explizit machen, und
umgekehrt: <strong>Pivoting</strong>. In unserem Beispiel muss jede
Kombination von Zeilen und Spalten einen Wert haben.</p>
<pre class="r"><code>stocks |&gt;
  pivot_wider(
    names_from = qtr, 
    values_from = price
  )</code></pre>
<pre><code>## # A tibble: 2 × 5
##    year   `1`   `2`   `3`   `4`
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  2020  1.88  0.59  0.35 NA   
## 2  2021 NA     0.92  0.17  2.66</code></pre>
</div>
<div id="complete" class="section level3" number="16.3.2">
<h3><span class="header-section-number">16.3.2</span>
<code>Complete</code></h3>
<p><code>tidyr::complete()</code> generiert explizite <em>Missings</em>,
durch das Anbieten der Variablen, die die Kombinationen von Zeilen
definieren, die existieren sollten. Zum Beispiel wissen wir, dass alle
Kombinationen von <code>year</code> und <code>qtr</code> in
<code>stocks</code> existieren sollten.</p>
<pre class="r"><code>stocks |&gt;
  complete(year, qtr)</code></pre>
<pre><code>## # A tibble: 8 × 3
##    year   qtr price
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  2020     1  1.88
## 2  2020     2  0.59
## 3  2020     3  0.35
## 4  2020     4 NA   
## 5  2021     1 NA   
## 6  2021     2  0.92
## 7  2021     3  0.17
## 8  2021     4  2.66</code></pre>
<p>Du rufst <code>complete()</code> mit den existierenden Variablen auf,
so dass die fehlenden Kombinationen aufgefüllt werden. Sind die
Variablen selbst nicht komplett, kannst du eigene Werte liefern. So
kannst du den <code>stocks</code> Datensatz von 2019 bis 2021 laufen
lassen.</p>
<pre class="r"><code>stocks |&gt;
  complete(year = 2019:2021, qtr)</code></pre>
<pre><code>## # A tibble: 12 × 3
##     year   qtr price
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  2019     1 NA   
##  2  2019     2 NA   
##  3  2019     3 NA   
##  4  2019     4 NA   
##  5  2020     1  1.88
##  6  2020     2  0.59
##  7  2020     3  0.35
##  8  2020     4 NA   
##  9  2021     1 NA   
## 10  2021     2  0.92
## 11  2021     3  0.17
## 12  2021     4  2.66</code></pre>
<p>Benutze <code>full_seq(x, 1)</code>, um fehlende Lücken zu stopfen,
hier in Einer-Schritten.</p>
<pre class="r"><code>full_seq(c(1, 2, 4, 5, 10), 1)</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
</div>
<div id="joins" class="section level3" number="16.3.3">
<h3><span class="header-section-number">16.3.3</span> Joins</h3>
<p><strong>Joins</strong> lernen wir später näher kennen.
<code>dplyr::anti_join(x, y)</code> nimmt nur die Reihen in
<code>x</code>, die kein Match in <code>y</code> haben. So können wir
enthüllen, dass Informationen zu vier Flughäfen fehlen, die in
<code>flights</code> genannt wurden.</p>
<pre class="r"><code>library(nycflights13)

flights |&gt; 
  distinct(faa = dest) |&gt; 
  anti_join(airports)</code></pre>
<pre><code>## Joining with `by = join_by(faa)`</code></pre>
<pre><code>## # A tibble: 4 × 1
##   faa  
##   &lt;chr&gt;
## 1 BQN  
## 2 SJU  
## 3 STT  
## 4 PSE</code></pre>
<p>Zuerst werden alle verschiedenen <code>dest</code> in faa
gespeichert. Mit <code>anti_join(airports)</code> wird dann in der
Variable <code>faa</code> in dem Datensatz <code>airports</code>
geschaut, ob die <code>dest</code> dort zu finden sind. In unserem Fall
fehlen dort vier Flughäfen.</p>
<pre class="r"><code>flights |&gt; 
  distinct(tailnum) |&gt; 
  anti_join(planes)</code></pre>
<pre><code>## Joining with `by = join_by(tailnum)`</code></pre>
<pre><code>## # A tibble: 722 × 1
##    tailnum
##    &lt;chr&gt;  
##  1 N3ALAA 
##  2 N3DUAA 
##  3 N542MQ 
##  4 N730MQ 
##  5 N9EAMQ 
##  6 N532UA 
##  7 N3EMAA 
##  8 N518MQ 
##  9 N3BAAA 
## 10 N3CYAA 
## # ℹ 712 more rows</code></pre>
</div>
</div>
<div id="faktoren-und-leere-gruppen" class="section level2"
number="16.4">
<h2><span class="header-section-number">16.4</span> Faktoren und leere
Gruppen</h2>
<pre class="r"><code>health &lt;- tibble(
  name   = c(&quot;Ikaia&quot;, &quot;Oletta&quot;, &quot;Leriah&quot;, &quot;Dashay&quot;, &quot;Tresaun&quot;),
  smoker = factor(c(&quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;, &quot;no&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;)),
  age    = c(34L, 88L, 75L, 47L, 56L),
)</code></pre>
<p>Wir wollen erstmal die Anzahl an Rauchern zählen mit
<code>dplyr::count()</code>.</p>
<pre class="r"><code>health |&gt; count(smoker)</code></pre>
<pre><code>## # A tibble: 1 × 2
##   smoker     n
##   &lt;fct&gt;  &lt;int&gt;
## 1 no         5</code></pre>
<p>Da die Gruppe nur Nichtraucher enthält, werden keine Nicht-Raucher
angezeigt. Wir können aber nach diesen nachfragen, auch wenn keine
vorhanden sind, mit <code>.drop = FALSE</code>:</p>
<pre class="r"><code>health |&gt; count(smoker, .drop = FALSE)</code></pre>
<pre><code>## # A tibble: 2 × 2
##   smoker     n
##   &lt;fct&gt;  &lt;int&gt;
## 1 yes        0
## 2 no         5</code></pre>
<p>Gleiches mit Achsen:</p>
<pre class="r"><code>ggplot(health, aes(x = smoker)) +
  geom_bar() +
  scale_x_discrete()</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-405-1.png" width="672" /></p>
<pre class="r"><code>ggplot(health, aes(x = smoker)) +
  geom_bar() +
  scale_x_discrete(drop = FALSE)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-405-2.png" width="672" /></p>
<p>Gleiches Problem mit <code>dplyr::group_by()</code>:</p>
<pre class="r"><code>health |&gt; 
  group_by(smoker, .drop = FALSE) |&gt; 
  summarize(
    n = n(),
    mean_age = mean(age),
    min_age = min(age),
    max_age = max(age),
    sd_age = sd(age)
  )</code></pre>
<pre><code>## Warning: There were 2 warnings in `summarize()`.
## The first warning was:
## ℹ In argument: `min_age = min(age)`.
## ℹ In group 1: `smoker = yes`.
## Caused by warning in `min()`:
## ! kein nicht-fehlendes Argument für min; gebe Inf zurück
## ℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.</code></pre>
<pre><code>## # A tibble: 2 × 6
##   smoker     n mean_age min_age max_age sd_age
##   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1 yes        0      NaN     Inf    -Inf   NA  
## 2 no         5       60      34      88   21.6</code></pre>
<p>Ein leerer Vektor hat die Länge 0, <em>Missing Values</em> haben
jeweils die Länge 1.<br />
Führe Summary durch und dann mache die implizierten <em>Missings</em>
explizit mit <code>complete()</code>.</p>
<pre class="r"><code>health |&gt; 
  group_by(smoker) |&gt; 
  summarize(
    n = n(),
    mean_age = mean(age),
    min_age = min(age),
    max_age = max(age),
    sd_age = sd(age)
  ) |&gt; 
  complete(smoker)</code></pre>
<pre><code>## # A tibble: 2 × 6
##   smoker     n mean_age min_age max_age sd_age
##   &lt;fct&gt;  &lt;int&gt;    &lt;dbl&gt;   &lt;int&gt;   &lt;int&gt;  &lt;dbl&gt;
## 1 yes       NA       NA      NA      NA   NA  
## 2 no         5       60      34      88   21.6</code></pre>
</div>
</div>
<div id="joins-1" class="section level1" number="17">
<h1><span class="header-section-number">17</span> Joins</h1>
<div id="einleitung-13" class="section level2" number="17.1">
<h2><span class="header-section-number">17.1</span> Einleitung</h2>
<p>Es ist selten, dass du nur einen einzigen <em>Data Frame</em> hast.
Normalerweise hast du mehrere und du musst sie “joinen”, also
zusammenfügen. Es gibt zwei Arten von joins:</p>
<ul>
<li><strong>Mutating Joins</strong> - fügt neue Variablen einem <em>Data
Frame</em> hinzu, von <em>matching Observations</em> in einem
anderen.</li>
<li><strong>Filtering Joins</strong> - filtert Beobachtungen eines
<em>Data Frames</em>, je nachdem, ob sie eine Observation in einem
anderen matchen.</li>
</ul>
<div id="voraussetzungen-12" class="section level3" number="17.1.1">
<h3><span class="header-section-number">17.1.1</span>
Voraussetzungen</h3>
<pre class="r"><code>library(tidyverse)
library(nycflights13)</code></pre>
</div>
</div>
<div id="schlüssel---keys" class="section level2" number="17.2">
<h2><span class="header-section-number">17.2</span> Schlüssel -
Keys</h2>
<p>Zuerst müssen wir verstehen, wie zwei Tabellen miteinander verbunden
werden können. Dies durch ein Paar von Schlüsseln, die sich in jeder
Tabelle befinden.</p>
<div id="primärschlüssel-und-fremdschlüssel" class="section level3"
number="17.2.1">
<h3><span class="header-section-number">17.2.1</span> Primärschlüssel
und Fremdschlüssel</h3>
<p>Jedes “Join” involviert ein Paar von Schlüsseln: einen
Primärschlüssel und einen Fremdschlüssel. Ein Primärschlüssel ist eine
Variable, die jede Beobachtung eindeutig identifiziert. <strong>compound
key</strong> sind mehr als eine Variable.</p>
<p>In <code>airlines</code> finden wir zwei Variablen zu jeder Airline:
<em>carrier code</em> und <em>name</em>. Identifizieren lässt sich jede
Airline eindeutig durch den <em>carrier code</em>, so dass
<code>carrier</code> der Primärschlüssel ist.</p>
<pre class="r"><code>airlines</code></pre>
<pre><code>## # A tibble: 16 × 2
##    carrier name                       
##    &lt;chr&gt;   &lt;chr&gt;                      
##  1 9E      Endeavor Air Inc.          
##  2 AA      American Airlines Inc.     
##  3 AS      Alaska Airlines Inc.       
##  4 B6      JetBlue Airways            
##  5 DL      Delta Air Lines Inc.       
##  6 EV      ExpressJet Airlines Inc.   
##  7 F9      Frontier Airlines Inc.     
##  8 FL      AirTran Airways Corporation
##  9 HA      Hawaiian Airlines Inc.     
## 10 MQ      Envoy Air                  
## 11 OO      SkyWest Airlines Inc.      
## 12 UA      United Air Lines Inc.      
## 13 US      US Airways Inc.            
## 14 VX      Virgin America             
## 15 WN      Southwest Airlines Co.     
## 16 YV      Mesa Airlines Inc.</code></pre>
<p>In <code>airports</code> kann jeder Flughafen durch seinen
<em>airport code</em> identifiziert werden: <code>faa</code>.</p>
<pre class="r"><code>airports</code></pre>
<pre><code>## # A tibble: 1,458 × 8
##    faa   name                             lat    lon   alt    tz dst   tzone    
##    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;    
##  1 04G   Lansdowne Airport               41.1  -80.6  1044    -5 A     America/…
##  2 06A   Moton Field Municipal Airport   32.5  -85.7   264    -6 A     America/…
##  3 06C   Schaumburg Regional             42.0  -88.1   801    -6 A     America/…
##  4 06N   Randall Airport                 41.4  -74.4   523    -5 A     America/…
##  5 09J   Jekyll Island Airport           31.1  -81.4    11    -5 A     America/…
##  6 0A9   Elizabethton Municipal Airport  36.4  -82.2  1593    -5 A     America/…
##  7 0G6   Williams County Airport         41.5  -84.5   730    -5 A     America/…
##  8 0G7   Finger Lakes Regional Airport   42.9  -76.8   492    -5 A     America/…
##  9 0P2   Shoestring Aviation Airfield    39.8  -76.6  1000    -5 U     America/…
## 10 0S9   Jefferson County Intl           48.1 -123.    108    -8 A     America/…
## # ℹ 1,448 more rows</code></pre>
<p>In <code>planes</code> finden wir Infos zu jedem Flugzeug, das durch
<code>tailnum</code> eindeutig identifiziert werden kann.</p>
<pre class="r"><code>planes</code></pre>
<pre><code>## # A tibble: 3,322 × 9
##    tailnum  year type              manufacturer model engines seats speed engine
##    &lt;chr&gt;   &lt;int&gt; &lt;chr&gt;             &lt;chr&gt;        &lt;chr&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; 
##  1 N10156   2004 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…
##  2 N102UW   1998 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  3 N103US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  4 N104UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  5 N10575   2002 Fixed wing multi… EMBRAER      EMB-…       2    55    NA Turbo…
##  6 N105UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  7 N107US   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  8 N108UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
##  9 N109UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
## 10 N110UW   1999 Fixed wing multi… AIRBUS INDU… A320…       2   182    NA Turbo…
## # ℹ 3,312 more rows</code></pre>
<p><code>weather</code> liefert Daten zum Wetter an den Flughäfen.
<code>origin</code> und <code>time_hour</code> sind also hier der
<em>compound</em> Primärschlüssel.</p>
<pre class="r"><code>weather</code></pre>
<pre><code>## # A tibble: 26,115 × 15
##    origin  year month   day  hour  temp  dewp humid wind_dir wind_speed
##    &lt;chr&gt;  &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;
##  1 EWR     2013     1     1     1  39.0  26.1  59.4      270      10.4 
##  2 EWR     2013     1     1     2  39.0  27.0  61.6      250       8.06
##  3 EWR     2013     1     1     3  39.0  28.0  64.4      240      11.5 
##  4 EWR     2013     1     1     4  39.9  28.0  62.2      250      12.7 
##  5 EWR     2013     1     1     5  39.0  28.0  64.4      260      12.7 
##  6 EWR     2013     1     1     6  37.9  28.0  67.2      240      11.5 
##  7 EWR     2013     1     1     7  39.0  28.0  64.4      240      15.0 
##  8 EWR     2013     1     1     8  39.9  28.0  62.2      250      10.4 
##  9 EWR     2013     1     1     9  39.9  28.0  62.2      260      15.0 
## 10 EWR     2013     1     1    10  41    28.0  59.6      260      13.8 
## # ℹ 26,105 more rows
## # ℹ 5 more variables: wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;,
## #   visib &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Ein Fremdschlüssel ist eine Variable (oder mehrere), die zu mit einem
anderen Primärschlüssel in einer anderen Tabelle korrespondiert:</p>
<ul>
<li><p><code>flights$tailnum</code> ist Fremdschlüssel, der mit
Primärschlüssel <code>planes$tailnum</code> korrespondiert.</p></li>
<li><p><code>flights$carrier</code> zu
<code>airlines$carrier</code>.</p></li>
<li><p><code>flights$origin</code> zu
<code>airports$faa</code>.</p></li>
<li><p><code>flights$dest</code> zu <code>airports$faa</code>.</p></li>
<li><p><code>flights$origin-flights$time_hour</code> <em>compound
Fremdschlüssel</em>, der mit <em>compound</em> Primärschlüssel
<code>weather$origin-weather$time_hour</code> korrespondiert.</p></li>
</ul>
<div class="float">
<img
src="images/relational.png"
title="Primärschlüssel - Fremdschlüssel"
alt="Verbindung zwischen allen 5 Data Frames im nycflights13 Paket. PK grau, FK weiß." />
<div class="figcaption">Verbindung zwischen allen 5 Data Frames im
nycflights13 Paket. PK grau, FK weiß.</div>
</div>
</div>
<div id="primärschlüssel-checken" class="section level3"
number="17.2.2">
<h3><span class="header-section-number">17.2.2</span> Primärschlüssel
checken</h3>
<p>Sind sie wirklich einmalig, also die Beobachtungen?</p>
<pre class="r"><code>planes |&gt; 
  count(tailnum) |&gt; 
  filter(n &gt; 1)</code></pre>
<pre><code>## # A tibble: 0 × 2
## # ℹ 2 variables: tailnum &lt;chr&gt;, n &lt;int&gt;</code></pre>
<pre class="r"><code>weather |&gt; 
  count(time_hour, origin) |&gt; 
  filter(n &gt; 1)</code></pre>
<pre><code>## # A tibble: 0 × 3
## # ℹ 3 variables: time_hour &lt;dttm&gt;, origin &lt;chr&gt;, n &lt;int&gt;</code></pre>
<p>Checke auch nach <em>Missing Values</em>!</p>
<pre class="r"><code>planes |&gt; 
  filter(is.na(tailnum))</code></pre>
<pre><code>## # A tibble: 0 × 9
## # ℹ 9 variables: tailnum &lt;chr&gt;, year &lt;int&gt;, type &lt;chr&gt;, manufacturer &lt;chr&gt;,
## #   model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;</code></pre>
<pre class="r"><code>weather |&gt; 
  filter(is.na(time_hour) | is.na(origin))</code></pre>
<pre><code>## # A tibble: 0 × 15
## # ℹ 15 variables: origin &lt;chr&gt;, year &lt;int&gt;, month &lt;int&gt;, day &lt;int&gt;, hour &lt;int&gt;,
## #   temp &lt;dbl&gt;, dewp &lt;dbl&gt;, humid &lt;dbl&gt;, wind_dir &lt;dbl&gt;, wind_speed &lt;dbl&gt;,
## #   wind_gust &lt;dbl&gt;, precip &lt;dbl&gt;, pressure &lt;dbl&gt;, visib &lt;dbl&gt;,
## #   time_hour &lt;dttm&gt;</code></pre>
</div>
<div id="surrogat-schlüssel" class="section level3" number="17.2.3">
<h3><span class="header-section-number">17.2.3</span>
Surrogat-Schlüssel</h3>
<p>Welches ist eigentlich der Primärschlüssel für <code>flights</code>?
Es gibt drei Variablen, die zusammen jeden Flug eindeutig
identifizieren:</p>
<pre class="r"><code>flights |&gt; 
  count(time_hour, carrier, flight) |&gt; 
  filter(n &gt; 1)</code></pre>
<pre><code>## # A tibble: 0 × 4
## # ℹ 4 variables: time_hour &lt;dttm&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, n &lt;int&gt;</code></pre>
<p>Macht es die Abwesenheit von Duplikaten gleich zu einem guten
Primärschlüssel? Ich denke nicht. Hier aber schon, da es irritierend für
eine Fluglinie wäre, würden mehrere Flugzeuge mit derselben Flugnummer
zur selben Zeit abheben.</p>
<p>Abgesehen davon, können wir einen Surrogat-Schlüssel durch die
Zeilennummer konstruieren.</p>
<pre class="r"><code>flights2 &lt;- flights |&gt; 
  mutate(id = row_number(), .before = 1)
flights2</code></pre>
<pre><code>## # A tibble: 336,776 × 20
##       id  year month   day dep_time sched_dep_time dep_delay arr_time
##    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;    &lt;int&gt;          &lt;int&gt;     &lt;dbl&gt;    &lt;int&gt;
##  1     1  2013     1     1      517            515         2      830
##  2     2  2013     1     1      533            529         4      850
##  3     3  2013     1     1      542            540         2      923
##  4     4  2013     1     1      544            545        -1     1004
##  5     5  2013     1     1      554            600        -6      812
##  6     6  2013     1     1      554            558        -4      740
##  7     7  2013     1     1      555            600        -5      913
##  8     8  2013     1     1      557            600        -3      709
##  9     9  2013     1     1      557            600        -3      838
## 10    10  2013     1     1      558            600        -2      753
## # ℹ 336,766 more rows
## # ℹ 12 more variables: sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;,
## #   flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;,
## #   distance &lt;dbl&gt;, hour &lt;dbl&gt;, minute &lt;dbl&gt;, time_hour &lt;dttm&gt;</code></pre>
<p>Bei der Kommunikation zu einem anderen ist es einfach einfacher auf
Flug 2001 zu verweisen, als auf Flug UA43, Abflugzeit 9 Uhr, am
21.3.2006.</p>
</div>
</div>
<div id="basic-joins" class="section level2" number="17.3">
<h2><span class="header-section-number">17.3</span> Basic Joins</h2>
<p><strong>dplyr</strong> bietet sechs <code>join</code> Funktionen an:
<em>left, inner, right, full, semi, anti</em>.</p>
<div id="mutating-joins" class="section level3" number="17.3.1">
<h3><span class="header-section-number">17.3.1</span> Mutating
Joins</h3>
<p>Erlaubt uns Variablen von zwei <em>Data Frames</em> zu kombinieren.
Erst werden die Beobachtungen nach den Schlüsseln gematcht. Dann von
einem <em>Data Frame</em> Variablen in den anderen kopiert. Die neuen
Variablen werden rechts eingeordnet, so dass sie in der Console nicht
unbedingt sichtbar sind. Wir bauen uns ein Dataset mit sechs
Variablen.</p>
<pre class="r"><code>flights2 &lt;- flights |&gt; 
  select(year, time_hour, origin, dest, tailnum, carrier)
flights2</code></pre>
<pre><code>## # A tibble: 336,776 × 6
##     year time_hour           origin dest  tailnum carrier
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;  
##  1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     
##  2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     
##  3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     
##  4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     
##  5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     
##  6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     
##  7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6     
##  8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV     
##  9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6     
## 10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA     
## # ℹ 336,766 more rows</code></pre>
<p>Meist benutzt man den <code>left_join()</code>. Der Output hat immer
dieselbe Zeilenanzahl wie <code>x</code>. Der primäre Nutzen ist es
Metadaten hinzuzufügen. So können wir den kompletten Airline Namen zu
<code>flights2</code> hinzufügen.</p>
<pre class="r"><code>flights2 |&gt;
  left_join(airlines)</code></pre>
<pre><code>## Joining with `by = join_by(carrier)`</code></pre>
<pre><code>## # A tibble: 336,776 × 7
##     year time_hour           origin dest  tailnum carrier name                  
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;                 
##  1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines Inc. 
##  2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines Inc. 
##  3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines Inc.
##  4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways       
##  5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.  
##  6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines Inc. 
##  7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      JetBlue Airways       
##  8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      ExpressJet Airlines I…
##  9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      JetBlue Airways       
## 10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      American Airlines Inc.
## # ℹ 336,766 more rows</code></pre>
<p>Oder Wetterdaten zu den Abflugzeiten finden.</p>
<pre class="r"><code>flights2 |&gt; 
  left_join(weather |&gt; select(origin, time_hour, temp, wind_speed))</code></pre>
<pre><code>## Joining with `by = join_by(time_hour, origin)`</code></pre>
<pre><code>## # A tibble: 336,776 × 8
##     year time_hour           origin dest  tailnum carrier  temp wind_speed
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;      &lt;dbl&gt;
##  1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7
##  2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0
##  3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0
##  4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0
##  5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1
##  6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7
##  7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6       37.9       11.5
##  8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV       39.9       16.1
##  9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6       37.9       13.8
## 10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA       39.9       16.1
## # ℹ 336,766 more rows</code></pre>
<p>Die Flugzeuggröße.</p>
<pre class="r"><code>flights2 |&gt; 
  left_join(planes |&gt; select(tailnum, type, engines, seats))</code></pre>
<pre><code>## Joining with `by = join_by(tailnum)`</code></pre>
<pre><code>## # A tibble: 336,776 × 9
##     year time_hour           origin dest  tailnum carrier type     engines seats
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;int&gt; &lt;int&gt;
##  1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Fixed w…       2   149
##  2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      Fixed w…       2   149
##  3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Fixed w…       2   178
##  4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      Fixed w…       2   200
##  5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Fixed w…       2   178
##  6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Fixed w…       2   191
##  7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Fixed w…       2   200
##  8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      Fixed w…       2    55
##  9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      Fixed w…       2   200
## 10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;          NA    NA
## # ℹ 336,766 more rows</code></pre>
<p>Findet <code>left_join()</code> kein Match für eine Reihe in
<code>x</code>, so wird mit <code>NA</code> aufgefüllt.</p>
<pre class="r"><code>flights2 |&gt; 
  filter(tailnum == &quot;N3ALAA&quot;) |&gt; 
  left_join(planes |&gt; select(tailnum, type, engines, seats))</code></pre>
<pre><code>## Joining with `by = join_by(tailnum)`</code></pre>
<pre><code>## # A tibble: 63 × 9
##     year time_hour           origin dest  tailnum carrier type  engines seats
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt; &lt;int&gt;
##  1  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  2  2013 2013-01-02 18:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  3  2013 2013-01-03 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  4  2013 2013-01-07 19:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  5  2013 2013-01-08 17:00:00 JFK    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  6  2013 2013-01-16 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  7  2013 2013-01-20 18:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  8  2013 2013-01-22 17:00:00 JFK    ORD   N3ALAA  AA      &lt;NA&gt;       NA    NA
##  9  2013 2013-10-11 06:00:00 EWR    MIA   N3ALAA  AA      &lt;NA&gt;       NA    NA
## 10  2013 2013-10-14 08:00:00 JFK    BOS   N3ALAA  AA      &lt;NA&gt;       NA    NA
## # ℹ 53 more rows</code></pre>
</div>
<div id="spezifizieren-von-join-schlüsseln" class="section level3"
number="17.3.2">
<h3><span class="header-section-number">17.3.2</span> Spezifizieren von
Join-Schlüsseln</h3>
<p><code>left_join()</code> benutzt immer Variablen, die in beiden
<em>Data Frames</em> auftauchen als Join Key: <strong>natural</strong>
<code>join</code>. Manchmal funktioniert es nicht. So können Variablen
mit gleichem Namen in verschiedenen Datensätzen eine andere Bedeutung
haben.</p>
<pre class="r"><code>flights2 |&gt; 
  left_join(planes)</code></pre>
<pre><code>## Joining with `by = join_by(year, tailnum)`</code></pre>
<pre><code>## # A tibble: 336,776 × 13
##     year time_hour           origin dest  tailnum carrier type  manufacturer
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt;       
##  1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      &lt;NA&gt;  &lt;NA&gt;        
##  2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      &lt;NA&gt;  &lt;NA&gt;        
##  3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      &lt;NA&gt;  &lt;NA&gt;        
##  4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;  &lt;NA&gt;        
##  5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      &lt;NA&gt;  &lt;NA&gt;        
##  6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      &lt;NA&gt;  &lt;NA&gt;        
##  7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      &lt;NA&gt;  &lt;NA&gt;        
##  8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      &lt;NA&gt;  &lt;NA&gt;        
##  9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      &lt;NA&gt;  &lt;NA&gt;        
## 10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      &lt;NA&gt;  &lt;NA&gt;        
## # ℹ 336,766 more rows
## # ℹ 5 more variables: model &lt;chr&gt;, engines &lt;int&gt;, seats &lt;int&gt;, speed &lt;int&gt;,
## #   engine &lt;chr&gt;</code></pre>
<p>Hier hat <code>year</code> in beiden Datensätzen eine andere
Bedeutung. <code>flight$year</code> ist das Jahr, in dem der Flug
stattgefunden hat. <code>planes$year</code> ist das Jahr, in dem das
Flugzeug gebaut wurde. Wir wollen aber nur auf <code>tailnum</code>
joinen, also müssen wir eine explizite Spezifiation anbieten, mit
<code>join_by()</code>.</p>
<pre class="r"><code>flights2 |&gt; 
 # left_join(planes, join_by(tailnum)) muss noch aktualisiert werden
  left_join(planes, by = &quot;tailnum&quot;)</code></pre>
<pre><code>## # A tibble: 336,776 × 14
##    year.x time_hour           origin dest  tailnum carrier year.y type          
##     &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;    &lt;int&gt; &lt;chr&gt;         
##  1   2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA        1999 Fixed wing mu…
##  2   2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA        1998 Fixed wing mu…
##  3   2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA        1990 Fixed wing mu…
##  4   2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6        2012 Fixed wing mu…
##  5   2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL        1991 Fixed wing mu…
##  6   2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA        2012 Fixed wing mu…
##  7   2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6        2000 Fixed wing mu…
##  8   2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV        1998 Fixed wing mu…
##  9   2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6        2004 Fixed wing mu…
## 10   2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA          NA &lt;NA&gt;          
## # ℹ 336,766 more rows
## # ℹ 6 more variables: manufacturer &lt;chr&gt;, model &lt;chr&gt;, engines &lt;int&gt;,
## #   seats &lt;int&gt;, speed &lt;int&gt;, engine &lt;chr&gt;</code></pre>
<p>Die Variablen <code>year</code> wurden im gemeinsamen Datensatz jetzt
optisch eindeutig gemacht, mit einem Zusatz (<code>year.x</code>,
<code>year.y</code>), der genau sagt, wo die Variable herkommt: von
<code>x</code> oder von <code>y</code>. Du kannst das Suffix natürlich
überschreiben.<br />
<code>by = "tailnum"</code> steht kurz für
<code>by = c("tailnum" = "tailnum")</code> (evtl.
<code>join_by(tailnum)</code> für
<code>join_by(tailnum == tailnum)</code>).</p>
<p>Es gibt zwei Möglichkeiten die <code>flights2</code> und die
<code>airports</code> Tabelle zu verbinden: über <code>dest</code> oder
über <code>origin</code>.</p>
<pre class="r"><code>flights2 |&gt; 
  left_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;))</code></pre>
<pre><code>## # A tibble: 336,776 × 13
##     year time_hour           origin dest  tailnum carrier name         lat   lon
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;
##  1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      George Bu…  30.0 -95.3
##  2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      George Bu…  30.0 -95.3
##  3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Miami Intl  25.8 -80.3
##  4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      &lt;NA&gt;        NA    NA  
##  5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Hartsfiel…  33.6 -84.4
##  6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Chicago O…  42.0 -87.9
##  7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Fort Laud…  26.1 -80.2
##  8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      Washingto…  38.9 -77.5
##  9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      Orlando I…  28.4 -81.3
## 10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      Chicago O…  42.0 -87.9
## # ℹ 336,766 more rows
## # ℹ 4 more variables: alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;</code></pre>
<pre class="r"><code>flights2 |&gt; 
  left_join(airports, by = c(&quot;origin&quot; = &quot;faa&quot;))</code></pre>
<pre><code>## # A tibble: 336,776 × 13
##     year time_hour           origin dest  tailnum carrier name         lat   lon
##    &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;
##  1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Li…  40.7 -74.2
##  2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia  40.8 -73.9
##  3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Ke…  40.6 -73.8
##  4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Ke…  40.6 -73.8
##  5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia  40.8 -73.9
##  6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Li…  40.7 -74.2
##  7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Newark Li…  40.7 -74.2
##  8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      La Guardia  40.8 -73.9
##  9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      John F Ke…  40.6 -73.8
## 10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      La Guardia  40.8 -73.9
## # ℹ 336,766 more rows
## # ℹ 4 more variables: alt &lt;dbl&gt;, tz &lt;dbl&gt;, dst &lt;chr&gt;, tzone &lt;chr&gt;</code></pre>
</div>
<div id="joins-filtern" class="section level3" number="17.3.3">
<h3><span class="header-section-number">17.3.3</span> Joins filtern</h3>
<p><strong>Semi-Joins</strong> behalten alle Reihen in <code>x</code>,
die ein Match in <code>y</code> haben. So können wir alle Flughäfen
anzeigen, die passenden Origin haben:</p>
<pre class="r"><code>airports |&gt; 
  semi_join(flights2, by = c(&quot;faa&quot; = &quot;origin&quot;))</code></pre>
<pre><code>## # A tibble: 3 × 8
##   faa   name                  lat   lon   alt    tz dst   tzone           
##   &lt;chr&gt; &lt;chr&gt;               &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;           
## 1 EWR   Newark Liberty Intl  40.7 -74.2    18    -5 A     America/New_York
## 2 JFK   John F Kennedy Intl  40.6 -73.8    13    -5 A     America/New_York
## 3 LGA   La Guardia           40.8 -73.9    22    -5 A     America/New_York</code></pre>
<p>Oder natürlich eine passenden Destination.</p>
<pre class="r"><code>airports |&gt; 
  semi_join(flights2, by = c(&quot;faa&quot; = &quot;dest&quot;))</code></pre>
<pre><code>## # A tibble: 101 × 8
##    faa   name                                lat    lon   alt    tz dst   tzone 
##    &lt;chr&gt; &lt;chr&gt;                             &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; 
##  1 ABQ   Albuquerque International Sunport  35.0 -107.   5355    -7 A     Ameri…
##  2 ACK   Nantucket Mem                      41.3  -70.1    48    -5 A     Ameri…
##  3 ALB   Albany Intl                        42.7  -73.8   285    -5 A     Ameri…
##  4 ANC   Ted Stevens Anchorage Intl         61.2 -150.    152    -9 A     Ameri…
##  5 ATL   Hartsfield Jackson Atlanta Intl    33.6  -84.4  1026    -5 A     Ameri…
##  6 AUS   Austin Bergstrom Intl              30.2  -97.7   542    -6 A     Ameri…
##  7 AVL   Asheville Regional Airport         35.4  -82.5  2165    -5 A     Ameri…
##  8 BDL   Bradley Intl                       41.9  -72.7   173    -5 A     Ameri…
##  9 BGR   Bangor Intl                        44.8  -68.8   192    -5 A     Ameri…
## 10 BHM   Birmingham Intl                    33.6  -86.8   644    -6 A     Ameri…
## # ℹ 91 more rows</code></pre>
<p>Anti-Joins sind das Gegenteil. Sie geben alle Reihen in
<code>x</code> aus, die kein Match in <code>y</code> haben.</p>
<pre class="r"><code>flights2 |&gt; 
  anti_join(airports, by = c(&quot;dest&quot; = &quot;faa&quot;)) |&gt; 
  distinct(dest)</code></pre>
<pre><code>## # A tibble: 4 × 1
##   dest 
##   &lt;chr&gt;
## 1 BQN  
## 2 SJU  
## 3 STT  
## 4 PSE</code></pre>
<p>Welche <code>tailnum</code> fehlen in <code>planes</code>? Sie sind
in <code>flights2</code>, aber nicht in <code>planes</code>.</p>
<pre class="r"><code>flights2 |&gt;
  anti_join(planes, by = &quot;tailnum&quot;) |&gt; 
  distinct(tailnum)</code></pre>
<pre><code>## # A tibble: 722 × 1
##    tailnum
##    &lt;chr&gt;  
##  1 N3ALAA 
##  2 N3DUAA 
##  3 N542MQ 
##  4 N730MQ 
##  5 N9EAMQ 
##  6 N532UA 
##  7 N3EMAA 
##  8 N518MQ 
##  9 N3BAAA 
## 10 N3CYAA 
## # ℹ 712 more rows</code></pre>
</div>
</div>
<div id="wie-funktionieren-joins" class="section level2" number="17.4">
<h2><span class="header-section-number">17.4</span> Wie funktionieren
Joins?</h2>
<pre class="r"><code>x &lt;- tribble(
  ~key, ~val_x,
     1, &quot;x1&quot;,
     2, &quot;x2&quot;,
     3, &quot;x3&quot;
)
y &lt;- tribble(
  ~key, ~val_y,
     1, &quot;y1&quot;,
     2, &quot;y2&quot;,
     4, &quot;y3&quot;
)
x</code></pre>
<pre><code>## # A tibble: 3 × 2
##     key val_x
##   &lt;dbl&gt; &lt;chr&gt;
## 1     1 x1   
## 2     2 x2   
## 3     3 x3</code></pre>
<pre class="r"><code>y</code></pre>
<pre><code>## # A tibble: 3 × 2
##     key val_y
##   &lt;dbl&gt; &lt;chr&gt;
## 1     1 y1   
## 2     2 y2   
## 3     4 y3</code></pre>
<p>Beim <em>Inner Join</em> matchen Reihen, wenn die Schlüssel gleich
sind. Also enthält der Output nur Reihen mit Schlüsseln, die in
<code>x</code> und <code>y</code> enthalten sind.</p>
<pre class="r"><code>inner_join(x, y)</code></pre>
<pre><code>## Joining with `by = join_by(key)`</code></pre>
<pre><code>## # A tibble: 2 × 3
##     key val_x val_y
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 x1    y1   
## 2     2 x2    y2</code></pre>
<p>Ein <em>Outer Join</em> behält Beobachtungen, die in mindestens einem
der <em>Data Frames</em> auftauchen. Diese Beobachtung hat einen
Schlüsel, der matcht, wenn es kein anderer Schlüssel tut. Ein
<code>NA</code> wird dann erstellt. Drei <em>Outer Joins</em>
existieren:</p>
<ul>
<li><em>Left Join</em> behält alle Beobachtungen in <code>x</code>. Jede
Reihe von <code>x</code> wird beibehalten im Output.</li>
</ul>
<pre class="r"><code>left_join(x, y)</code></pre>
<pre><code>## Joining with `by = join_by(key)`</code></pre>
<pre><code>## # A tibble: 3 × 3
##     key val_x val_y
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 x1    y1   
## 2     2 x2    y2   
## 3     3 x3    &lt;NA&gt;</code></pre>
<ul>
<li><em>Right Join</em> behält alle Beobachtungen in
<code>y</code>.</li>
</ul>
<pre class="r"><code>right_join(x, y)</code></pre>
<pre><code>## Joining with `by = join_by(key)`</code></pre>
<pre><code>## # A tibble: 3 × 3
##     key val_x val_y
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 x1    y1   
## 2     2 x2    y2   
## 3     4 &lt;NA&gt;  y3</code></pre>
<ul>
<li><em>Full Join</em> behält alle Beobachtungen, die in <code>x</code>
oder <code>y</code> anfallen. Jede Reihe von <code>x</code> und
<code>y</code> ist im Output vorhanden. Der Output fängt mit allen
Reihen von <code>x</code> an, dann folgen die verbliebenden von
<code>y</code>.</li>
</ul>
<pre class="r"><code>full_join(x, y)</code></pre>
<pre><code>## Joining with `by = join_by(key)`</code></pre>
<pre><code>## # A tibble: 4 × 3
##     key val_x val_y
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 x1    y1   
## 2     2 x2    y2   
## 3     3 x3    &lt;NA&gt; 
## 4     4 &lt;NA&gt;  y3</code></pre>
<div id="row-matching" class="section level3" number="17.4.1">
<h3><span class="header-section-number">17.4.1</span> Row Matching</h3>
<p>Was passiert, wenn eine Reihe in <code>x</code> zu mehr als einer
Reihe in <code>y</code> matcht?</p>
<p>Es kann sein, dass eine Reihe in <code>x</code>:</p>
<ul>
<li>nicht matcht. Sie entfällt.</li>
<li>zu einer Reihe matcht.</li>
<li>zu mehr als einer Reihe in <code>y</code> matcht. Sie wird
dupliziert.</li>
</ul>
<p><strong>dplyr</strong> warnt uns, wann immer es multiple Matches
gibt.</p>
<pre class="r"><code>df1 &lt;- tibble(key = c(1, 2, 3), val_x = c(&quot;x1&quot;, &quot;x2&quot;, &quot;x3&quot;))
df2 &lt;- tibble(key = c(1, 2, 4), val_y = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;))
df1</code></pre>
<pre><code>## # A tibble: 3 × 2
##     key val_x
##   &lt;dbl&gt; &lt;chr&gt;
## 1     1 x1   
## 2     2 x2   
## 3     3 x3</code></pre>
<pre class="r"><code>df2</code></pre>
<pre><code>## # A tibble: 3 × 2
##     key val_y
##   &lt;dbl&gt; &lt;chr&gt;
## 1     1 y1   
## 2     2 y2   
## 3     4 y3</code></pre>
<pre class="r"><code>df1 |&gt; 
  inner_join(df2, by = &quot;key&quot;)</code></pre>
<pre><code>## # A tibble: 2 × 3
##     key val_x val_y
##   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 x1    y1   
## 2     2 x2    y2</code></pre>
</div>
</div>
</div>
<div id="programmieren-funktionen" class="section level1" number="18">
<h1><span class="header-section-number">18</span> Programmieren:
Funktionen</h1>
<div id="einleitung-14" class="section level2" number="18.1">
<h2><span class="header-section-number">18.1</span> Einleitung</h2>
<p>In unserem eraten Abschnitt haben wir schon Funktionen eingeführt.
Hier noch ein wenig intensiver. Funktionen erlauben es dir gewöhnliche
Aufgaben zu automatisieren. Gegenüber <em>copy-paste</em> hat es drei
Vorteile:</p>
<ol style="list-style-type: decimal">
<li><p>Verpasse deiner Funktion einen Namen, so dass er einfacher zu
verstehen ist.</p></li>
<li><p>Verändern sich Voraussetzungen, so musst du Code nur an einem Ort
aktualisieren, statt an vielen.</p></li>
<li><p>Du verringerst die Chance gleiche Fehler wiederholt zu
machen.</p></li>
</ol>
<p>In diesem Abschnitt lernen wir drei Typen von Funktionen kennen:</p>
<ul>
<li><p>Vektor-Funktionen, die einen oder mehrere Vektoren als Input
nehmen und einen Vektor als Output ausgeben.</p></li>
<li><p><em>Data Frame</em> Funktionen, die einen <em>Data Frame</em> als
Input nehmen und einen <em>Data Frame</em> als Output ausgeben.</p></li>
<li><p>Plot-Funktionen, die einen <em>Data Frame</em> als Input nehmen
und einen Plot als Output.</p></li>
</ul>
<div id="voraussetzungen-13" class="section level3" number="18.1.1">
<h3><span class="header-section-number">18.1.1</span>
Voraussetzungen</h3>
<pre class="r"><code>library(tidyverse)
library(nycflights13)</code></pre>
</div>
</div>
<div id="vektor-funktionen" class="section level2" number="18.2">
<h2><span class="header-section-number">18.2</span>
Vektor-Funktionen</h2>
<pre class="r"><code>df &lt;- tibble(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5),
  d = rnorm(5),
)
df</code></pre>
<pre><code>## # A tibble: 5 × 4
##         a      b      c       d
##     &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1  0.428   0.549  0.672 -1.14  
## 2  0.177  -1.55   1.16  -0.960 
## 3 -0.0642 -0.144  0.171 -1.33  
## 4 -1.69   -3.31   1.09   1.09  
## 5  0.964   2.27  -0.212 -0.0656</code></pre>
<pre class="r"><code>df |&gt; mutate(
  a = (a - min(a, na.rm = TRUE)) / 
    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),
  b = (b - min(b, na.rm = TRUE)) / 
    (max(b, na.rm = TRUE) - min(a, na.rm = TRUE)),
  c = (c - min(c, na.rm = TRUE)) / 
    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),
  d = (d - min(d, na.rm = TRUE)) / 
    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),
)</code></pre>
<pre><code>## # A tibble: 5 × 4
##       a     b     c      d
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1 0.798 1.70  0.643 0.0773
## 2 0.703 0.775 1     0.153 
## 3 0.612 1.39  0.279 0     
## 4 0     0     0.948 1     
## 5 1     2.46  0     0.523</code></pre>
<p>Alle Vektoren sollten zwischen 0 und 1 liegen. Tun sie aber nicht.
Copy-Paste hat für <code>b</code> zu einem Fehler geführt. Also besser
Funktionen schreiben.</p>
<div id="funktionen-schreiben" class="section level3" number="18.2.1">
<h3><span class="header-section-number">18.2.1</span> Funktionen
schreiben</h3>
<p>Welche Teile des Codes sind jetzt konstant und welche variieren?</p>
<pre class="r"><code>(a - min(a, na.rm = TRUE)) / (max(a, na.rm = TRUE) - min(a, na.rm = TRUE))
(b - min(b, na.rm = TRUE)) / (max(b, na.rm = TRUE) - min(b, na.rm = TRUE))
(c - min(c, na.rm = TRUE)) / (max(c, na.rm = TRUE) - min(c, na.rm = TRUE))
(d - min(d, na.rm = TRUE)) / (max(d, na.rm = TRUE) - min(d, na.rm = TRUE))  </code></pre>
<p>In jeder Zeile sind es genau vier Buchstaben (jeweils: a, b, c,
d).</p>
<pre class="r"><code>(█ - min(█, na.rm = TRUE)) / (max(█, na.rm = TRUE) - min(█, na.rm = TRUE))</code></pre>
<p>Um daraus eine Funktion zu machen, bedarf es drei Dinge:</p>
<ol style="list-style-type: decimal">
<li>Name. Zum Beispiel <code>rescale01</code>, weil die Funktion einen
Vektor in ein Intervall zwischen 0 und 1 packt.</li>
<li>Argumente.</li>
<li><em>Body</em>. Der Code kommt hier herein.</li>
</ol>
<p>Ein Template sieht dann wie folgt aus:</p>
<pre class="r"><code>name &lt;- function(arguments) {
  body
}</code></pre>
<p>Er führt dann zu:</p>
<pre class="r"><code>rescale01 &lt;- function(x) {
  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))
}
rescale01(c(-10, 0, 10))</code></pre>
<pre><code>## [1] 0.0 0.5 1.0</code></pre>
<pre class="r"><code>rescale01(c(1, 2, 3, NA, 5))</code></pre>
<pre><code>## [1] 0.00 0.25 0.50   NA 1.00</code></pre>
<p>Mithilfe von <code>mutate()</code>:</p>
<pre class="r"><code>df |&gt; mutate(
  a = rescale01(a),
  b = rescale01(b),
  c = rescale01(c),
  d = rescale01(d),
)</code></pre>
<pre><code>## # A tibble: 5 × 4
##       a     b     c      d
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1 0.798 0.691 0.643 0.0773
## 2 0.703 0.315 1     0.153 
## 3 0.612 0.567 0.279 0     
## 4 0     0     0.948 1     
## 5 1     1     0     0.523</code></pre>
</div>
<div id="funktion-weiterentwickeln" class="section level3"
number="18.2.2">
<h3><span class="header-section-number">18.2.2</span> Funktion
weiterentwickeln</h3>
<p>Mithilfe von <code>range()</code> können wir schnell das Minimum und
das Maximum berechnen.</p>
<pre class="r"><code>rescale01 &lt;- function(x) {
  rng &lt;- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}</code></pre>
<p>Liegt ein unendlicher Wert vor, so haben wir ein Problem.</p>
<pre class="r"><code>x &lt;- c(1:10, Inf)
rescale01(x)</code></pre>
<pre><code>##  [1]   0   0   0   0   0   0   0   0   0   0 NaN</code></pre>
<p>Wir sagen also <code>range()</code> unendliche Werte bitte zu
ignorieren.</p>
<pre class="r"><code>rescale01 &lt;- function(x) {
  rng &lt;- range(x, na.rm = TRUE, finite = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

rescale01(x)</code></pre>
<pre><code>##  [1] 0.0000000 0.1111111 0.2222222 0.3333333 0.4444444 0.5555556 0.6666667
##  [8] 0.7777778 0.8888889 1.0000000       Inf</code></pre>
</div>
<div id="mutate-funktionen" class="section level3" number="18.2.3">
<h3><span class="header-section-number">18.2.3</span> Mutate
Funktionen</h3>
<p>Wir wollen den <em>z-Score</em> berechnen. <code>mutate()</code>
bietet sich hier an, da sie dieselbe Länge (wie der Input) ausgeben.</p>
<pre class="r"><code>z_score &lt;- function(x) {
  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)
}
z_score(c(2,3,3,4))</code></pre>
<pre><code>## [1] -1.224745  0.000000  0.000000  1.224745</code></pre>
<p>Mit <code>case_when()</code> können wir Werte ausgeben, die sich
innerhalb eines Intervalls befinden.</p>
<pre class="r"><code># .default = x funktioniert nicht, auch nicht mit 1:10
clamp &lt;- function(x, min, max) {
  case_when(
    x &lt; min ~ min,
    x &gt; max ~ max,
    .default = x
  )
}

clamp(1:10, min = 3, max = 7)</code></pre>
<pre><code>##  [1] 3 3 3 4 5 6 7 7 7 7</code></pre>
<pre class="r"><code>clamp &lt;- function(x, min, max) {
  case_when(
    x &lt; min ~ 3,
    x &gt; max ~ 7,
    TRUE ~ x
  )
}

clamp(seq(1, 10, 1), min = 3, max = 7)</code></pre>
<pre><code>##  [1] 3 3 3 4 5 6 7 7 7 7</code></pre>
<p>Willst du Dollarzeichen, Prozentzeichen, Komma von einem
<em>String</em> entfernen?</p>
<pre class="r"><code>clean_number &lt;- function(x) {
    is_pct &lt;- str_detect(x, &quot;%&quot;)
    num &lt;- x |&gt; 
    str_remove_all(&quot;[%]&quot;) |&gt; 
    str_remove_all(&quot;,&quot;) |&gt; 
    str_remove_all(&quot;[$]&quot;) |&gt; 
    as.numeric(x)
  if_else(is_pct, num / 100, num)
}

clean_number(&quot;$12,300&quot;)</code></pre>
<pre><code>## [1] 12300</code></pre>
<pre class="r"><code>clean_number(&quot;45%&quot;)</code></pre>
<pre><code>## [1] 0.45</code></pre>
<p>Ersetze einen Vektor durch <code>NA</code>, wenn bestimmte Zahlen
vorkommen.</p>
<pre class="r"><code>fix_na &lt;- function(x) {
  ifelse(x %in% c(997, 998, 999), NA, x)
}
fix_na(seq(990,1001,1))</code></pre>
<pre><code>##  [1]  990  991  992  993  994  995  996   NA   NA   NA 1000 1001</code></pre>
<p>Unsere Funktion kann aber natürlich auch mehrere Vektoren als
Argumente aufnehmen.</p>
<pre class="r"><code>haversine &lt;- function(long1, lat1, long2, lat2, round = 3) {
  # convert to radians
  long1 &lt;- long1 * pi / 180
  lat1  &lt;- lat1  * pi / 180
  long2 &lt;- long2 * pi / 180
  lat2  &lt;- lat2  * pi / 180
  
  R &lt;- 6371 # Earth mean radius in km
  a &lt;- sin((lat2 - lat1) / 2)^2 + 
    cos(lat1) * cos(lat2) * sin((long2 - long1) / 2)^2
  d &lt;- R * 2 * asin(sqrt(a))
  
  round(d, round)
}</code></pre>
</div>
<div id="zusammenfassende-funktionen-summary-functions"
class="section level3" number="18.2.4">
<h3><span class="header-section-number">18.2.4</span> Zusammenfassende
Funktionen (Summary Functions)</h3>
<p>Summary Functions geben einen einzelnen Wert aus
(<code>summarize()</code>).</p>
<pre class="r"><code>commas &lt;- function(x) {
  str_flatten(x, collapse = &quot;, &quot;, last = &quot; and &quot;)
}

commas(c(&quot;cat&quot;, &quot;dog&quot;, &quot;pigeon&quot;))</code></pre>
<pre><code>## [1] &quot;cat, dog and pigeon&quot;</code></pre>
<p>Berechne den Variationskoeffizienten:</p>
<pre class="r"><code>cv &lt;- function(x, na.rm = FALSE) {
  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)
}

cv(runif(100, min = 0, max = 50))</code></pre>
<pre><code>## [1] 0.6416063</code></pre>
<pre class="r"><code>cv(runif(100, min = 0, max = 500))</code></pre>
<pre><code>## [1] 0.5875608</code></pre>
<p>Wieviele <em>Missing Values</em>? Verpasse immer einen Namen, an den
du dich erinnern kannst.</p>
<pre class="r"><code>n_missing &lt;- function(x) {
  sum(is.na(x))
} 
n_missing(c(2,3,4,NA,NA,5))</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Vergleiche zwei Vektoren miteinander.</p>
<pre class="r"><code>mape &lt;- function(actual, predicted) {
  sum(abs((actual - predicted) / actual)) / length(actual)
}
mape(c(1,2,3,2,3,4,2), c(2,3,2,3,4,4,2))</code></pre>
<pre><code>## [1] 0.3809524</code></pre>
</div>
<div id="data-frame-funktionen" class="section level3" number="18.2.5">
<h3><span class="header-section-number">18.2.5</span> Data Frame
Funktionen</h3>
<p>Vektorfunktionen sind nützlich, um Code herauszuziehen, der innerhalb
eines dplyr-Verbs wiederholt wird. Aber oft wiederholen Sie auch die
Verben selbst, insbesondere in einer großen <em>Pipe</em>. Wenn Sie
feststellen, dass Sie mehrere Verben mehrmals kopieren und einfügen,
sollten Sie über das Schreiben einer <em>Data Frame</em> Funktion
nachdenken. Sie funktionieren ähnlich wie dplyr-Verben: Sie nehmen einen
<em>Data Frame</em> als erstes Argument, einige zusätzliche Argumente,
die angeben, was damit gemacht werden soll, und geben einen <em>Data
Frame</em> oder Vektor zurück.</p>
</div>
<div id="indirection-and-tidy-evaluation" class="section level3"
number="18.2.6">
<h3><span class="header-section-number">18.2.6</span> Indirection and
Tidy Evaluation</h3>
<p>Bei Verwendung von <strong>dolyr</strong> Verben und Funktionen,
stößt man schnell auf Probleme.</p>
<pre class="r"><code>grouped_mean &lt;- function(df, group_var, mean_var) {
  df |&gt; 
    group_by(group_var) |&gt; 
    summarize(mean(mean_var))
}</code></pre>
<pre class="r"><code>diamonds |&gt; grouped_mean(cut, carat)
#&gt; Error in `group_by()`:
#&gt; ! Must group by variables found in `.data`.
#&gt; ✖ Column `group_var` is not found.</code></pre>
<p>Machen wir es ein wenig deutlicher.</p>
<pre class="r"><code>df &lt;- tibble(
  mean_var = 1,
  group_var = &quot;g&quot;,
  group = 1,
  x = 10,
  y = 100
)

df |&gt; grouped_mean(group, x)</code></pre>
<pre><code>## # A tibble: 1 × 2
##   group_var `mean(mean_var)`
##   &lt;chr&gt;                &lt;dbl&gt;
## 1 g                        1</code></pre>
<pre class="r"><code>#&gt; # A tibble: 1 × 2
#&gt;   group_var `mean(mean_var)`
#&gt;   &lt;chr&gt;                &lt;dbl&gt;
#&gt; 1 g                        1
df |&gt; grouped_mean(group, y)</code></pre>
<pre><code>## # A tibble: 1 × 2
##   group_var `mean(mean_var)`
##   &lt;chr&gt;                &lt;dbl&gt;
## 1 g                        1</code></pre>
<pre class="r"><code>#&gt; # A tibble: 1 × 2
#&gt;   group_var `mean(mean_var)`
#&gt;   &lt;chr&gt;                &lt;dbl&gt;
#&gt; 1 g                        1</code></pre>
<p>Egal wie wir <code>grouped_mean()</code> nennen, es macht
<code>|&gt; group_by(group_var)</code>
<code>|&gt; summarize(mean(mean_var))</code>, statt
<code>df |&gt; group_by(group)</code>
<code>|&gt; summarize(mean(x))</code>. <strong>Embracing</strong>
bedeutet, dass die Variable in geschweifte Klammern gepackt wird.</p>
<pre class="r"><code>grouped_mean &lt;- function(df, group_var, mean_var) {
  df |&gt; 
    group_by({{ group_var }}) |&gt; 
    summarize(mean({{ mean_var }}))
}

df |&gt; grouped_mean(group, x)</code></pre>
<pre><code>## # A tibble: 1 × 2
##   group `mean(x)`
##   &lt;dbl&gt;     &lt;dbl&gt;
## 1     1        10</code></pre>
</div>
<div id="wann-embrace" class="section level3" number="18.2.7">
<h3><span class="header-section-number">18.2.7</span> Wann
<em>Embrace</em>?</h3>
<p>Die Lösung findest du in der Dokumentation. *
<strong>Data-masking</strong>: <code>arrange()</code>,
<code>filter()</code>, <code>summarize()</code>. *
<strong>Tidy-selection</strong>: <code>select()</code>,
<code>relocate()</code>, <code>rename()</code>.</p>
</div>
<div id="gewöhnliche-anwendungsfälle" class="section level3"
number="18.2.8">
<h3><span class="header-section-number">18.2.8</span> Gewöhnliche
Anwendungsfälle</h3>
<pre class="r"><code>summary6 &lt;- function(data, var) {
  data |&gt; summarize(
    min = min({{ var }}, na.rm = TRUE),
    mean = mean({{ var }}, na.rm = TRUE),
    median = median({{ var }}, na.rm = TRUE),
    max = max({{ var }}, na.rm = TRUE),
    n = n(),
    n_miss = sum(is.na({{ var }})),
    .groups = &quot;drop&quot;
  )
}

diamonds |&gt; summary6(carat)</code></pre>
<pre><code>## # A tibble: 1 × 6
##     min  mean median   max     n n_miss
##   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;
## 1   0.2 0.798    0.7  5.01 53940      0</code></pre>
<p>Das Schöne an dieser Funktion ist, dass wir sie auf gruppierten Daten
verwenden können, da sie <code>summarize()</code> umschließt.</p>
<pre class="r"><code>diamonds |&gt; 
  group_by(cut) |&gt; 
  summary6(carat)</code></pre>
<pre><code>## # A tibble: 5 × 7
##   cut         min  mean median   max     n n_miss
##   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;
## 1 Fair       0.22 1.05    1     5.01  1610      0
## 2 Good       0.23 0.849   0.82  3.01  4906      0
## 3 Very Good  0.2  0.806   0.71  4    12082      0
## 4 Premium    0.2  0.892   0.86  4.01 13791      0
## 5 Ideal      0.2  0.703   0.54  3.5  21551      0</code></pre>
<p>Berechnete Variablen können wir so auch mit <code>summarize</code>
benutzen.</p>
<pre class="r"><code>diamonds |&gt; 
  group_by(cut) |&gt; 
  summary6(log10(carat))</code></pre>
<pre><code>## # A tibble: 5 × 7
##   cut          min    mean  median   max     n n_miss
##   &lt;ord&gt;      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;  &lt;int&gt;
## 1 Fair      -0.658 -0.0273  0      0.700  1610      0
## 2 Good      -0.638 -0.133  -0.0862 0.479  4906      0
## 3 Very Good -0.699 -0.164  -0.149  0.602 12082      0
## 4 Premium   -0.699 -0.125  -0.0655 0.603 13791      0
## 5 Ideal     -0.699 -0.225  -0.268  0.544 21551      0</code></pre>
<p>Auch <code>count()</code> ist nützlich und berechnet Anteile.</p>
<pre class="r"><code>count_prop &lt;- function(df, var, sort = FALSE) {
  df |&gt;
    count({{ var }}, sort = sort) |&gt;
    mutate(prop = n / sum(n))
}

diamonds |&gt; count_prop(clarity)</code></pre>
<pre><code>## # A tibble: 8 × 3
##   clarity     n   prop
##   &lt;ord&gt;   &lt;int&gt;  &lt;dbl&gt;
## 1 I1        741 0.0137
## 2 SI2      9194 0.170 
## 3 SI1     13065 0.242 
## 4 VS2     12258 0.227 
## 5 VS1      8171 0.151 
## 6 VVS2     5066 0.0939
## 7 VVS1     3655 0.0678
## 8 IF       1790 0.0332</code></pre>
<p>Nur das zweite Argument der drei: <code>df</code>, <code>var</code>,
<code>sort</code> muss umklammert werden, da <code>count()</code>
<em>data-masking</em> für alle Variablen benutzt. <code>sort</code> hat
als <em>default</em> (Wert) <code>FALSE</code>.</p>
<pre class="r"><code>unique_where &lt;- function(df, condition, var) {
  df |&gt; 
    filter({{ condition }}) |&gt; 
    distinct({{ var }}) |&gt; 
    arrange({{ var }})
}

# Find all the destinations in December
flights |&gt; unique_where(month == 12, dest)</code></pre>
<pre><code>## # A tibble: 96 × 1
##    dest 
##    &lt;chr&gt;
##  1 ABQ  
##  2 ALB  
##  3 ATL  
##  4 AUS  
##  5 AVL  
##  6 BDL  
##  7 BGR  
##  8 BHM  
##  9 BNA  
## 10 BOS  
## # ℹ 86 more rows</code></pre>
<p>Wenn du immer mit demselben Datensatz arbeitest, kann es Sinn machen
den Datensatz fest einzuprogrammieren. Als Spalte kann eine Zahl
entsprechend der Spaltenzahl dienen, oder der Name mit, oder ohne
Anführungszeichen.</p>
<pre class="r"><code>subset_flights &lt;- function(rows, cols) {
  flights |&gt; 
    filter({{ rows }}) |&gt; 
    select(time_hour, carrier, flight, {{ cols }})
}
subset_flights(TRUE, &quot;year&quot;)</code></pre>
<pre><code>## # A tibble: 336,776 × 4
##    time_hour           carrier flight  year
##    &lt;dttm&gt;              &lt;chr&gt;    &lt;int&gt; &lt;int&gt;
##  1 2013-01-01 05:00:00 UA        1545  2013
##  2 2013-01-01 05:00:00 UA        1714  2013
##  3 2013-01-01 05:00:00 AA        1141  2013
##  4 2013-01-01 05:00:00 B6         725  2013
##  5 2013-01-01 06:00:00 DL         461  2013
##  6 2013-01-01 05:00:00 UA        1696  2013
##  7 2013-01-01 06:00:00 B6         507  2013
##  8 2013-01-01 06:00:00 EV        5708  2013
##  9 2013-01-01 06:00:00 B6          79  2013
## 10 2013-01-01 06:00:00 AA         301  2013
## # ℹ 336,766 more rows</code></pre>
<pre class="r"><code>subset_flights(nrow(flights) &lt;= 10, 1)</code></pre>
<pre><code>## # A tibble: 0 × 4
## # ℹ 4 variables: time_hour &lt;dttm&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, year &lt;int&gt;</code></pre>
</div>
<div id="data-masking-vs.-tidy-selection" class="section level3"
number="18.2.9">
<h3><span class="header-section-number">18.2.9</span> Data-masking
vs. Tidy-selection</h3>
<p>Manchmal möchtest du Variablen innerhalb einer Funktion auswählen,
die Datenmaskierung verwendet</p>
<pre class="r"><code>count_missing &lt;- function(df, group_vars, x_var) {
  df |&gt; 
    group_by({{ group_vars }}) |&gt; 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = &quot;drop&quot;
    )
}

flights |&gt; 
  count_missing(c(year, month, day), dep_time)
#&gt; Error in `group_by()`:
#&gt; ℹ In argument: `c(year, month, day)`.
#&gt; Caused by error:
#&gt; ! `c(year, month, day)` must be size 336776 or 1, not 1010328.</code></pre>
<p><em>Tidy-selection</em> in einer <em>data-masking</em> Funktion lässt
sich benutzen mit <code>pick()</code>. Der Code oben funktioniert nicht,
da <code>group_by()</code> <em>data-masking</em>, nicht
<em>tidy-selection</em> benutzt.</p>
<pre class="r"><code>count_missing &lt;- function(df, group_vars, x_var) {
  df |&gt; 
    group_by(pick({{ group_vars }})) |&gt; 
    summarize(
      n_miss = sum(is.na({{ x_var }})),
      .groups = &quot;drop&quot;
  )
}

flights |&gt; 
  count_missing(c(year, month, day), dep_time)</code></pre>
<pre><code>## # A tibble: 365 × 4
##     year month   day n_miss
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;  &lt;int&gt;
##  1  2013     1     1      4
##  2  2013     1     2      8
##  3  2013     1     3     10
##  4  2013     1     4      6
##  5  2013     1     5      3
##  6  2013     1     6      1
##  7  2013     1     7      3
##  8  2013     1     8      4
##  9  2013     1     9      5
## 10  2013     1    10      3
## # ℹ 355 more rows</code></pre>
<pre class="r"><code>count_wide &lt;- function(data, rows, cols) {
  data |&gt; 
    count(pick(c({{ rows }}, {{ cols }}))) |&gt; 
    pivot_wider(
      names_from = {{ cols }}, 
      values_from = n,
      names_sort = TRUE,
      values_fill = 0
    )
}

diamonds |&gt; count_wide(c(clarity, color), cut)</code></pre>
<pre><code>## # A tibble: 56 × 7
##    clarity color  Fair  Good `Very Good` Premium Ideal
##    &lt;ord&gt;   &lt;ord&gt; &lt;int&gt; &lt;int&gt;       &lt;int&gt;   &lt;int&gt; &lt;int&gt;
##  1 I1      D         4     8           5      12    13
##  2 I1      E         9    23          22      30    18
##  3 I1      F        35    19          13      34    42
##  4 I1      G        53    19          16      46    16
##  5 I1      H        52    14          12      46    38
##  6 I1      I        34     9           8      24    17
##  7 I1      J        23     4           8      13     2
##  8 SI2     D        56   223         314     421   356
##  9 SI2     E        78   202         445     519   469
## 10 SI2     F        89   201         343     523   453
## # ℹ 46 more rows</code></pre>
</div>
</div>
<div id="plot-funktionen" class="section level2" number="18.3">
<h2><span class="header-section-number">18.3</span> Plot Funktionen</h2>
<p>Anstatt eines <em>Data Frames</em> wollen wir einen Plot ausgeben
lassen. Du kannst dieselbe Technik mit <code>ggplot2</code> verwenden,
da <code>aes()</code> eine <em>data-masking</em> Funktion ist.</p>
<pre class="r"><code>diamonds |&gt; 
  ggplot(aes(x = carat)) +
  geom_histogram(binwidth = 0.1)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-469-1.png" width="672" /></p>
<pre class="r"><code>diamonds |&gt; 
  ggplot(aes(x = carat)) +
  geom_histogram(binwidth = 0.05)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-469-2.png" width="672" /></p>
<p>Es wäre aber doch viel schöner, wenn du diesen Code in eine
Histogramm Funktion packen könntest.</p>
<pre class="r"><code>histogram &lt;- function(df, var, binwidth = NULL) {
  df |&gt; 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth)
}

diamonds |&gt; histogram(carat, 0.1)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-470-1.png" width="672" /></p>
<p>Du kannst natürlich noch durch <code>+</code> weitere Komponenten
hinzufügen.</p>
<pre class="r"><code>diamonds |&gt; 
  histogram(carat, 0.1) +
  labs(x = &quot;Size (in carats)&quot;, y = &quot;Number of diamonds&quot;)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-471-1.png" width="672" /></p>
<div id="mehr-variablen" class="section level3" number="18.3.1">
<h3><span class="header-section-number">18.3.1</span> Mehr
Variablen</h3>
<p>Mehr Variablen können natürlich hinzugefügt werden.</p>
<pre class="r"><code>linearity_check &lt;- function(df, x, y) {
  df |&gt;
    ggplot(aes(x = {{ x }}, y = {{ y }})) +
    geom_point() +
    geom_smooth(method = &quot;loess&quot;, formula = y ~ x, color = &quot;red&quot;, se = FALSE) +
    geom_smooth(method = &quot;lm&quot;, formula = y ~ x, color = &quot;blue&quot;, se = FALSE) 
}

starwars |&gt; 
  filter(mass &lt; 1000) |&gt; 
  linearity_check(mass, height)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-472-1.png" width="672" /></p>
<pre class="r"><code>hex_plot &lt;- function(df, x, y, z, bins = 20, fun = &quot;mean&quot;) {
  df |&gt; 
    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + 
    stat_summary_hex(
      aes(color = after_scale(fill)), # make border same color as fill
      bins = bins, 
      fun = fun,
    )
}

diamonds |&gt; hex_plot(carat, price, depth)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-473-1.png" width="672" /></p>
</div>
<div id="kombinieren-mit-tidyverse" class="section level3"
number="18.3.2">
<h3><span class="header-section-number">18.3.2</span> Kombinieren mit
<code>tidyverse</code></h3>
<p>Wir wollen ein vertikales Säulendiagramm erstellen, bei dem die
Reihenfolge fallend, statt aufsteigend ist.</p>
<pre class="r"><code>sorted_bars &lt;- function(df, var) {
  df |&gt; 
    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |&gt;
    ggplot(aes(y = {{ var }})) +
    geom_bar()
}

diamonds |&gt; sorted_bars(clarity)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-474-1.png" width="672" /></p>
<p>Hier haben wir eine neuen Operator, <code>:=</code>. R erlaubt hier
nur einen einfachen Wortnamen, wir wollen aber unsere Variable
überschreiben. Von <code>tidy</code> wird er wie ein <code>=</code>
bewertet.</p>
<p>Einen Plot für eine Teilmenge mithilfe von <code>filter()</code> in
einer Funktion können wir auch leicht erstellen.</p>
<pre class="r"><code>conditional_bars &lt;- function(df, condition, var) {
  df |&gt; 
    filter({{ condition }}) |&gt; 
    ggplot(aes(x = {{ var }})) + 
    geom_bar()
}

diamonds |&gt; conditional_bars(cut == &quot;Good&quot;, clarity)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-475-1.png" width="672" /></p>
</div>
<div id="labeling" class="section level3" number="18.3.3">
<h3><span class="header-section-number">18.3.3</span> Labeling</h3>
<pre class="r"><code>histogram &lt;- function(df, var, binwidth = NULL) {
  df |&gt; 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth)
}</code></pre>
<p>Warum nicht hier eine Überschrift hinzufügen? Dazu benutzen wir das
<code>rlang</code> Paket. Dazu benutzen wir
<code>rlang::englue()</code>. Jeder Wert in <code>{}</code> wird in den
<em>String</em> eingeführt. In <code>{{}}</code> wird der Variablenname
eingesetzt.</p>
<pre class="r"><code>histogram &lt;- function(df, var, binwidth) {
  label &lt;- rlang::englue(&quot;A histogram of {{var}} with binwidth {binwidth}&quot;)
  
  df |&gt; 
    ggplot(aes(x = {{ var }})) + 
    geom_histogram(binwidth = binwidth) + 
    labs(title = label)
}

diamonds |&gt; histogram(carat, 0.1)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-477-1.png" width="672" /></p>
</div>
</div>
<div id="style" class="section level2" number="18.4">
<h2><span class="header-section-number">18.4</span> Style</h2>
<p>R ist es egal wie du deine Funktionen oder Namen benennst. Kurz
sollten sie sein, aber auch sollte man eine Idee bekommen wie sich die
Funktion verhält. Funktionsnamen sind meist verben und Argumente
Nomen.</p>
<pre class="r"><code># Too short
f()

# Not a verb, or descriptive
my_awesome_function()

# Long, but clear
impute_missing()
collapse_years()</code></pre>
<p>Einrücken der Zeilen nicht vergessen.</p>
<pre class="r"><code># Missing extra two spaces
density &lt;- function(color, facets, binwidth = 0.1) {
diamonds |&gt; 
  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +
  geom_freqpoly(binwidth = binwidth) +
  facet_wrap(vars({{ facets }}))
}

# Pipe indented incorrectly
density &lt;- function(color, facets, binwidth = 0.1) {
  diamonds |&gt; 
  ggplot(aes(x = carat, y = after_stat(density), color = {{ color }})) +
  geom_freqpoly(binwidth = binwidth) +
  facet_wrap(vars({{ facets }}))
}</code></pre>
</div>
</div>
<div id="iteration" class="section level1" number="19">
<h1><span class="header-section-number">19</span> Iteration</h1>
<div id="einleitung-und-voraussetzung" class="section level2"
number="19.1">
<h2><span class="header-section-number">19.1</span> Einleitung und
Voraussetzung</h2>
<p>Willst du einen numerischen Vektor verdoppeln, so reicht es einfach
<code>2 * x</code> zu schreiben. Ähnliche Werkzeuge für Wiederholungen
haben wir schon kennengelernt:</p>
<ul>
<li><code>facet_wrap()</code> und <code>facet_grid</code> zeichnet einen
Plot für jede Teilmenge.</li>
<li><code>group_by</code> mit <code>summarize()</code> berechnet
zusammenfassende Statistiken für Untergruppen.</li>
<li><code>unnest_wider()</code> und <code>unnest_longer()</code>
erstellen neue Zeilen und Spalten.</li>
</ul>
<p>Jetzt lernen wir generelle Werkzeuge, <strong>functional
programming</strong> Werkzeuge kennen. Sie werden so genannt, da sie um
Funktionen gebaut werden, die andere Funktionen als Input nehmen.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
<p>Wir brauchen das bekannte <strong>dplyr</strong> und das neue
<strong>purrr</strong>. Ein hervorrangendes Paket.</p>
</div>
<div id="modyfying-multiple-columns" class="section level2"
number="19.2">
<h2><span class="header-section-number">19.2</span> Modyfying Multiple
Columns</h2>
<p>Wir schauen uns ein simplen <code>tibble</code> an und wollen Anzahl
der Beobachtungen, sowie Median, jeder Spalte berechen.</p>
<pre class="r"><code>df &lt;- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
df</code></pre>
<pre><code>## # A tibble: 10 × 4
##          a       b       c      d
##      &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
##  1 -2.59    0.335   0.541  -0.424
##  2  0.201  -0.337  -0.523   0.122
##  3 -0.0302 -0.289  -1.39    0.540
##  4  0.585  -0.0502  0.370   1.23 
##  5 -0.499  -0.696  -0.0552 -0.455
##  6  1.30    0.261  -1.26    1.62 
##  7 -1.76    0.344  -0.317  -0.641
##  8  2.29   -2.62    2.21   -2.93 
##  9  1.26    0.657   0.724   0.201
## 10  0.580  -0.427   0.620  -0.864</code></pre>
<pre class="r"><code>df |&gt; summarize(
  n = n(),
  a = median(a),
  b = median(b),
  c = median(c),
  d = median(d),
)</code></pre>
<pre><code>## # A tibble: 1 × 5
##       n     a      b     c      d
##   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1    10 0.390 -0.170 0.158 -0.151</code></pre>
<p>Wir können es mit <em>copy-paste</em> erledigen. Das kann sehr mühsam
sein, Oder wir benutzen <code>across()</code>:</p>
<pre class="r"><code>df |&gt; summarize(
  n = n(),
  across(a:d, median),
)</code></pre>
<pre><code>## # A tibble: 1 × 5
##       n     a      b     c      d
##   &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1    10 0.390 -0.170 0.158 -0.151</code></pre>
<p>Es hat drei wichtige Argumente, wobei die ersten beiden elementar
sind: <code>.cols</code> bestimmt die Spalten über die iteriert werden
soll und <code>.fns</code> was mit jeder Spalte gemacht werden soll. Das
<code>.names</code> Argument benutzt du, wenn du zusätzlich Kontrolle
über über die Namen des Outputs gewinnen willst.</p>
<div id="auswahl-von-spalten-mit-.cols" class="section level3"
number="19.2.1">
<h3><span class="header-section-number">19.2.1</span> Auswahl von
Spalten mit <code>.cols</code></h3>
<p>Das erste Argument sucht die zu transformierenden Spalten aus. Es
benutzt dieselbe Spezifikation wie <code>select()</code>, sodass du auch
<code>starts_with()</code> und <code>ends_with()</code> benutzen
kannst.</p>
<pre class="r"><code>dfs &lt;- tibble( w1 = rnorm(4), w2 = rnorm(4) + 5, s2 = rnorm(4) * 100)
dfs</code></pre>
<pre><code>## # A tibble: 4 × 3
##       w1    w2     s2
##    &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;
## 1  0.781  7.39  -60.2
## 2 -0.887  5.69 -210. 
## 3  1.57   6.17   83.7
## 4  1.65   3.32  201.</code></pre>
<pre class="r"><code>dfs|&gt;
  select(starts_with(&quot;w&quot;))</code></pre>
<pre><code>## # A tibble: 4 × 2
##       w1    w2
##    &lt;dbl&gt; &lt;dbl&gt;
## 1  0.781  7.39
## 2 -0.887  5.69
## 3  1.57   6.17
## 4  1.65   3.32</code></pre>
<pre class="r"><code>dfs|&gt;
  summarize(
    n = n(),
    across(c(w1, w2, s2), median)
  )</code></pre>
<pre><code>## # A tibble: 1 × 4
##       n    w1    w2    s2
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     4  1.18  5.93  11.7</code></pre>
<p>Zwei weitere Auswahltechniken sind sehr nützlich für
<code>across()</code>: <code>everything</code> und <code>where()</code>.
<code>everything</code> ist <em>straightforward</em>: es wählt jede
nicht-gruppierte Spalte.</p>
<pre class="r"><code>df &lt;- tibble(
  grp = sample(2, 10, replace = TRUE),
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)

df |&gt; 
  group_by(grp) |&gt; 
  summarize(across(everything(), median))</code></pre>
<pre><code>## # A tibble: 2 × 5
##     grp      a     b        c       d
##   &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1     1 -0.241 0.194 -0.253   -0.0615
## 2     2  0.760 0.919  0.00556  0.197</code></pre>
<p><code>where()</code> erlaubt es Spalten aufgrund ihres Types
auszuwählen: - <code>where(is.numeric)</code> -
<code>where(is.Date)</code> - …</p>
<p>Du kannst die Selektoren miteinander kombinieren:
<code>starts_with("a") &amp; where(is.logical)</code>. Hier werden alle
logischen Vektoren ausgewählt, deren Namen mit “a” starten.</p>
</div>
<div id="eine-einfach-funktion-aufrufen" class="section level3"
number="19.2.2">
<h3><span class="header-section-number">19.2.2</span> Eine einfach
Funktion aufrufen</h3>
<p>Wir übergeben eine Funktion an eine andere. Wir übergeben diese
Funktion an <code>across()</code>. Wir rufen sie nicht selbst auf. Dem
Funktionsnamen folgt kein <code>()</code>. Sonst gibt es eine
Fehlermeldung. Besser also ohne.</p>
<pre class="r"><code>k =  function(x) mean(x)
df|&gt;
  group_by(grp)|&gt;
  summarize(across(everything(), k))</code></pre>
<pre><code>## # A tibble: 2 × 5
##     grp      a     b       c      d
##   &lt;int&gt;  &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;
## 1     1 -0.552 0.168 -0.608  -0.221
## 2     2  0.692 0.531 -0.0817  0.135</code></pre>
</div>
<div id="multiple-funktionen-aufrufen" class="section level3"
number="19.2.3">
<h3><span class="header-section-number">19.2.3</span> Multiple
Funktionen aufrufen</h3>
<p>Haben wir <em>Missing Values</em> in unserem Datensatz, so wollen wir
diese natürlich entfernen.</p>
<pre class="r"><code>rnorm_na &lt;- function(n, n_na, mean = 0, sd = 1) {
  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))
}

df_miss &lt;- tibble(
  a = rnorm_na(5, 1),
  b = rnorm_na(5, 1),
  c = rnorm_na(5, 2),
  d = rnorm(5)
)
df_miss |&gt; 
  summarize(
    across(a:d, median),
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 1 × 5
##       a     b     c      d     n
##   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;
## 1    NA    NA    NA 0.0920     5</code></pre>
<p>Das können wir natürlich leicht mithilfe von <code>na.rm = T</code>.
Statt den Median durch <code>median()</code> aufzurufen, müssen wir eine
neue Funktion kreieren.</p>
<pre class="r"><code>df_miss |&gt; 
  summarize(
    across(a:d, function(x) median(x, na.rm = TRUE)),
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 1 × 5
##       a       b     c      d     n
##   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;
## 1 0.328 -0.0381 0.136 0.0920     5</code></pre>
<p>Es geht aber noch ein wenig kürzer, indem man <code>function</code>
durch <code>\</code> ersetzt.</p>
<pre class="r"><code>df_miss |&gt; 
  summarize(
    across(a:d, \(x) median(x, na.rm = TRUE)),
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 1 × 5
##       a       b     c      d     n
##   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;
## 1 0.328 -0.0381 0.136 0.0920     5</code></pre>
<p>Was geht wohl schneller?</p>
<pre class="r"><code>df_miss |&gt; 
  summarize(
    a = median(a, na.rm = TRUE),
    b = median(b, na.rm = TRUE),
    c = median(c, na.rm = TRUE),
    d = median(d, na.rm = TRUE),
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 1 × 5
##       a       b     c      d     n
##   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;int&gt;
## 1 0.328 -0.0381 0.136 0.0920     5</code></pre>
<p>Wir können jetzt sogar noch eine weitere Funktion hinzufügen. In eine
Liste.</p>
<pre class="r"><code>df_miss |&gt; 
  summarize(
    across(a:d, list(
      median = \(x) median(x, na.rm = TRUE),
      n_miss = \(x) sum(is.na(x))
    )),
    n = n()
  )</code></pre>
<pre><code>## # A tibble: 1 × 9
##   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss     n
##      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt; &lt;int&gt;
## 1    0.328        1  -0.0381        1    0.136        2   0.0920        0     5</code></pre>
<p>Achte auf die neuen Spaltennamen. Das ist kein Zufall:
<code>{.col}_{.fn}</code>. Der Name ist eine Kombination aus Spaltenname
und Funktion.</p>
</div>
<div id="spaltennamen" class="section level3" number="19.2.4">
<h3><span class="header-section-number">19.2.4</span> Spaltennamen</h3>
<p>Die können wir jetzt selber festlegen, wenn wir z.B. zuerst den Namen
der Funktion uns wünschen.</p>
<pre class="r"><code>df_miss |&gt; 
  summarize(
    across(
      a:d,
      list(
        median = \(x) median(x, na.rm = TRUE),
        n_miss = \(x) sum(is.na(x))
      ),
      .names = &quot;{.fn}_{.col}&quot;
    ),
    n = n(),
  )</code></pre>
<pre><code>## # A tibble: 1 × 9
##   median_a n_miss_a median_b n_miss_b median_c n_miss_c median_d n_miss_d     n
##      &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt;    &lt;dbl&gt;    &lt;int&gt; &lt;int&gt;
## 1    0.328        1  -0.0381        1    0.136        2   0.0920        0     5</code></pre>
<p>Das <code>.names</code> Argument ist besonders wichtig, wenn du
<code>across()</code> zusammen mit <code>mutate()</code> benutzt.
<code>across()</code> innerhalb von <code>mutate()</code> ersetzt
existierende Spalten. In unserem Fall ersetzt <code>coalesce()</code>
<code>NA</code> durch <code>0</code>.</p>
<pre class="r"><code>df_miss |&gt; 
  mutate(
    across(a:d, \(x) coalesce(x, 0))
  )</code></pre>
<pre><code>## # A tibble: 5 × 4
##        a       b      c       d
##    &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;
## 1  0.323  0       0      0.550 
## 2 -0.525 -0.259   0.136  0.0920
## 3  0.334  0.291  -0.736 -0.439 
## 4  0     -0.146   0      0.298 
## 5  0.440  0.0696  0.660 -1.28</code></pre>
<p>Du kannst aber auch neue Spalten kreieren, indem du durch
<code>.names</code> dem Output neue Namen verpasst.</p>
<pre class="r"><code>df_miss |&gt; 
  mutate(
    across(a:d, \(x) abs(x), .names = &quot;{.col}_abs&quot;)
  )</code></pre>
<pre><code>## # A tibble: 5 × 8
##        a       b      c       d  a_abs   b_abs  c_abs  d_abs
##    &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;
## 1  0.323 NA      NA      0.550   0.323 NA      NA     0.550 
## 2 -0.525 -0.259   0.136  0.0920  0.525  0.259   0.136 0.0920
## 3  0.334  0.291  -0.736 -0.439   0.334  0.291   0.736 0.439 
## 4 NA     -0.146  NA      0.298  NA      0.146  NA     0.298 
## 5  0.440  0.0696  0.660 -1.28    0.440  0.0696  0.660 1.28</code></pre>
</div>
<div id="filtern" class="section level3" number="19.2.5">
<h3><span class="header-section-number">19.2.5</span> Filtern</h3>
<p><code>across()</code> funktioniert sehr gut mit
<code>summarize()</code> und <code>mutate()</code>, aber nicht wirklich
mit <code>filter()</code>. <strong>dplyr</strong> bietet zwei Varianten
von <code>across()</code>an: <code>if_any()</code> und
<code>if_all()</code>.</p>
<pre class="r"><code># same as df_miss |&gt; filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))
df_miss |&gt; filter(if_any(a:d, is.na))</code></pre>
<pre><code>## # A tibble: 2 × 4
##        a      b     c     d
##    &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  0.323 NA        NA 0.550
## 2 NA     -0.146    NA 0.298</code></pre>
<p>Jede Zeile wird übernommen, in der mindestens ein <code>NA</code>
Wert ist. Oder in der nur <code>NA</code> Werte sind.</p>
<pre class="r"><code># same as df_miss |&gt; filter(is.na(a) &amp; is.na(b) &amp; is.na(c) &amp; is.na(d))
df_miss |&gt; filter(if_all(a:d, is.na))</code></pre>
<pre><code>## # A tibble: 0 × 4
## # ℹ 4 variables: a &lt;dbl&gt;, b &lt;dbl&gt;, c &lt;dbl&gt;, d &lt;dbl&gt;</code></pre>
</div>
<div id="across-in-funktionen" class="section level3" number="19.2.6">
<h3><span class="header-section-number">19.2.6</span>
<code>across()</code> in Funktionen</h3>
<p><code>across()</code> ist sehr nützlich, da es einem erlaubt auch auf
multiplen Spalten zu operieren.</p>
<pre class="r"><code>expand_dates &lt;- function(df) {
  df |&gt; 
    mutate(
      across(where(is.Date), list(year = year, month = month, day = mday))
    )
}

df_date &lt;- tibble(
  name = c(&quot;Amy&quot;, &quot;Bob&quot;),
  date = ymd(c(&quot;2009-08-03&quot;, &quot;2010-01-16&quot;))
)

df_date |&gt; 
  expand_dates()</code></pre>
<pre><code>## # A tibble: 2 × 5
##   name  date       date_year date_month date_day
##   &lt;chr&gt; &lt;date&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;int&gt;
## 1 Amy   2009-08-03      2009          8        3
## 2 Bob   2010-01-16      2010          1       16</code></pre>
<p>Berechne das arithmetische Mittel von numerischen Spalten.</p>
<pre class="r"><code>summarize_means &lt;- function(df, summary_vars = where(is.numeric)) {
  df |&gt; 
    summarize(
      across({{ summary_vars }}, \(x) mean(x, na.rm = TRUE)),
      n = n()
    )
}
diamonds |&gt; 
  group_by(cut) |&gt; 
  summarize_means()</code></pre>
<pre><code>## # A tibble: 5 × 11
##   cut       carat depth table price     x     y     z log_price log_carat     n
##   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;int&gt;
## 1 Fair      1.05   64.0  59.1 4359.  6.25  6.18  3.98      8.09   -0.0629  1610
## 2 Good      0.849  62.4  58.7 3929.  5.84  5.85  3.64      7.84   -0.307   4906
## 3 Very Good 0.806  61.8  58.0 3982.  5.74  5.77  3.56      7.80   -0.379  12082
## 4 Premium   0.892  61.3  58.7 4584.  5.97  5.94  3.65      7.95   -0.288  13791
## 5 Ideal     0.703  61.7  56.0 3458.  5.51  5.52  3.40      7.64   -0.518  21551</code></pre>
<pre class="r"><code>diamonds |&gt; 
  group_by(cut) |&gt; 
  summarize_means(c(carat, x:z))</code></pre>
<pre><code>## # A tibble: 5 × 6
##   cut       carat     x     y     z     n
##   &lt;ord&gt;     &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;
## 1 Fair      1.05   6.25  6.18  3.98  1610
## 2 Good      0.849  5.84  5.85  3.64  4906
## 3 Very Good 0.806  5.74  5.77  3.56 12082
## 4 Premium   0.892  5.97  5.94  3.65 13791
## 5 Ideal     0.703  5.51  5.52  3.40 21551</code></pre>
</div>
<div id="vs.-pivot_longer" class="section level3" number="19.2.7">
<h3><span class="header-section-number">19.2.7</span>
vs. <code>pivot_longer()</code></h3>
<p>Mithilfe von <code>pivot_longer</code> konnten wir aus einer
Kreuztabelle, eine lange Tabelle machen. Oftmals wird erst
<code>pivot_longer()</code> auf die Tabelle angesetzt, dann folgt
<code>group_by()</code>.</p>
<pre class="r"><code>df |&gt; 
  summarize(across(a:d, list(median = median, mean = mean)))</code></pre>
<pre><code>## # A tibble: 1 × 8
##   a_median  a_mean b_median b_mean c_median c_mean d_median  d_mean
##      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1    0.188 -0.0543    0.610  0.313   -0.106 -0.397  0.00790 -0.0785</code></pre>
<p>Dieselben Werte erhalten wir natürlich, indem wir
<code>pivot_longer()</code> benutzen und dann
<code>summarize()</code>.</p>
<pre class="r"><code>long &lt;- df |&gt; 
  pivot_longer(a:d) |&gt; 
  group_by(name) |&gt; 
  summarize(
    median = median(value),
    mean = mean(value)
  )</code></pre>
<p>Benutze <code>pivot_wider()</code> um wieder zur alten Struktur
zurückzukehren.</p>
<pre class="r"><code>long |&gt; 
  pivot_wider(
    names_from = name,
    values_from = c(median, mean),
    names_vary = &quot;slowest&quot;,
    names_glue = &quot;{name}_{.value}&quot;
  )</code></pre>
<pre><code>## # A tibble: 1 × 8
##   a_median  a_mean b_median b_mean c_median c_mean d_median  d_mean
##      &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;  &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt;
## 1    0.188 -0.0543    0.610  0.313   -0.106 -0.397  0.00790 -0.0785</code></pre>
<p>Es ist eine nützliche Technik, auch wenn die Namen der Variablen
“schwierig” sind.</p>
<pre class="r"><code>df_paired &lt;- tibble(
  a_val = rnorm(10),
  a_wts = runif(10),
  b_val = rnorm(10),
  b_wts = runif(10),
  c_val = rnorm(10),
  c_wts = runif(10),
  d_val = rnorm(10),
  d_wts = runif(10)
)</code></pre>
<p>Keine Chance mit <code>across()</code>, aber mit
<code>pivot_longer()</code>.</p>
<pre class="r"><code>df_long &lt;- df_paired |&gt; 
  pivot_longer(
    everything(), 
    names_to = c(&quot;group&quot;, &quot;.value&quot;), 
    names_sep = &quot;_&quot;
  )
df_long</code></pre>
<pre><code>## # A tibble: 40 × 3
##    group    val    wts
##    &lt;chr&gt;  &lt;dbl&gt;  &lt;dbl&gt;
##  1 a     -0.428 0.678 
##  2 b     -0.512 0.661 
##  3 c      1.21  0.406 
##  4 d     -0.260 0.205 
##  5 a     -0.188 0.628 
##  6 b     -0.760 0.0532
##  7 c      0.156 0.0774
##  8 d      0.396 0.973 
##  9 a      1.86  0.673 
## 10 b      1.88  0.0996
## # ℹ 30 more rows</code></pre>
<pre class="r"><code>df_long |&gt; 
  group_by(group) |&gt; 
  summarize(mean = weighted.mean(val, wts))</code></pre>
<pre><code>## # A tibble: 4 × 2
##   group  mean
##   &lt;chr&gt; &lt;dbl&gt;
## 1 a     0.221
## 2 b     0.325
## 3 c     0.190
## 4 d     0.332</code></pre>
</div>
</div>
</div>
<div id="reading-multiple-files" class="section level1" number="20">
<h1><span class="header-section-number">20</span> Reading Multiple
Files</h1>
<p>Hier geht es darum <code>purrr::map()</code> zu benutzen, dass
Transformationen nicht in multiplen Spalten vornimmt, sondern in jedem
Ordner deiner <em>directory</em>. Da das Thema sehr speziell ist,
schieben wir es mal nach hinten. Genauso wie das nächste.</p>
</div>
<div id="saving-multiple-outputs" class="section level1" number="21">
<h1><span class="header-section-number">21</span> Saving Multiple
Outputs</h1>
<p>Speziell, da geschoben.</p>
</div>
<div id="base-r---r-funktionen" class="section level1" number="22">
<h1><span class="header-section-number">22</span> Base R - R
Funktionen</h1>
<div id="einleitung-15" class="section level2" number="22.1">
<h2><span class="header-section-number">22.1</span> Einleitung</h2>
<p>Wir haben viel <strong>tidyverse</strong> benutzt, aber es geht auch
ohne Pakete. Trotzdem laden wir unser Standardpaket.</p>
<pre class="r"><code>library(tidyverse)</code></pre>
</div>
<div id="auswahl-multipler-elemente-mit" class="section level2"
number="22.2">
<h2><span class="header-section-number">22.2</span> Auswahl multipler
Elemente mit <code>[</code></h2>
<p>Eckige Klammern werden benutzt, um Teilmengen aus Vektoren oder
<em>Data Frames</em> zu gewinnen. Viele <strong>dplyr</strong> Verben
sind Spizialfälle von <code>[</code>.</p>
<div id="subsetting-vectors" class="section level3" number="22.2.1">
<h3><span class="header-section-number">22.2.1</span> Subsetting
Vectors</h3>
<p>Es gibt 5 Möglichkeiten einen Vektor zu unterteilen.
<code>x[i]</code> wäre ein Beispiel:</p>
<ol style="list-style-type: decimal">
<li><strong>Ein Vektor mit positiven, ganzen Zahlen.</strong> Ein
Vektor, oder eine einfache Zahl werden gewählt. Sie bestimmen die
Position des Elements im Vektor, das ausgegeben wird. Ein Beispiel zeigt
es schnell. Mehrere Zahlen können wiederholt werden, so dass der Output
länger ist als der Input. In <strong>tidyverse</strong> können wir mit
<code>slice(1:2)</code> z.B. Zeilen auswählen.</li>
</ol>
<pre class="r"><code>x &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;)
x[c(3, 2, 5)]</code></pre>
<pre><code>## [1] &quot;three&quot; &quot;two&quot;   &quot;five&quot;</code></pre>
<pre class="r"><code>x[2]</code></pre>
<pre><code>## [1] &quot;two&quot;</code></pre>
<pre class="r"><code>x[c(1, 1, 5, 5, 5, 2)]</code></pre>
<pre><code>## [1] &quot;one&quot;  &quot;one&quot;  &quot;five&quot; &quot;five&quot; &quot;five&quot; &quot;two&quot;</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><strong>Ein Vektor mit negativen Zahlen.</strong> Sie entfernen die
Zahlen hinter dem <code>-</code>. Bitte nicht <code>+</code> und
<code>-</code> mischen:</li>
</ol>
<pre class="r"><code>x[c(-1, -3, -5)]</code></pre>
<pre><code>## [1] &quot;two&quot;  &quot;four&quot;</code></pre>
<ol start="3" style="list-style-type: decimal">
<li><strong>Ein logical vector</strong>. Sehr wichtig. Der Vektor behält
die Elemente, die mit einem <code>TRUE</code> korrespondieren. Bei
Vergleichen wird es oft gebraucht.</li>
</ol>
<pre class="r"><code>x &lt;- c(10, 3, NA, 5, 8, 1, NA)

# All non-missing values of x
x[!is.na(x)]</code></pre>
<pre><code>## [1] 10  3  5  8  1</code></pre>
<pre class="r"><code># All even (or missing!) values of x
x[x %% 2 == 0]</code></pre>
<pre><code>## [1] 10 NA  8 NA</code></pre>
<ol start="4" style="list-style-type: decimal">
<li><strong>Ein Character Vector.</strong> Hast du einen benannten
Vektor, so kannst du ihn mit seinem Namen ansprechen.</li>
</ol>
<pre class="r"><code>x &lt;- c(abc = 1, def = 2, xyz = 5)
x[c(&quot;xyz&quot;, &quot;def&quot;)]</code></pre>
<pre><code>## xyz def 
##   5   2</code></pre>
<ol start="5" style="list-style-type: decimal">
<li><strong>Nothing.</strong> Klingt unlogisch, spielt aber später bei
2d Strukturen wie <em>tibbles</em> eine Rolle.</li>
</ol>
</div>
<div id="subsetting-data-frames" class="section level3" number="22.2.2">
<h3><span class="header-section-number">22.2.2</span> Subsetting Data
Frames</h3>
<p><code>df[rows, cols]</code> wählt den Wert eines <em>Data Frames</em>
aus. Lasse ich eine Seite weg, so werden ALLE Werte der Zeile oder
Spalte weggelassen.</p>
<pre class="r"><code>df &lt;- tibble(
  x = 1:3, 
  y = c(&quot;a&quot;, &quot;e&quot;, &quot;f&quot;), 
  z = runif(3)
)
df</code></pre>
<pre><code>## # A tibble: 3 × 3
##       x y         z
##   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     1 a     0.104
## 2     2 e     0.402
## 3     3 f     0.770</code></pre>
<pre class="r"><code># Select first row and second column
df[1, 2]</code></pre>
<pre><code>## # A tibble: 1 × 1
##   y    
##   &lt;chr&gt;
## 1 a</code></pre>
<pre class="r"><code># Select all rows and columns x and y
df[, c(&quot;x&quot; , &quot;y&quot;)]</code></pre>
<pre><code>## # A tibble: 3 × 2
##       x y    
##   &lt;int&gt; &lt;chr&gt;
## 1     1 a    
## 2     2 e    
## 3     3 f</code></pre>
<pre class="r"><code># Select rows where `x` is greater than 1 and all columns
df[df$x &gt; 1, ]</code></pre>
<pre><code>## # A tibble: 2 × 3
##       x y         z
##   &lt;int&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     2 e     0.402
## 2     3 f     0.770</code></pre>
<p><code>$</code> bei <code>df$x</code> wählt die Variable
<code>x</code> von <code>df</code> aus. Es gibt einen Unterschied
zwischen <em>tibbles</em> und <em>Data Frames</em> bzgl <code>[</code>.
Bei einem <em>Data Frame</em> wird ein Vektor erzeugt, wenn nur eine
Variable ausgewählt wird. Bei einem <em>tibble</em> wird immer wieder
ein <em>tibble</em> erzeugt.</p>
<pre class="r"><code>df1 &lt;- data.frame(x = 1:3)
df1[, &quot;x&quot;]</code></pre>
<pre><code>## [1] 1 2 3</code></pre>
<pre class="r"><code>df2 &lt;- tibble(x = 1:3)
df2[, &quot;x&quot;]</code></pre>
<pre><code>## # A tibble: 3 × 1
##       x
##   &lt;int&gt;
## 1     1
## 2     2
## 3     3</code></pre>
<p>Verhindere es mit:</p>
<pre class="r"><code>df1[, &quot;x&quot; , drop = FALSE]</code></pre>
<pre><code>##   x
## 1 1
## 2 2
## 3 3</code></pre>
</div>
<div id="äquivalente-zu-dplyr" class="section level3" number="22.2.3">
<h3><span class="header-section-number">22.2.3</span> Äquivalente zu
<strong>dplyr</strong></h3>
<ol style="list-style-type: decimal">
<li><code>filter()</code> ist äquivalent zu <em>Subsetting</em> die
Reihen mithilfe eines logischen Vektors.</li>
</ol>
<pre class="r"><code>df &lt;- tibble(
  x = c(2, 3, 1, 1, NA), 
  y = letters[1:5], 
  z = runif(5)
)
df |&gt; filter(x &gt; 1)</code></pre>
<pre><code>## # A tibble: 2 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     2 a     0.347
## 2     3 b     0.523</code></pre>
<pre class="r"><code># same as
df[!is.na(df$x) &amp; df$x &gt; 1, ]</code></pre>
<pre><code>## # A tibble: 2 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     2 a     0.347
## 2     3 b     0.523</code></pre>
<pre class="r"><code>which(df$x &gt; 1)</code></pre>
<pre><code>## [1] 1 2</code></pre>
<pre class="r"><code>df[which(df$x &gt; 1), ]</code></pre>
<pre><code>## # A tibble: 2 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     2 a     0.347
## 2     3 b     0.523</code></pre>
<ol start="2" style="list-style-type: decimal">
<li><code>arrange()</code> zu <code>order()</code>:</li>
</ol>
<pre class="r"><code>df |&gt; arrange(x, y)</code></pre>
<pre><code>## # A tibble: 5 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     1 c     0.368
## 2     1 d     0.851
## 3     2 a     0.347
## 4     3 b     0.523
## 5    NA e     0.934</code></pre>
<pre class="r"><code>df |&gt; arrange(x, y, decreasing = TRUE)</code></pre>
<pre><code>## # A tibble: 5 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     1 c     0.368
## 2     1 d     0.851
## 3     2 a     0.347
## 4     3 b     0.523
## 5    NA e     0.934</code></pre>
<pre class="r"><code># same as
df[order(df$x, df$y), ]</code></pre>
<pre><code>## # A tibble: 5 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     1 c     0.368
## 2     1 d     0.851
## 3     2 a     0.347
## 4     3 b     0.523
## 5    NA e     0.934</code></pre>
<pre class="r"><code>df[order(df$x, df$y), decreasing = TRUE, ]</code></pre>
<pre><code>## # A tibble: 5 × 3
##       x y         z
##   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     1 c     0.368
## 2     1 d     0.851
## 3     2 a     0.347
## 4     3 b     0.523
## 5    NA e     0.934</code></pre>
<p>Umgedrehte Reihenfolge mit <code>order(decreasing = TRUE)</code>,
oder <code>-rank(col)</code></p>
<ol start="3" style="list-style-type: decimal">
<li><code>select()</code> und <code>relocate()</code> zu einem
<em>Character Vector</em>.</li>
</ol>
<pre class="r"><code>df |&gt; select(x, z)</code></pre>
<pre><code>## # A tibble: 5 × 2
##       x     z
##   &lt;dbl&gt; &lt;dbl&gt;
## 1     2 0.347
## 2     3 0.523
## 3     1 0.368
## 4     1 0.851
## 5    NA 0.934</code></pre>
<pre class="r"><code># same as
df[, c(&quot;x&quot;, &quot;z&quot;)]</code></pre>
<pre><code>## # A tibble: 5 × 2
##       x     z
##   &lt;dbl&gt; &lt;dbl&gt;
## 1     2 0.347
## 2     3 0.523
## 3     1 0.368
## 4     1 0.851
## 5    NA 0.934</code></pre>
<p>In R Base kann man auch <code>filter()</code> und
<code>select()</code> kombinieren, durch <code>subset()</code>.</p>
<pre class="r"><code>df |&gt; 
  filter(x &gt; 1) |&gt; 
  select(y, z)</code></pre>
<pre><code>## # A tibble: 2 × 2
##   y         z
##   &lt;chr&gt; &lt;dbl&gt;
## 1 a     0.347
## 2 b     0.523</code></pre>
<pre class="r"><code>df |&gt; subset(x &gt; 1, c(y, z))</code></pre>
<pre><code>## # A tibble: 2 × 2
##   y         z
##   &lt;chr&gt; &lt;dbl&gt;
## 1 a     0.347
## 2 b     0.523</code></pre>
</div>
</div>
<div id="auswahl-einzelner-elementen-durch-und" class="section level2"
number="22.3">
<h2><span class="header-section-number">22.3</span> Auswahl einzelner
Elementen durch <code>$</code> und <code>[[</code></h2>
<p>Hier zeige ich dir wie du <code>[[</code> und <code>$</code> benutzt,
um aus <em>Data Frames</em> Spalten zu ziehen. Unterschiede zwischen
<code>[</code> und <code>[[</code> werden wir in Listen kennenlernen und
Unterschiede zwischen <code>data.frames</code> und <em>tibbles</em>.</p>
<div id="data-frames" class="section level3" number="22.3.1">
<h3><span class="header-section-number">22.3.1</span> Data Frames</h3>
<p><code>[[</code> und <code>$</code> können benutzt werden, um Spalten
aus einem <em>Data Frame</em> zu ziehen. Hier könen Position oder Name
bzw. der Name der Spalte stehen.</p>
<pre class="r"><code>tb &lt;- tibble(
  x = 1:4,
  y = c(10, 4, 1, 21)
)

# by position
tb[[1]]</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<pre class="r"><code># by name
tb[[&quot;x&quot;]]</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<pre class="r"><code>tb$x</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<p>Wir können auch neue Spalten kreieren., so wie wir es durch
<code>mutate()</code> schon kennen.</p>
<pre class="r"><code>tb$z &lt;- tb$x + tb$y
tb</code></pre>
<pre><code>## # A tibble: 4 × 3
##       x     y     z
##   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1     1    10    11
## 2     2     4     6
## 3     3     1     4
## 4     4    21    25</code></pre>
<p>Weitere Beispiele mit <code>transform()</code>, <code>with()</code>
und <code>within()</code>:</p>
<pre class="r"><code>data(diamonds, package = &quot;ggplot2&quot;)

# Most straightforward
diamonds$ppc &lt;- diamonds$price / diamonds$carat

# Avoid repeating diamonds 
diamonds$ppc &lt;- with(diamonds, price / carat)

# The inspiration for dplyr&#39;s mutate
diamonds &lt;- transform(diamonds, ppc = price / carat)
diamonds &lt;- diamonds |&gt; transform(ppc = price / carat)

# Similar to transform(), but uses assignment rather argument matching
# (can also use = here, since = is equivalent to &lt;- outside of a function call)
diamonds &lt;- within(diamonds, {
  ppc &lt;- price / carat
})
diamonds &lt;- diamonds |&gt; within({
  ppc &lt;- price / carat
})

# Protect against partial matching
diamonds$ppc &lt;- diamonds[[&quot;price&quot;]] / diamonds[[&quot;carat&quot;]]
diamonds$ppc &lt;- diamonds[, &quot;price&quot;] / diamonds[, &quot;carat&quot;]</code></pre>
<p><code>$</code> direkt zu benutzen ist bequem, wenn man schnelle
Zusammenfassungen braucht. Dann gibt es keine Notwendigkeit
<code>summarize()</code> zu benutzen.</p>
<pre class="r"><code>max(diamonds$carat)</code></pre>
<pre><code>## [1] 5.01</code></pre>
<pre class="r"><code>levels(diamonds$cut)</code></pre>
<pre><code>## [1] &quot;Fair&quot;      &quot;Good&quot;      &quot;Very Good&quot; &quot;Premium&quot;   &quot;Ideal&quot;</code></pre>
<p><strong>dplyr</strong> hat auch ein Äquivalent zu <code>[[/$</code>
im Angebot: <code>pull()</code>. Es nimmt entweder einen Variablennmanen
oder die Position einer Variable und gibt gerade diese Spalte aus. So
können die <strong>Pipe</strong> benutzen:</p>
<pre class="r"><code>diamonds |&gt; pull(carat) |&gt; max()</code></pre>
<pre><code>## [1] 5.01</code></pre>
<pre class="r"><code>diamonds |&gt; pull(cut) |&gt; levels()</code></pre>
<pre><code>## [1] &quot;Fair&quot;      &quot;Good&quot;      &quot;Very Good&quot; &quot;Premium&quot;   &quot;Ideal&quot;</code></pre>
</div>
<div id="tibbles" class="section level3" number="22.3.2">
<h3><span class="header-section-number">22.3.2</span> Tibbles</h3>
<p>In Bezug auf <code>$</code> unterscheiden sich <em>tibbles</em> und
<em>base</em> <code>data.frame()</code>. Im Gegensatz zu
<code>tibble()</code> wird bei <code>sata.frame()</code> keine
Fehlermeldung ausgegeben.</p>
<pre class="r"><code>df &lt;- data.frame(x1 = 1)
df$x</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>df$z</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code>tb &lt;- tibble(x1 = 1)
tb$x</code></pre>
<pre><code>## Warning: Unknown or uninitialised column: `x`.</code></pre>
<pre><code>## NULL</code></pre>
<pre class="r"><code>tb$z</code></pre>
<pre><code>## Warning: Unknown or uninitialised column: `z`.</code></pre>
<pre><code>## NULL</code></pre>
</div>
<div id="listen" class="section level3" number="22.3.3">
<h3><span class="header-section-number">22.3.3</span> Listen</h3>
<p>Der Unterschied bei Listen zu <code>[</code> ist sehr wichtig zu
verstehen.</p>
<pre class="r"><code>l &lt;- list(
  a = 1:3, 
  b = &quot;a string&quot;, 
  c = pi, 
  d = list(-1, -5)
)</code></pre>
<p><code>[</code> extrahiert eine Subliste.</p>
<pre class="r"><code>str(l[1:2])</code></pre>
<pre><code>## List of 2
##  $ a: int [1:3] 1 2 3
##  $ b: chr &quot;a string&quot;</code></pre>
<pre class="r"><code>str(l[1])</code></pre>
<pre><code>## List of 1
##  $ a: int [1:3] 1 2 3</code></pre>
<pre class="r"><code>str(l[4])</code></pre>
<pre><code>## List of 1
##  $ d:List of 2
##   ..$ : num -1
##   ..$ : num -5</code></pre>
<p>Bestimme die Subliste mit <em>logical</em>, <em>integer</em> oder
<em>character vector</em>.</p>
<p><code>[[</code> und <code>$</code> extrahieren eine einzige
Komponente von einer Liste.</p>
<pre class="r"><code>str(l[[1]])</code></pre>
<pre><code>##  int [1:3] 1 2 3</code></pre>
<pre class="r"><code>str(l[[4]])</code></pre>
<pre><code>## List of 2
##  $ : num -1
##  $ : num -5</code></pre>
<pre class="r"><code>str(l$a)</code></pre>
<pre><code>##  int [1:3] 1 2 3</code></pre>
</div>
</div>
<div id="apply-family" class="section level2" number="22.4">
<h2><span class="header-section-number">22.4</span> Apply family</h2>
<p>Das wichtigste Mitglied der Familie ist <code>lapply()</code>,
welches sehr ähnlich zu <code>purrr::map()</code> ist. Du kannst jeden
<code>map()</code> <em>call</em> durch <code>lapply()</code>
ersetzen.</p>
<p>Es gibt kein Äquivalent zu <code>across()</code>, aber in <strong>R
Base</strong> kommst du durch <code>[</code> mit <code>lapply()</code>
nah dran. <code>lapply()</code> auf einem <em>Data Frame</em> wendet die
Funktion auf jeder Spalte an.</p>
<pre class="r"><code>df &lt;- tibble(a = 1, b = 2, c = &quot;a&quot;, d = &quot;b&quot;, e = 4)
# First find numeric columns
num_cols &lt;- sapply(df, is.numeric)
num_cols</code></pre>
<pre><code>##     a     b     c     d     e 
##  TRUE  TRUE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code># Then transform each column with lapply() then replace the original values
df[, num_cols] &lt;- lapply(df[, num_cols, drop = FALSE], \(x) x * 2)
df</code></pre>
<pre><code>## # A tibble: 1 × 5
##       a     b c     d         e
##   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;
## 1     2     4 a     b         8</code></pre>
<p><code>sapply()</code> steckt den Output in einen Vektor,
<code>lapply()</code> in eine Liste.</p>
<p>R bietet eine striktere Version von <code>sapply()</code> an:
<code>vapply()</code>. Es nimmt ein weiteres Argument auf, dass den Typ
spezifiziert.</p>
<pre class="r"><code>vapply(df, is.numeric, logical(1))</code></pre>
<pre><code>##     a     b     c     d     e 
##  TRUE  TRUE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>vapply(df, is.numeric, numeric(1))</code></pre>
<pre><code>## a b c d e 
## 1 1 0 0 1</code></pre>
<p>Die Ausgabe hat einen logischen Wert bzw. einen numerischen.</p>
<p><code>tapply()</code> berechnet eine gruppierte Zusammenfassung durch
eine Funktion wie <code>mean()</code>.</p>
<pre class="r"><code>diamonds |&gt; 
  group_by(cut) |&gt; 
  summarize(price = mean(price))</code></pre>
<pre><code>## # A tibble: 5 × 2
##   cut       price
##   &lt;ord&gt;     &lt;dbl&gt;
## 1 Fair      4359.
## 2 Good      3929.
## 3 Very Good 3982.
## 4 Premium   4584.
## 5 Ideal     3458.</code></pre>
<pre class="r"><code>tapply(diamonds$price, diamonds$cut, mean)</code></pre>
<pre><code>##      Fair      Good Very Good   Premium     Ideal 
##  4358.758  3928.864  3981.760  4584.258  3457.542</code></pre>
<p>Abschließend gibt es noch <code>apply()</code>, welches mit Matrizen
und <em>Arrays</em> arbeitet. Wir arbeiten aber häufiger mit <em>Data
Frames</em>. Mehr darüber ist aber online schnell zu finden.</p>
</div>
<div id="for-loops" class="section level2" number="22.5">
<h2><span class="header-section-number">22.5</span> <code>for</code>
loops</h2>
<p><code>for</code> Schleifen sind mächtig und wichtig und werden von
Fortgeschrittenen häufig angewendet. Die Struktur sieht wie folgt
aus:</p>
<pre class="r"><code>for (element in vector) {
  # do something with element
}</code></pre>
<p>Ein einfaches Beispiel.</p>
<pre class="r"><code>k &lt;- numeric(20)
for (i in seq(1,20)) {
  k[i] &lt;- i*10
}
k</code></pre>
<pre><code>##  [1]  10  20  30  40  50  60  70  80  90 100 110 120 130 140 150 160 170 180 190
## [20] 200</code></pre>
</div>
<div id="while-schleifen" class="section level2" number="22.6">
<h2><span class="header-section-number">22.6</span> while-Schleifen</h2>
<p>Sie funktionieren ähnlich.</p>
<pre class="r"><code>n = numeric(0)
p = 5
while(p &lt; 10){
 n = c(n, p)
 p = p + 1
}
p</code></pre>
<pre><code>## [1] 10</code></pre>
<pre class="r"><code>n</code></pre>
<pre><code>## [1] 5 6 7 8 9</code></pre>
</div>
<div id="plots" class="section level2" number="22.7">
<h2><span class="header-section-number">22.7</span> Plots</h2>
<p>Kurz und schnell ohne Pakete.</p>
<pre class="r"><code># Left
hist(diamonds$carat)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-532-1.png" width="672" /></p>
<pre class="r"><code># Right
plot(diamonds$carat, diamonds$price)</code></pre>
<p><img src="index_2_files/figure-html/unnamed-chunk-532-2.png" width="672" /></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
