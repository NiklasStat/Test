<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Die Welt von R - Kapitel 1</title>

<script src="site_libs/header-attrs-2.24/header-attrs.js"></script>
<script src="site_libs/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/lumen.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/jqueryui-1.13.2/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>
<script src="site_libs/kePrint-0.0.1/kePrint.js"></script>
<link href="site_libs/lightable-0.0.1/lightable.css" rel="stylesheet" />

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>









<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark the anchor link active (and if it's in a dropdown, also mark that active)
  var dropdown = menuAnchor.closest('li.dropdown');
  if (window.bootstrap) { // Bootstrap 4+
    menuAnchor.addClass('active');
    dropdown.find('> .dropdown-toggle').addClass('active');
  } else { // Bootstrap 3
    menuAnchor.parent().addClass('active');
    dropdown.addClass('active');
  }

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}

@media print {
.toc-content {
  /* see https://github.com/w3c/csswg-drafts/issues/4434 */
  float: right;
}
}

.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}


</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-bs-toggle="collapse" data-target="#navbar" data-bs-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">My Website</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li>
  <a href="bbb1.html">1. Grundlagen Programmierung mit R</a>
</li>
<li>
  <a href="index_2.html">2. Data Science mit R</a>
</li>
<li>
  <a href="index_3.html">3. Machine Learning</a>
</li>
<li>
  <a href="index_4.html">4. Projekte mit R</a>
</li>
<li>
  <a href="test_markdown.html">Testen</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Die Welt von R - Kapitel 1</h1>

</div>


<div id="grundlagen" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Grundlagen</h1>
<p>Hier in diesem Abschnitt findest du die grundlegenden Konzepte von R.
Wir gehen hier nicht ins Detail und auch der Bezug zur Statistik ist
überschaubar. Das folgt in den anderen Abschnitten. Lerne erst einmal
<strong>R</strong> und die Programmierung kennen.</p>
<div id="die-benutzeroberfläche" class="section level2" number="1.1">
<h2><span class="header-section-number">1.1</span> Die
Benutzeroberfläche</h2>
<p>Um mit R zu arbeiten, lade R und ggf. RStudio online kostenfrei
herunter. Um R auszuführen, schreibe deinen Code in die Console unten
links. Um es auszuführen drücke Enter. Oben links kannst du ein neues R
Script öffnen und so als Editor nutzen. Um den geschriebenen Code in die
Console zu schicken, setze den Cursor an das Ende der Zeile, die du
schreiben willst und drücke in der Leiste darüber Run. Für alle Zeilen
markiere diese und drücke Run.<br />
Führe jetzt deinen ersten Code aus, z.B. die Summe zweier Zahlen.
Benutze R also als Taschenrechner.</p>
<pre class="r"><code>6 + 4</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Die Zeile beginnt mit dem erste Wert [1] deines Ergebnisses. Es gibt
natürlich Befehle, die mehr als einen Wert ausgeben. So geben wir z.B.
die Werte von 10 bis 13 wie folgt aus.</p>
<pre class="r"><code>10:13</code></pre>
<pre><code>## [1] 10 11 12 13</code></pre>
<p>Die Ausgabe erfolgt. Die Zahlen in den eckigen Klammern sind also zu
vernachlässigen, helfen aber natürlich. Du weißt aber wahrscheinlich
schon was ein Index ist.<br />
Auch wissen wir jetzt schon wie man alle ganzen Zahlen zwischen zwei
Zahlen widergibt. Hurra.</p>
<p>Auch über mehrere Zeilen können wir schreiben. Lücken zwischen den
Zahlen und Operatoren sind dabei erlaubt.</p>
<pre class="r"><code>99 -
+
+ 98</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Fehlermeldungen sind nicht ungewöhnlich und auch nicht zu vermeiden.
Lerne aus ihnen.<br />
Einfache arithmetische Rechnungen können wir schon intuitiv berechnen
lassen. Hier gilt natürlich auch Punkt vor Strich. Komma müssen, falls
notwendig, natürlich schon gesetzt werden. Der Code steht dabei in der
Console immer nach dem <code>&gt;</code>. Ohne lässt sich der Code aber
einfacher kopieren.</p>
<pre class="r"><code>4 + 44</code></pre>
<pre><code>## [1] 48</code></pre>
<pre class="r"><code>44 - 45</code></pre>
<pre><code>## [1] -1</code></pre>
<pre class="r"><code>33 / (4   -    1)</code></pre>
<pre><code>## [1] 11</code></pre>
<p>Kommentare kannst du nach einem Hastag # schreiben. Sehr sinnvoll und
zu empfehlen. Danach wird der Code nicht interpretiert. Ergebnisse, die
R ausgibt, werden hier nach einem <code>##</code> angegeben.</p>
</div>
<div id="objekte" class="section level2" number="1.2">
<h2><span class="header-section-number">1.2</span> Objekte</h2>
<p>Jetzt wollen wir aber natürlich nicht nur Werte ausgeben, sondern
diese auch speichern. Willst du z.B. einen Vektor benutzen, speichern
und dann wieder benutzen, erstelle ein R Objekt. Daten kannst du z.B.
als Objekt a oder b abspeichern und dann jederzeit benutzen.</p>
<pre class="r"><code>a &lt;- 5
a</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>a + 5</code></pre>
<pre><code>## [1] 10</code></pre>
<p>Die Zahlen 1 bis 6 können auch in einem Objekt abgespeichert werden
und dann natürlich auch aufgerufen werden.</p>
<pre class="r"><code>die &lt;- 1:6
die</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<p>Wenn du ein Objekt erstellst, erscheint es rechts oben im Fenster
Environment. Alle in der aktuellen Sitzung erstellten Objekte sind also
einzusehen. Sehr praktisch.<br />
Bei der Erstellung von Objekten ist auf den Namen zu achten. Viele, aber
nicht alle Namen, sind erlaubt. Ein Name kann nicht beginnen mt ^, !, $,
@, +, -, /, oder *. Auch auf Groß- und Kleinschreibung ist zu
achten.</p>
<table>
<thead>
<tr class="header">
<th>gute Namen</th>
<th>Problemnamen</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>a</td>
<td>1versuch</td>
</tr>
<tr class="even">
<td>b</td>
<td>^mean</td>
</tr>
<tr class="odd">
<td>Auto</td>
<td>$</td>
</tr>
<tr class="even">
<td>my_variable</td>
<td>3rd</td>
</tr>
<tr class="odd">
<td>.heute</td>
<td>!nicht_gut</td>
</tr>
</tbody>
</table>
<p>Schon benutzte Namen werden ohne Nachfrage einfach überschrieben.
Also aufpassen!</p>
<pre class="r"><code>my_zahl &lt;-1
my_zahl</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>my_zahl &lt;- 999
my_zahl</code></pre>
<pre><code>## [1] 999</code></pre>
<p>Deine Objektnamen kannst du mithilfe von <code>ls</code> abrufen.</p>
<pre class="r"><code>ls()</code></pre>
<pre><code>## [1] &quot;a&quot;       &quot;die&quot;     &quot;my_zahl&quot;</code></pre>
<p>Zahlen können wir manipulieren, aber auch unseren Vektor der Zahlen 1
bis 6. Und abspeichern natürlich nie vergessen.</p>
<pre class="r"><code>die - 6</code></pre>
<pre><code>## [1] -5 -4 -3 -2 -1  0</code></pre>
<pre class="r"><code>die / 2</code></pre>
<pre><code>## [1] 0.5 1.0 1.5 2.0 2.5 3.0</code></pre>
<pre class="r"><code>die * die</code></pre>
<pre><code>## [1]  1  4  9 16 25 36</code></pre>
<pre class="r"><code>die_zwei &lt;- die * die</code></pre>
<p>Hierbei multiplizieren wir die Vektoren elementenweise. Also erstes
Element von Vektor 1 wird mit dem ersten Element von Vektor 2
mutipliziert usw. Es geht natürlich auch anders. Aber dazu erst später
mehr.<br />
Wir können aber auch zwei Vektoren unterschiedlicher Länge multiplzieren
oder addieren. Hierbei wird dann der kürzere Vektor so lange wiederholt
bis die Anzahl der Elemente beider gleich ist.</p>
<pre class="r"><code>1:2</code></pre>
<pre><code>## [1] 1 2</code></pre>
<pre class="r"><code>1:4</code></pre>
<pre><code>## [1] 1 2 3 4</code></pre>
<pre class="r"><code>die</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<pre class="r"><code>die + 3:6</code></pre>
<pre><code>## Warning in die + 3:6: Länge des längeren Objektes
##       ist kein Vielfaches der Länge des kürzeren Objektes</code></pre>
<pre><code>## [1]  4  6  8 10  8 10</code></pre>
<pre class="r"><code>die + 1:3</code></pre>
<pre><code>## [1] 2 4 6 5 7 9</code></pre>
<p>Eine Warnung wird ausgegeben, wenn die Länge des längeren Objektes
kein Vielfaches des kürzeren Objektes ist.</p>
<p>Inneres <code>%*%</code> und äußeres Produkt <code>%o%</code> ergeben
natürlich zwei komplett verschiedene Ergebnisse.</p>
<pre class="r"><code>die %*% die</code></pre>
<pre><code>##      [,1]
## [1,]   91</code></pre>
<pre class="r"><code>die %o% die </code></pre>
<pre><code>##      [,1] [,2] [,3] [,4] [,5] [,6]
## [1,]    1    2    3    4    5    6
## [2,]    2    4    6    8   10   12
## [3,]    3    6    9   12   15   18
## [4,]    4    8   12   16   20   24
## [5,]    5   10   15   20   25   30
## [6,]    6   12   18   24   30   36</code></pre>
</div>
<div id="funktionen" class="section level2" number="1.3">
<h2><span class="header-section-number">1.3</span> Funktionen</h2>
<p>R kommt mit einer Menge an Funktionen daher. Wir können z.B. mit
Hilfe der <code>round</code> Funktion runden, oder die Fakultät
berechnen <code>factorial</code>. Eine Funktion anzuwenden ist sehr
leicht. Schreibe einfach den Namen der Funktion und lasse dann die Daten
folgen.</p>
<pre class="r"><code>round(3.14)</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>factorial(4)</code></pre>
<pre><code>## [1] 24</code></pre>
<p>Die Daten in den Klammern werden <em>Argumente</em> genannt. Diese
können rohe Daten sein, ein R Objekt oder sogar das Ergebnis einer
anderen R Funktion. Dabei kämpft sich R von innen nach außen vor
(letztes Beispiel).</p>
<pre class="r"><code>mean(1:8)</code></pre>
<pre><code>## [1] 4.5</code></pre>
<pre class="r"><code>mean(die)</code></pre>
<pre><code>## [1] 3.5</code></pre>
<pre class="r"><code>round(mean(die))</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Die Funktion <code>sample</code> gibt uns eine Zufallsstichprobe
beliebiger Länge wider. Hierbei müssen wir zwei Argumente angeben.<br />
<code>sample</code> gibt uns <code>size</code> Elemente des Vektors
wider.</p>
<pre class="r"><code>sample(x = 1:6, size = 3)</code></pre>
<pre><code>## [1] 1 4 2</code></pre>
<p>Wir können so einen Würfelwurf simulieren, auch ohne Würfel.</p>
<pre class="r"><code>sample(x = die, size = 1)</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>sample(x = die, size = 1)</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>sample(x = die, size = 1)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>sample(x = die, size = 1)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Jeder Würfelwurf gibt uns ein zufälliges Ergebns wider.<br />
Du kannst soviele Argumente wie du willst und wie nötig sind einer
Funktion übergeben, getrennt durch ein Komma natürlich. Oftmals wird das
erste Argument in den Klammern nicht extra benannt, da es sich meist um
die Daten handelt.</p>
<pre class="r"><code>sample(die, size = 2)</code></pre>
<pre><code>## [1] 6 1</code></pre>
<pre class="r"><code>sample(die, size = 2)</code></pre>
<pre><code>## [1] 6 2</code></pre>
<pre class="r"><code>sample(size = 2, x = die)</code></pre>
<pre><code>## [1] 2 3</code></pre>
<p>Die Reihenfolge kann vertauscht werden. Es ist aber nicht zu
empfehlen.<br />
Wenn du dir nicht sicher bist, welcher Name zu welcher Funktion passt,
benutze den Befehl <code>args</code>. Er zeigt dir die benötigten
Argumente der Funktion an.</p>
<pre class="r"><code>args(round)</code></pre>
<pre><code>## function (x, digits = 0) 
## NULL</code></pre>
<p>Hier siehst du auch, dass die Anzahl der Nachkommastellen auf 0
gesetz sind. Das is der <em>Default</em> Wert. Gibst du kein Argument
für die Anzahl der Nachkommastellen hier an, so wird auf eine ganze Zahl
gerundet.</p>
<pre class="r"><code>round(3.1415)</code></pre>
<pre><code>## [1] 3</code></pre>
<pre class="r"><code>round(3.1415, digits = 2)</code></pre>
<pre><code>## [1] 3.14</code></pre>
<p>Um den Code besser zu verstehen, schreibe einfach die Namen aus.
Nicht für immer, aber am Anfang hilft es. Dann ist wie oben erfolgt auch
die Reihenfolge der Argumente vertauschbar.</p>
<div id="sample-replacement" class="section level3" number="1.3.1">
<h3><span class="header-section-number">1.3.1</span> Sample
(Replacement)</h3>
<p>Wir wollen jetzt einen doppelten Würfelwurf simulieren, also einen
Wurf mit 2 Würfeln. Probiere es aus.</p>
<pre class="r"><code>sample(die, size = 2)</code></pre>
<pre><code>## [1] 2 4</code></pre>
<p>So oft wir wollen werden zwei Würfel geworfen. Was fällt auf?<br />
Als Default wird bei <code>sample</code> ohne Zurücklegen (Replacement)
geworfen. Das ist kein echter Wurf mit zwei Würfeln!<br />
Wir müssen noch ein weiteres Argument hinzufügen:
<code>replace = TRUE</code>.</p>
<pre class="r"><code>sample(die, size = 2, replace = TRUE)</code></pre>
<pre><code>## [1] 4 2</code></pre>
<p>Ohne bzw. mit <code>replace = FALSE</code> erhalten wir niemals
zweimal dieselbe Augenzahl.<br />
Die Augensumme lässt sich berechnen.</p>
<pre class="r"><code>dice &lt;- sample(die, size = 2, replace = TRUE)
sum(dice)</code></pre>
<pre><code>## [1] 8</code></pre>
<p>In <code>dice</code> ist jetzt das Ergebnis gespeichert. Egal wie oft
wir den Befehl aufrufen. Es wird nicht neu gewürfelt. Das beruhigt.</p>
</div>
</div>
<div id="eigene-funktionen-schreiben" class="section level2"
number="1.4">
<h2><span class="header-section-number">1.4</span> Eigene Funktionen
schreiben</h2>
<p>Wir haben unseren Würfelwurf mit R Code geschrieben.</p>
<pre class="r"><code>die &lt;- 1:6
dice &lt;- sample(die, size = 2, replace = TRUE)
sum(dice)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Bei jedem Würfelwurf können wir den Code also aufs neue verwenden und
erhalten ein valides Ergebnis.<br />
Einfacher wäre es aber eine neue, eigene Funktion zu schreiben. Das
machen wir jetzt.</p>
<p>Unsere Funktion soll <code>roll()</code> heißen, so dass immer ein
Ergebnis zwischen 2 und 12 erscheint: die Augensumme.</p>
<div id="funktionen-konstruieren" class="section level3" number="1.4.1">
<h3><span class="header-section-number">1.4.1</span> Funktionen
konstruieren</h3>
<p>Jede Funktion in R besteht aus drei Teilen: Name, Body, Code.<br />
Diese drei Teile packen wir in ein R Objekt, welches mit der
<code>function</code> Funktion erfolgt, gefolgt von geschweiften
Klammern:<br />
<code>my_function &lt;- function() {}</code>. In die geschweiften
Klammern kommt der Body. Hier sagen wir R was es zu tun hat.</p>
<pre class="r"><code>roll &lt;- function(){
  die &lt;- 1:6
  dice &lt;- sample(die, size = 2, replace = TRUE)
  summe_würfel &lt;- sum(dice)
  return (summe_würfel)
}</code></pre>
<p><code>return</code> könnten wir hier auch weglassen und stattdessen
bloß <code>summe_würfel</code> schreiben. Jetzt wird mit
<code>return</code> die Augensumme der Würfel widergegeben. Der Output
soll natürlich gespeichert werden. Nicht vergessen. Zum Aufrufen
verwenden wir <code>roll()</code>. Die Klammern sind der Trigger, um die
Funktion auszuführen. Ohne die Klammern wird bloß der Code
ausgegeben.</p>
<pre class="r"><code>roll()</code></pre>
<pre><code>## [1] 8</code></pre>
<pre class="r"><code>roll()</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>roll()</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>roll</code></pre>
<pre><code>## function(){
##   die &lt;- 1:6
##   dice &lt;- sample(die, size = 2, replace = TRUE)
##   summe_würfel &lt;- sum(dice)
##   return (summe_würfel)
## }
## &lt;bytecode: 0x000002010725cec8&gt;</code></pre>
<p>R führt den ganzen Code im Body aus und gibt als Resultat die letzte
Zeile Code wider. Überlege also was passiert, wenn du Zeile für Zeile
des Bodys in die Command Zeile eingibst. Würde R ein Resultat nach der
letzten Zeile ausgeben?</p>
</div>
</div>
<div id="argumente" class="section level2" number="1.5">
<h2><span class="header-section-number">1.5</span> Argumente</h2>
<p>Eine Fehlermeldung erhalten wir, da wir etwas vergessen haben und
falschen Namen verwendet haben.</p>
<pre class="r"><code>roll2 &lt;- function() {
  dice &lt;- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}</code></pre>
<p>Die Funktion braucht das Objekt <code>bones</code>. Aber er wird hier
nicht gefunden.<br />
<code>roll2()</code> erzeugt einen Fehler. Wir können aber
<code>bones</code> verwenden, wenn wir <code>bones</code> zu einem
Argument der Funktion machen. <code>bones</code> kommt also in die
Klammern der Funktion.</p>
<pre class="r"><code>roll2 &lt;- function(bones) {
  dice &lt;- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}</code></pre>
<p>Jetzt funktioniert <code>roll2</code> solange <code>bones</code> in
der Funktion aufgerufen wird. Dadurch sind wir auch deutlich flexibler,
sodass unser Würfel nicht nur 6 Seiten haben muss, sondern beliebig
viele.</p>
<pre class="r"><code>roll2(bones = 1:4)</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>roll2(bones = 1:6)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>roll2(1:20)</code></pre>
<pre><code>## [1] 26</code></pre>
<p>Gibst du keinen Wert für das Argument an, so erscheint eine
Fehlermeldung. Um eine Fehlermeldung zu vermeiden, kannst du einen
Defaultwert angeben.</p>
<pre class="r"><code>roll2 &lt;- function(bones = 1:6) {
  dice &lt;- sample(bones, size = 2, replace = TRUE)
  sum(dice)
}</code></pre>
<p>Ein neuer Wert als Arument liefert gewünschte Ergebnisse. Wird er
vergessen übernimmt der Defaultwert seinen Job.<br />
Du kannst deiner Funktion soviele Argumente wie du willst übergeben.
Nenne diese und liste sie durch Komma getrennt in den Klammern
auf.<br />
Jeder Argumentname in der Funktion wird beim Laufen jetzt durch die
gegebenen Werte ersetzt. Sind Defaultwerte gegeben, so liefern diese bei
Nichtnennung eigener Werte, die Daten für die Funktion.</p>
<p>Baue dir also eigene Funktionen! Einmal konstruiert behandelt R deine
Funktion wie jede andere Funktion in R, z.B. <code>mean</code>,
<code>round</code>, <code>max</code>, etc. Und denke daran. Die Funktion
gibt das Ergebnis der letzten Zeile des Body aus. Die Zeile vor der
schließenden geschweiften Klammer.</p>
</div>
</div>
<div id="pakete-und-hilfspakete" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Pakete und
Hilfspakete</h1>
<p>Wir haben einen Würfelwurf kostruiert und können jetzt überprüfen, ob
dieser faire Ergebnisse liefert. Zwei Werkzeuge helfen uns dabei:
Wiederholung und Visualisierung. Wir werden unsere Würfelwürfe
wiederholen und anschaulich visualisieren. Hierzu brauchen wir Pakete,
die uns dabei helfen. Sie sind noch nicht in unserem Download enthalten.
Viele der mächtigsten Werkzeuge sind in R Paketen enthalten. Lass uns
schauen was R Pakete sind und wie wir sie benutzen können.</p>
<div id="pakete" class="section level2" number="2.1">
<h2><span class="header-section-number">2.1</span> Pakete</h2>
<p>Wir sind nicht die einzigen Personen, die in R Funktionen schreiben.
Viele schlaue Köpfe benutzen R und entwickeln Werkzeuge, die uns bei der
Datenanalyse helfen können.<br />
Sie werden kostenfrei bereitgestellt, nur anwenden müssen wir sie noch
selber. Sie kommen als vormontierte Sammlung von Funktionen und Objekte:
Pakete.</p>
<p>Um ein paar schnelle Plots zu erhalten benutzen wir die
<code>qplot</code> Funktion im <strong>ggplot2</strong> Paket. Zuvor
muss es gedownloaded und installiert werden.</p>
<div id="install.packages" class="section level3" number="2.1.1">
<h3><span class="header-section-number">2.1.1</span>
install.packages</h3>
<p>Jedes R Paket ist zu finden auf <a
href="http://cran.r-project.org">link</a>. Herunterladen können wir
<strong>ggplot2</strong> über die Command Line durch:
<code>install.packages("ggplot2")</code>.</p>
</div>
<div id="library" class="section level3" number="2.1.2">
<h3><span class="header-section-number">2.1.2</span> library</h3>
<p>Mit dem Befehl <code>library("ggplot2")</code> können wir es
zugänglich machen. Ersetze ggplot2 natürlich beliebig.</p>
<p><code>qplot</code> erstellt schnelle Plots. Zwei Vektoren derselben
Länge und schon haben wir einen Scatterplot erstellt. Hierbei wird ein
Vektor mithilfe der <code>c</code> Funktion erstellt. In den Klammern
getrennt durch Komma stehen die einzelnen Werte.</p>
<pre class="r"><code>library(ggplot2)</code></pre>
<pre><code>## Warning: Paket &#39;ggplot2&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre class="r"><code>x &lt;- c(12,14,16,17,12,13,14,10,-5,-2)
y &lt;- x^2
y</code></pre>
<pre><code>##  [1] 144 196 256 289 144 169 196 100  25   4</code></pre>
<pre class="r"><code>qplot(x,y)</code></pre>
<pre><code>## Warning: `qplot()` was deprecated in ggplot2 3.4.0.
## This warning is displayed once every 8 hours.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<p><img src="bbb1_files/figure-html/unnamed-chunk-29-1.png" width="672" /></p>
<p>Elementenweise werden die Punktepaare erzeugt. Übergeben wir
<code>qplot</code> nur einen Vektor, erzeugt R ein Histogramm.</p>
<pre class="r"><code>x &lt;- c(1,2,2,2,3,3)
qplot(x, binwidth = 1)</code></pre>
<p><img src="bbb1_files/figure-html/unnamed-chunk-30-1.png" width="672" /></p>
<p>Unsere Intervalle gehen jeweils +- 0.5, da die Bandbreite (binwidth)
= 1 ist.</p>
<pre class="r"><code>x &lt;- c(1,2,2,2,3,3)
barplot(table(x), horiz = TRUE)</code></pre>
<p><img src="bbb1_files/figure-html/unnamed-chunk-31-1.png" width="672" /></p>
<p>Ein wenig anschaulicher ist ein Barplot.<br />
Kommen wir auf unser Würfelexperiment zurück. Wollen wir den Würfelwurf,
den wir simuliert haben, beliebig oft wiederholen, können wir die mit
<code>replicate</code> tun. Zuerst steht in der Klammer die Anzahl der
Wiederholungen, dann was wiederholt werden soll. In unserem Fall der
zweimalige Würfelwurf mit Zurücklegen. Die Summe ergibt Zahlen zwischen
2 und 12.</p>
<pre class="r"><code>replicate(5, 2)</code></pre>
<pre><code>## [1] 2 2 2 2 2</code></pre>
<pre class="r"><code>replicate(10, roll())</code></pre>
<pre><code>##  [1]  7  5 12  4  4  9  4  7  6 11</code></pre>
<p>Jetzt können wir die beiden Würfel aber auch 10 000 mal werfen und
die Augensumme notieren. Also simulieren wir mal. Welche Grafik ist wohl
sinnvoller?</p>
<pre class="r"><code>rolls &lt;- replicate(10000, roll())
qplot(rolls, binwidth = 1)</code></pre>
<p><img src="bbb1_files/figure-html/unnamed-chunk-33-1.png" width="672" /></p>
<pre class="r"><code>barplot(table(rolls), horiz = F)</code></pre>
<p><img src="bbb1_files/figure-html/unnamed-chunk-33-2.png" width="672" /></p>
<p>Es sieht alles nach einem fairen Würfel aus. Um ihn unfair zu machen
könnten wir die Wahrscheinlichkeiten ändern:</p>
<table>
<thead>
<tr class="header">
<th>Zahl</th>
<th>faire WKT</th>
<th>gewichtete WKT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>1/6</td>
<td>1/8</td>
</tr>
<tr class="even">
<td>2</td>
<td>1/6</td>
<td>1/8</td>
</tr>
<tr class="odd">
<td>3</td>
<td>1/6</td>
<td>1/8</td>
</tr>
<tr class="even">
<td>4</td>
<td>1/6</td>
<td>1/8</td>
</tr>
<tr class="odd">
<td>5</td>
<td>1/6</td>
<td>1/8</td>
</tr>
<tr class="even">
<td>6</td>
<td>1/6</td>
<td>3/8</td>
</tr>
</tbody>
</table>
<p>Die Wahrscheinlichkeiten können wir ändern, indem wir der
<code>sample</code> Funktion ein Argument hinzufügen. Mache dies
mithilfe der Hilfeseite.</p>
</div>
</div>
<div id="hilfe-suchen-mit-hilfeseiten" class="section level2"
number="2.2">
<h2><span class="header-section-number">2.2</span> Hilfe suchen mit
Hilfeseiten</h2>
<p>Hilfeseiten können über ein Fragezeichen vor der Funktion aufgerufen
werden: <code>?sqrt</code>, <code>?log10</code> und <code>?sample</code>
sind Beispiele. Sie enthalten Informationen über das, was jede Funktion
macht. Am Ende von ihnen findet man meist anschauliche Beispiele.<br />
Kommt die Funktion in einem R Paket daher, muss dieses natürlich zuvor
geladen werden.</p>
<div id="abschnitte-der-hilfeseiten" class="section level3"
number="2.2.1">
<h3><span class="header-section-number">2.2.1</span> Abschnitte der
Hilfeseiten</h3>
<p>Folgende Themen sind meist zu finden:</p>
<p><strong>Beschreibung</strong> Eine Beschreibung was die Funktion
macht.</p>
<p><strong>Usage</strong> Ein Beispiel wie du die Funktion schreiben
würdest.</p>
<p><strong>Argumente</strong> Eine Liste der Argumente. Welche Art von
Argumenten erwartet R und was macht die Funktion mit den
Informationen.</p>
<p><strong>Details</strong> Eine tiefere Beschreibung der Funktion.</p>
<p><strong>Value</strong> Was gibt die Funktion dir wider?</p>
<p><strong>See Also</strong> Verwandte R Funktionen.</p>
<p><strong>Examples</strong> Beispiele.</p>
<p>Hast du die Funktion vergessen bzw. den Namen, gib zwei Fragezeichen
und dann das Keywort an. Es ist eine Hilfeseite für eine Hilfeseite
(z.B. <code>??log</code>).</p>
<p>Wir rufen also <code>?sample</code> auf. Hier stehen viele wichtige
Infos, die wir zum bauen unserer Funktion brauchen.</p>
<pre class="r"><code>sample(x, size, replace = FALSE, prob = NULL)</code></pre>
<p>Unsere <code>roll()</code> Funktion rufen wir uns in Erinnerung.</p>
<pre class="r"><code>roll &lt;- function() {
  die &lt;- 1:6
  dice &lt;- sample(die, size = 2, replace = TRUE)
  sum(dice)
}</code></pre>
<p>Um unsere Wahrscheinlichkeiten anzupassen, fügen wir ein weiteres
Argument hinzu: <code>prob</code> mit einem Vektor von Gewichten.</p>
<pre class="r"><code>roll &lt;- function() {
  die &lt;- 1:6
  dice &lt;- sample(die, size = 2, replace = T,
     prob = c(1/8, 1/8, 1/8, 1/8, 1/8, 3/8))
  sum(dice)
}
roll()</code></pre>
<pre><code>## [1] 7</code></pre>
<p>Wir überschreiben unsere Ergebnisse.</p>
<pre class="r"><code>rolls &lt;- replicate(10000, roll())
qplot(rolls, binwidth = 1)</code></pre>
<p><img src="bbb1_files/figure-html/unnamed-chunk-37-1.png" width="672" /></p>
<pre class="r"><code>barplot(table(rolls), horiz = F)</code></pre>
<p><img src="bbb1_files/figure-html/unnamed-chunk-37-2.png" width="672" /></p>
</div>
<div id="noch-mehr-hilfe" class="section level3" number="2.2.2">
<h3><span class="header-section-number">2.2.2</span> Noch mehr
Hilfe</h3>
<p>Stack Overflow<br />
Google<br />
RStudio <a href="www.community.rstudio.com">link</a></p>
</div>
</div>
</div>
<div id="r-objekte" class="section level1" number="3">
<h1><span class="header-section-number">3</span> R Objekte</h1>
<div id="vektoren" class="section level2" number="3.1">
<h2><span class="header-section-number">3.1</span> Vektoren</h2>
<p>Ein Vektor ist schnell gebildet aus ein paar Werten und einem
<code>c</code>.</p>
<pre class="r"><code>die &lt;- c(1,2,3,4,5,6)
die</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<pre class="r"><code>is.vector(die)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Wir erstellen einen Vektor und überprüfen, ob es wirklich einer ist.
Die möglichen Ergebnisse sind natürlich TRUE oder FALSE. Auch aus einem
Wert ist ein Vektor zu bilden. Mit der Länge 1 natürlich.</p>
<pre class="r"><code>five &lt;- 5
is.vector(five)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>length(five)</code></pre>
<pre><code>## [1] 1</code></pre>
<pre class="r"><code>length(die)</code></pre>
<pre><code>## [1] 6</code></pre>
<p>Ein eindimensionaler Vektor kann nur einen Datentyp beinhalten.
Insgesamt gibt es sechs verschiedene Typen von Vektoren:<br />
doubles<br />
integers<br />
characters<br />
logicals<br />
complex<br />
raw.</p>
<p>Wir wollen jetzt ein 52er Kartendeck erstellen. Dafür brauchen wir
natürlich verschiedene Datentypen (Text und Zahlen). Bei der
Dateneingabe werden sie durch gewisse Konventionen angegeben. Bei der
Dateneingabe kann ein <code>L</code> mit angegeben werden für
<strong>integer</strong> und Anführungszeichen für
<strong>character</strong>.</p>
<pre class="r"><code>int &lt;- 1L
text &lt;- &quot;ace&quot;</code></pre>
<p>Vektoren mit mehr als einem Element können natürlich auch erstellt
werden.</p>
<pre class="r"><code>int &lt;- c(1L, 5L)
text &lt;- c(&quot;ace&quot;, &quot;hearts&quot;)</code></pre>
<p>Verschiedene Typen sind notwendig, da sie auf Funktionen
verschiedenartig reagieren.</p>
<pre class="r"><code>sum(int)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code># sum(text) Fehlermeldung</code></pre>
<div id="doubles" class="section level3" number="3.1.1">
<h3><span class="header-section-number">3.1.1</span> Doubles</h3>
<p>Ein double Vektor enthält reguläre Zahlen: positive Zahlen, negative
Zahlen, große oder kleine, Zahlen mit oder ohne Nachkommastellen.<br />
R speichert jede Zahl, die du eintippst, als double ab. Abfragen kannst
du diesen Typ leicht mit <code>typeof</code>.</p>
<pre class="r"><code>die &lt;- c(1,2,3,4,5,6)
die</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
<pre class="r"><code>typeof(die)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<p>Einige R Funktionen deklarieren doubles als
<strong>numerics</strong>.</p>
</div>
<div id="integers" class="section level3" number="3.1.2">
<h3><span class="header-section-number">3.1.2</span> Integers</h3>
<p>Da du Integers als doubles abspeichern kannst, benutzt du diesen
Datentypen nicht sehr oft. Erst folgt eine ganze Zahl, dann ein
<code>L</code>.</p>
<pre class="r"><code>int &lt;- c(-1L, 2L, 4L)
int</code></pre>
<pre><code>## [1] -1  2  4</code></pre>
<pre class="r"><code>typeof(int)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<p>R speichert eine Zahl nur mit einem <code>L</code> so ab, ansonsten
als doubles.</p>
</div>
<div id="characters" class="section level3" number="3.1.3">
<h3><span class="header-section-number">3.1.3</span> Characters</h3>
<p>Hier wird Text abgespeichert. In Anführungszeichen.</p>
<pre class="r"><code>text &lt;- c(&quot;Hello&quot;, &quot;World&quot;)
text</code></pre>
<pre><code>## [1] &quot;Hello&quot; &quot;World&quot;</code></pre>
<pre class="r"><code>typeof(text)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<pre class="r"><code>typeof(&quot;Hello&quot;)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
<p>Die individuellen Elemente eines Character Vektors sind als
<strong>strings</strong> bekannt. Ein <em>String</em> kann mehr als nur
Buchstaben enthalten! Auch <code>"1"</code> ist ein <em>Character
String</em>.</p>
</div>
<div id="logicals" class="section level3" number="3.1.4">
<h3><span class="header-section-number">3.1.4</span> Logicals</h3>
<p>Diese Vekoren beinhalten <code>TRUE</code> oder <code>FALSE</code>.
Auch die Abkürzungen sind möglich: <code>T</code> oder <code>F</code>.
Sie sind wichtig!</p>
<pre class="r"><code>3 &gt; 4</code></pre>
<pre><code>## [1] FALSE</code></pre>
<p>Jedes mal, wenn du <code>TRUE</code> oder <code>FALSE</code> in
großen Buchstaben in R eingibst, wird es als logischer Wert
wahrgenommen.</p>
<pre class="r"><code>logic &lt;- c(TRUE, TRUE, TRUE)
logic</code></pre>
<pre><code>## [1] TRUE TRUE TRUE</code></pre>
<pre class="r"><code>typeof(logic)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<pre class="r"><code>typeof(F)</code></pre>
<pre><code>## [1] &quot;logical&quot;</code></pre>
<p><code>T</code> und <code>F</code> können auch als Zahlen wahgenommen
werden: 1 und 0. Dazu später mehr.</p>
</div>
<div id="complex-und-raw" class="section level3" number="3.1.5">
<h3><span class="header-section-number">3.1.5</span> Complex und
Raw</h3>
<p>Bei der Datenanalyse werden sie selten gebraucht. Complex Vektors
beihalten komplexe Zahlen. Um so einen Vektor zu erzeugen, füge einen
imaginären Term zu einer Zahl mit <code>i</code>.</p>
<pre class="r"><code>comp &lt;- c(1 + 1i, 1 + 2i,1 + 3i)
comp</code></pre>
<pre><code>## [1] 1+1i 1+2i 1+3i</code></pre>
<pre class="r"><code>typeof(comp)</code></pre>
<pre><code>## [1] &quot;complex&quot;</code></pre>
<p>Raw Vektoren beinhalten Datenbytes.</p>
<pre class="r"><code>raw(3)</code></pre>
<pre><code>## [1] 00 00 00</code></pre>
<pre class="r"><code>typeof(raw(3))</code></pre>
<pre><code>## [1] &quot;raw&quot;</code></pre>
<p><strong>Beispiel</strong> für einen Character Vektor. Karten: Ein
Royal Flush hat welche 5 Symbole auf den Karten?</p>
<pre class="r"><code>hand &lt;- c(&quot;Ass&quot;, &quot;König&quot;, &quot;Dame&quot;, &quot;Bube&quot;, &quot;Zehn&quot;) 
hand</code></pre>
<pre><code>## [1] &quot;Ass&quot;   &quot;König&quot; &quot;Dame&quot;  &quot;Bube&quot;  &quot;Zehn&quot;</code></pre>
<pre class="r"><code>typeof(hand)</code></pre>
<pre><code>## [1] &quot;character&quot;</code></pre>
</div>
</div>
<div id="attribute" class="section level2" number="3.2">
<h2><span class="header-section-number">3.2</span> Attribute</h2>
<p>Ein Atribut ist eine Zusatzinformation, die du an einen Vektor
anhängen kannst. Es beeinflusst weder den Wert noch wird es angezeigt,
wenn du dein Objekt ausgibst. Es ist vergleichbar mit Metadaten. R
ignoriert normalerweise diese Metadaten, sie können aber durch
Funktionen angezeigt werden. Über <code>attributes</code> kannst du dir
diese anzeigen lassen. Hat ein Objekt kein Attribut, so wird
<code>NULL</code> ausgegeben.</p>
<pre class="r"><code>attributes(die)</code></pre>
<pre><code>## NULL</code></pre>
<div id="namen" class="section level3" number="3.2.1">
<h3><span class="header-section-number">3.2.1</span> Namen</h3>
<p>Die populärsten Attribute eines Vektors sind Namen, Dimensionen und
Klassen.<br />
Du kannst mit speziellen Funktionen dir dieses Attribut ausgeben lassen.
Zum Beispiel kannst du nach dem Namen fragen mit <code>names</code>.</p>
<pre class="r"><code>names(die)</code></pre>
<pre><code>## NULL</code></pre>
<p><code>NULL</code> heißt, dass es kein names Attribut für
<code>die</code> gibt. Das kannst du selbst zuordnen. Der Vektor enthält
einen Namen für jedes Element in <code>die</code>.</p>
<pre class="r"><code>names(die) &lt;- c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;, &quot;six&quot;)
names(die)</code></pre>
<pre><code>## [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot; &quot;four&quot;  &quot;five&quot;  &quot;six&quot;</code></pre>
<pre class="r"><code>attributes(die)</code></pre>
<pre><code>## $names
## [1] &quot;one&quot;   &quot;two&quot;   &quot;three&quot; &quot;four&quot;  &quot;five&quot;  &quot;six&quot;</code></pre>
<pre class="r"><code>die</code></pre>
<pre><code>##   one   two three  four  five   six 
##     1     2     3     4     5     6</code></pre>
<pre class="r"><code>die + 1</code></pre>
<pre><code>##   one   two three  four  five   six 
##     2     3     4     5     6     7</code></pre>
<p>Die Namen affektieren nicht die aktuellen Werte, auch nicht bei
Manipulation der Werte. Das Attribut kannst du natürlich auch wieder
ändern.</p>
<pre class="r"><code>names(die) &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, &quot;quatro&quot;, &quot;cinco&quot;, &quot;seis&quot;)
die</code></pre>
<pre><code>##    uno    dos   tres quatro  cinco   seis 
##      1      2      3      4      5      6</code></pre>
<p>Das Namensattribut kann auch ganz entfernt werden.</p>
<pre class="r"><code>names(die) &lt;- NULL
die</code></pre>
<pre><code>## [1] 1 2 3 4 5 6</code></pre>
</div>
<div id="dimension" class="section level3" number="3.2.2">
<h3><span class="header-section-number">3.2.2</span> Dimension</h3>
<p>Ein Vektor kann in einen n-dimensionalen Array transformiert werden,
indem man ihm die Dimensinsattribute mit <code>dim</code> zuweist. So
kannst du einen Vektor der Länge 6 in eine <span
class="math inline">\(2\times3\)</span> - Matrix umwandeln mit zwei
Zeilen und drei Spalten.</p>
<pre class="r"><code>dim(die) &lt;- c(2, 3)
die</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<pre class="r"><code>dim(die) &lt;- c(3, 2)
die</code></pre>
<pre><code>##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## [3,]    3    6</code></pre>
<p>R füllt die Matrizen spaltenweise. Um diesen Prozess zu beeinflussen,
schau in die Hilfsfunktionen <code>matrix</code> oder
<code>array</code>.</p>
</div>
</div>
<div id="matrizen" class="section level2" number="3.3">
<h2><span class="header-section-number">3.3</span> Matrizen</h2>
<p>Matrizen enthalten Werte in einem 2-dimensionalen Array. Nach
<code>matrix</code> folgt in den Klammern der Datensatz, dann die Anzahl
der Zeilen <code>nrow</code> oder die Anahl der Spalten
<code>ncol</code>.</p>
<pre class="r"><code>m &lt;- matrix(die, nrow = 2)
m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<p><code>matrix</code> füllt die Matrix Spalte für Spalte (default). Du
kannst sie aber reihenweise befüllen lassen mit dem Argument
<code>byrow = T</code>.</p>
<pre class="r"><code>m &lt;- matrix(die, nrow = 2, byrow = TRUE)
m</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    2    3
## [2,]    4    5    6</code></pre>
</div>
<div id="arrays" class="section level2" number="3.4">
<h2><span class="header-section-number">3.4</span> Arrays</h2>
<p>Die <code>array</code> Funktion erzeugt einen n-dimensionalen Array.
Es wird nach einem Vektor als erstes Argument gefragt, dann folgt ein
Vektor der Dimensionen <code>dim</code>.</p>
<pre class="r"><code>ar &lt;- array(c(11:14, 21:24, 31:34), dim = c(2, 2, 3))
ar </code></pre>
<pre><code>## , , 1
## 
##      [,1] [,2]
## [1,]   11   13
## [2,]   12   14
## 
## , , 2
## 
##      [,1] [,2]
## [1,]   21   23
## [2,]   22   24
## 
## , , 3
## 
##      [,1] [,2]
## [1,]   31   33
## [2,]   32   34</code></pre>
<p>Bilde z.B. eine Matrix mit den Namen und Farbe eines Royal Flush.</p>
<pre class="r"><code>hand1 &lt;- c(&quot;ace&quot;, &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;)
matrix(hand1, nrow = 5)</code></pre>
<pre><code>##      [,1]    [,2]    
## [1,] &quot;ace&quot;   &quot;spades&quot;
## [2,] &quot;king&quot;  &quot;spades&quot;
## [3,] &quot;queen&quot; &quot;spades&quot;
## [4,] &quot;jack&quot;  &quot;spades&quot;
## [5,] &quot;ten&quot;   &quot;spades&quot;</code></pre>
<pre class="r"><code>matrix(hand1, ncol = 2)</code></pre>
<pre><code>##      [,1]    [,2]    
## [1,] &quot;ace&quot;   &quot;spades&quot;
## [2,] &quot;king&quot;  &quot;spades&quot;
## [3,] &quot;queen&quot; &quot;spades&quot;
## [4,] &quot;jack&quot;  &quot;spades&quot;
## [5,] &quot;ten&quot;   &quot;spades&quot;</code></pre>
<pre class="r"><code>dim(hand1) &lt;- c(5, 2)
hand1</code></pre>
<pre><code>##      [,1]    [,2]    
## [1,] &quot;ace&quot;   &quot;spades&quot;
## [2,] &quot;king&quot;  &quot;spades&quot;
## [3,] &quot;queen&quot; &quot;spades&quot;
## [4,] &quot;jack&quot;  &quot;spades&quot;
## [5,] &quot;ten&quot;   &quot;spades&quot;</code></pre>
<p>Auch kannst du Zeilenweise einlesen aus:</p>
<pre class="r"><code>hand2 &lt;- c(&quot;ace&quot;, &quot;spades&quot;, &quot;king&quot;, &quot;spades&quot;, &quot;queen&quot;, &quot;spades&quot;, &quot;jack&quot;, &quot;spades&quot;, &quot;ten&quot;, &quot;spades&quot;)
matrix(hand2, ncol = 2, byrow = T)</code></pre>
<pre><code>##      [,1]    [,2]    
## [1,] &quot;ace&quot;   &quot;spades&quot;
## [2,] &quot;king&quot;  &quot;spades&quot;
## [3,] &quot;queen&quot; &quot;spades&quot;
## [4,] &quot;jack&quot;  &quot;spades&quot;
## [5,] &quot;ten&quot;   &quot;spades&quot;</code></pre>
</div>
<div id="klassen" class="section level2" number="3.5">
<h2><span class="header-section-number">3.5</span> Klassen</h2>
<p>Änderst du die Dimension deines Objektes, so ändert sich nicht der
Typ des Objektes, aber seine Klasse.</p>
<pre class="r"><code>dim(die) &lt;- c(2, 3)
die</code></pre>
<pre><code>##      [,1] [,2] [,3]
## [1,]    1    3    5
## [2,]    2    4    6</code></pre>
<pre class="r"><code>typeof(die) </code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>class(die)</code></pre>
<pre><code>## [1] &quot;matrix&quot; &quot;array&quot;</code></pre>
<p>Jedes Element der Matrix ist immer noch ein double, aber es hat eine
neue Struktur angenommen. R hat ein <code>class</code> Attribut
hinzugefügt, nachdem du seine Dimension geändert hast.<br />
Viele Funktionen suchen nach einem bestimmten <code>class</code>
Attribut, um dann gemäß seiner Eigenschaft sich zu verhalten. Die Klasse
von einem double ist numerisch, von einem <em>String</em>
<em>character</em>.</p>
<div id="datum-und-zeit" class="section level3" number="3.5.1">
<h3><span class="header-section-number">3.5.1</span> Datum und Zeit</h3>
<p>Die Zeit sieht wie ein <em>Character String</em> aus, ist aber
normalerweise ein <code>double</code> und seine Klasse ist
<code>POSIXct</code> <code>POSIXT</code>.</p>
<pre class="r"><code>now &lt;- Sys.time()
now</code></pre>
<pre><code>## [1] &quot;2023-10-08 23:44:07 CEST&quot;</code></pre>
<pre class="r"><code>typeof(now)</code></pre>
<pre><code>## [1] &quot;double&quot;</code></pre>
<pre class="r"><code>class(now)</code></pre>
<pre><code>## [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</code></pre>
<p>Jede Zeit wird im <em>POSIXct Framework</em> durch Sekunden nach dem
1.1.1970, 0 Uhr dargestellt. R stellt das Zeitobjekt als <em>double</em>
mit einem Element dar.</p>
<pre class="r"><code>unclass(now) # Sekunden seit dem 1.1.1970</code></pre>
<pre><code>## [1] 1696801448</code></pre>
</div>
<div id="faktoren" class="section level3" number="3.5.2">
<h3><span class="header-section-number">3.5.2</span> Faktoren</h3>
<p>Mit Faktoren kann R kategorielle Informationen wie z.B. Augenfarbe
oder ethnische Zugehörigkeit, abspeichern. Ein Faktor kann nur eine
bestimmte Anzahl an Werten annehmen (z.B. m/w als Geschlecht) und diese
Werte haben ihre eigene Anordnung.<br />
Kategorische Variablen sind hier also zuhause. Um einen Faktor
anzuwenden, stecke einen Vektor in die <code>factor</code> Funktion. R
recodiert die Daten in dem Vektor als <em>Integers</em>. R fügt auch
noch ein <code>levels</code> Attribut hinzu, welches ein Set von Labels
für die Darstellung der Faktorwerte enthält. Außerdem noch ein
<code>class</code> Attribut, welches die Klasse <code>factor</code>
enthält. R ordnet deinen Faktor mit <code>unclass</code>.</p>
<pre class="r"><code>gender &lt;- factor(c(&quot;male&quot;, &quot;female&quot;, &quot;female&quot;, &quot;male&quot;))
typeof(gender)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<pre class="r"><code>attributes(gender)</code></pre>
<pre><code>## $levels
## [1] &quot;female&quot; &quot;male&quot;  
## 
## $class
## [1] &quot;factor&quot;</code></pre>
<pre class="r"><code>unclass(gender)</code></pre>
<pre><code>## [1] 2 1 1 2
## attr(,&quot;levels&quot;)
## [1] &quot;female&quot; &quot;male&quot;</code></pre>
<pre class="r"><code>gender</code></pre>
<pre><code>## [1] male   female female male  
## Levels: female male</code></pre>
<p>R stellt jede <code>1</code> als <code>female</code> und jede
<code>2</code> als <code>male</code> dar. Faktoren machen es leicht,
kategorielle Variablen in ein statistisches Modell zu stecken, weil die
Variablen bereits als Zahlen codiert sind. Faktoren sehen wie
<em>Character Strings</em> aus, aber verhalten sich wie Integers.<br />
R versucht oft <em>Character Strings</em> zu Faktoren zu konvertieren,
wenn du Daten einliest. Dazu später mehr. Einen Faktor kannst du zu
einem <em>Character String</em> konvertieren mithilfe der
<code>as.character</code> Funktion.</p>
<pre class="r"><code>as.character(gender)</code></pre>
<pre><code>## [1] &quot;male&quot;   &quot;female&quot; &quot;female&quot; &quot;male&quot;</code></pre>
<p><strong>Beispiel</strong> Kartenspiel.<br />
Manche Kartenspiele ordnen einer Karte einen numerischen Wert zu, wie
z.B. Blackjack. Wir kombinieren jetzt Ass, Herz und 1 in einem Vektor.
Welcher Typ eines Vektors entsteht jetzt? <strong>Lösung</strong> Diese
Übung geht nicht klar. Jeder Vektor kann nur einen Datentypen annehmen.
R zwingt all deine Werte zu einem <em>Character String</em>. Unser
Vektor beantwortet also die Frage <code>is.character(card)</code> mit
<code>TRUE</code>.</p>
<pre class="r"><code>card &lt;- c(&quot;Ass&quot;, &quot;Herz&quot;, 1)
card</code></pre>
<pre><code>## [1] &quot;Ass&quot;  &quot;Herz&quot; &quot;1&quot;</code></pre>
<pre class="r"><code>is.character(card)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Jetzt wird das berechnen von Punkten mit Mathematik schwierig.
Multiple Datentypen werden zu einem Datentypen zusammengefasst.</p>
</div>
</div>
<div id="coercion" class="section level2" number="3.6">
<h2><span class="header-section-number">3.6</span> Coercion</h2>
<p>Ist ein <em>Character Strings</em> in einem Vector vorhanden, so
zwingt R alle anderen Elemente ebenfalls in einen <em>Character
Strings</em>. Sind Zahlen und boolsche Werte (T und F) vorhanden, so
konvertiert R diese zu Zahlen. <code>TRUE</code> wird zu 1 und
<code>FALSE</code> wird zu 0.<br />
So kannst du leicht mathematische Operatoren auf Boolsche Werte
anwenden.</p>
<pre class="r"><code>sum(c(TRUE, TRUE, FALSE, FALSE))</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>sum(c(T, T, F, F))</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>sum(c(1, 1, 0, 0))</code></pre>
<pre><code>## [1] 2</code></pre>
<p><code>sum</code> zählt also die Anzahl von <code>TRUE</code> in einem
<em>logical Vektor</em>.<br />
Mit der <code>as</code> Funktion kanst du R zwingen Daten zu
konvertieren. Natürlich nur, wenn es Sinn macht.</p>
<pre class="r"><code>as.character(1)</code></pre>
<pre><code>## [1] &quot;1&quot;</code></pre>
<pre class="r"><code>as.logical(1)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>as.numeric(FALSE)</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Es gibt aber einen Weg <em>Coercion</em> zu vermeiden. Nicht immer
wollen wir nämlich Daten zwingen einen anderen Datentypen anzunehmen.
Listen helfen hier. Vektoren, Matrizen und Arrays helfen hier nicht
mehr.</p>
</div>
<div id="listen" class="section level2" number="3.7">
<h2><span class="header-section-number">3.7</span> Listen</h2>
<p>Listen sind Vektoren nicht unähnlich. Sie stecken Daten in eine
eindimensionale Reihe. Sie gruppieren allerdings nicht individuelle
Werte, sondern R Objekte wie Vektoren und andere Listen.<br />
Zum Beispiel kannst du eine Liste erstellen aus einem numerischen Vektor
der Länge 31 als erstes Element, einem <em>Character Vektor</em> der
Länge 1 als zweites Element und einer neuen Liste der Länge 2.</p>
<pre class="r"><code>list1 &lt;- list(100:130, &quot;R&quot;, list(TRUE, FALSE))
list1</code></pre>
<pre><code>## [[1]]
##  [1] 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118
## [20] 119 120 121 122 123 124 125 126 127 128 129 130
## 
## [[2]]
## [1] &quot;R&quot;
## 
## [[3]]
## [[3]][[1]]
## [1] TRUE
## 
## [[3]][[2]]
## [1] FALSE</code></pre>
<p><code>100</code> ist das erste Unterelement des ersten Element.
<code>"R"</code> das erste Unterelement des zweiten Elements.<br />
Die Struktur von Listen kann sehr kompliziert und lang werden. Aber die
Flexibilität macht Listen zu einem sehr nützlichen Ablageort für
verschiedenste Daten und Informationen. <strong>Mit Listen kannst du
alles zusammen lagern.</strong></p>
<p><strong>Beispiel</strong> Liste für Kartenbeispiel.</p>
<p>Eine Spielkarte mit Wert können wir so leicht speichern. Aus
<em>Character Vektor</em>, <em>Character Vektor</em> und numerischem
Vektor. Alle mit Länge 1.</p>
<pre class="r"><code>card &lt;- list(&quot;ace&quot;, &quot;hearts&quot;, 1)
card</code></pre>
<pre><code>## [[1]]
## [1] &quot;ace&quot;
## 
## [[2]]
## [1] &quot;hearts&quot;
## 
## [[3]]
## [1] 1</code></pre>
<p>Ein ganzes Deck Karten kannst du auch so speichern. Als Liste mit
Unter-/Sublisten. Du kannst aber einfach eine spezielle Klasse von
Listen benutzen. Einen <em>Data Frame</em>.</p>
</div>
<div id="data-frames" class="section level2" number="3.8">
<h2><span class="header-section-number">3.8</span> Data Frames</h2>
<p>Data Frames sind die 2-dimensionale Version von Listen. Sie speichern
Daten ähnlich wie Excel in einer 2-dim Tabelle. Aus Vektoren werden
Spalten, so dass jede Spalte aus einem anderen Datentyp bestehen kann.
Innerhalb der Spalte natürlich nicht.</p>
<table>
<thead>
<tr class="header">
<th>numeric</th>
<th>character</th>
<th>logical</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>“R”</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>2</td>
<td>“ist”</td>
<td>TRUE</td>
</tr>
<tr class="odd">
<td>3</td>
<td>“doch”</td>
<td>TRUE</td>
</tr>
<tr class="even">
<td>4</td>
<td>“eigentlich”</td>
<td>FALSE</td>
</tr>
<tr class="odd">
<td>5</td>
<td>“ganz”</td>
<td>FALSE</td>
</tr>
<tr class="even">
<td>6</td>
<td>“cool”</td>
<td>TRUE</td>
</tr>
</tbody>
</table>
<p>Die Spalten müssen natürlich alle gleich lang sein.</p>
<pre class="r"><code>df &lt;- data.frame(Kartenwert = c(&quot;ass&quot;, &quot;zwei&quot;, &quot;sechs&quot;), Farbe = c(&quot;kreuz&quot;, &quot;kreuz&quot;, &quot;kreuz&quot;), Zahlenwert = c(1, 2, 6))
df</code></pre>
<pre><code>##   Kartenwert Farbe Zahlenwert
## 1        ass kreuz          1
## 2       zwei kreuz          2
## 3      sechs kreuz          6</code></pre>
<p>Die Spalten kannst du natürlich beliebig benennen.<br />
Der Typ (type) eines <em>Data Frames</em> ist eine Liste. Du kannst
sehen aus welchen Typen der Objekte die Liste/<em>Data Frame</em>
zusammen gesetzt wurde, mithilfe der <code>str</code> Funktion.</p>
<pre class="r"><code>typeof(df)</code></pre>
<pre><code>## [1] &quot;list&quot;</code></pre>
<pre class="r"><code>class(df)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<pre class="r"><code>str(df)</code></pre>
<pre><code>## &#39;data.frame&#39;:    3 obs. of  3 variables:
##  $ Kartenwert: chr  &quot;ass&quot; &quot;zwei&quot; &quot;sechs&quot;
##  $ Farbe     : chr  &quot;kreuz&quot; &quot;kreuz&quot; &quot;kreuz&quot;
##  $ Zahlenwert: num  1 2 6</code></pre>
<p>R hat die <em>Character Strings</em> als Faktoren abgespeichert. Du
kannst dies verhindern durch das Argument
<code>stringsAsFactors = FALSE</code>. Wenn du <code>T</code> wählst,
ändert sich <code>chr</code>zu <code>Factor</code> in der Ausgabe.</p>
<pre class="r"><code>df &lt;- data.frame(Kartenwert = c(&quot;ass&quot;, &quot;zwei&quot;, &quot;sechs&quot;), Farbe = c(&quot;kreuz&quot;, &quot;kreuz&quot;, &quot;kreuz&quot;), Kartenzahl = c(1, 2, 6), stringsAsFactors = FALSE)</code></pre>
<p>Unser Kartendeck kann jetzt also gebaut werden. Zeilen sind die
Karten. Spalten sind die Typen der Werte: 52 Zeilen und 3 Spalten haben
wir. Auf englisch komplett.</p>
<pre class="r"><code>deck &lt;- data.frame(
  face = c(&quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, &quot;nine&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;,
    &quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;, &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, 
    &quot;nine&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;, &quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;, 
    &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, &quot;nine&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;, &quot;five&quot;, 
    &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;, &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, &quot;nine&quot;, 
    &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;, &quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;),  
  suit = c(&quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, 
    &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, 
    &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, 
    &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, 
    &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, 
    &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;hearts&quot;, 
    &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, 
    &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;), 
  value = c(13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 
    7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 
    10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
)
deck</code></pre>
<pre><code>##     face     suit value
## 1   king   spades    13
## 2  queen   spades    12
## 3   jack   spades    11
## 4    ten   spades    10
## 5   nine   spades     9
## 6  eight   spades     8
## 7  seven   spades     7
## 8    six   spades     6
## 9   five   spades     5
## 10  four   spades     4
## 11 three   spades     3
## 12   two   spades     2
## 13   ace   spades     1
## 14  king    clubs    13
## 15 queen    clubs    12
## 16  jack    clubs    11
## 17   ten    clubs    10
## 18  nine    clubs     9
## 19 eight    clubs     8
## 20 seven    clubs     7
## 21   six    clubs     6
## 22  five    clubs     5
## 23  four    clubs     4
## 24 three    clubs     3
## 25   two    clubs     2
## 26   ace    clubs     1
## 27  king diamonds    13
## 28 queen diamonds    12
## 29  jack diamonds    11
## 30   ten diamonds    10
## 31  nine diamonds     9
## 32 eight diamonds     8
## 33 seven diamonds     7
## 34   six diamonds     6
## 35  five diamonds     5
## 36  four diamonds     4
## 37 three diamonds     3
## 38   two diamonds     2
## 39   ace diamonds     1
## 40  king   hearts    13
## 41 queen   hearts    12
## 42  jack   hearts    11
## 43   ten   hearts    10
## 44  nine   hearts     9
## 45 eight   hearts     8
## 46 seven   hearts     7
## 47   six   hearts     6
## 48  five   hearts     5
## 49  four   hearts     4
## 50 three   hearts     3
## 51   two   hearts     2
## 52   ace   hearts     1</code></pre>
<p>Lange Tipparbeit ist zu vermeiden, wenn möglich durch Einlesen von
Daten.</p>
</div>
<div id="daten-laden" class="section level2" number="3.9">
<h2><span class="header-section-number">3.9</span> Daten laden</h2>
<p>Rechts oben im Fenster unter <strong>Environment</strong> kannst du
Daten aus verschiedenen Quellen einlesen. <em>From text</em> und dann
die .csv einlesen oder direkt unter <code>read.csv</code>. Dann folgt
unter “…” die Quelle. Unter <code>head(deck)</code> kannst du dir dann
die ersten Zeilen ausgeben lassen. Die bekannten Hilfeseiten helfen auch
hier weiter, falls es Probleme gibt.</p>
</div>
<div id="daten-speichern" class="section level2" number="3.10">
<h2><span class="header-section-number">3.10</span> Daten speichern</h2>
<p>Eine Kopie von <code>deck</code> können wir als neue <em>.csv</em>
Datei speichern, wenn wir wollen.</p>
<pre class="r"><code>write.csv(deck, file = &quot;cards.csv&quot;, row.names = FALSE)</code></pre>
<p>R speichert deine Datei in deiner working directory. Um den Ort zu
sehen, gib <code>getwd()</code> ein. Den Speicherprozess kannst du
deinen Ansprüchen natürlich noch anpassen, siehe Hilfe.<br />
Zuerst gibst du aber <code>write.csv</code> den Namen des Data Frames,
den du speichern willst. Dann folgt der Name der Datei.
<code>row.names = FALSE</code> verhindert das Speichern einer
Zählvariable als erste Spalte.</p>
</div>
</div>
<div id="r-notation" class="section level1" number="4">
<h1><span class="header-section-number">4</span> R Notation</h1>
<p>Jetzt wollen wir unser Kartendeck mischen oder Karten ausgeben.</p>
<div id="werte-auswählen" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Werte auswählen</h2>
<p>Wollen wir jetzt Wert(e) von unserem Objekt auswählen, z.B. unserem
<em>Data Frame</em>, so nehmen wir den Namen des <em>Data Frames</em>,
gefolgt von eckigen Klammern.</p>
<p><code>deck[ , ]</code></p>
<p>Indices durch ein Komma getrennt, packen wir in die Klammer. Die
Indices sagen R, welchen Wert es zu wählen hat. Oder welche Werte. Der
erste Wert steht für die Zeilen und der zweite für die Spalten. Ein
Index kann auf sechs verschiedene Arten erzeugt werden.</p>
<ul>
<li>Positive ganze Zahlen</li>
<li>Negative ganze Zahlen</li>
<li>Null</li>
<li>Leerer Raum</li>
<li>Logical Values</li>
<li>Namen</li>
</ul>
<div id="positive-ganze-zahlen" class="section level3" number="4.1.1">
<h3><span class="header-section-number">4.1.1</span> Positive ganze
Zahlen</h3>
<p>In R werden positive ganze Zahlen wie die <em>ij</em> Notation in der
Linearen Algebra gehandhabt: <code>deck[i, j]</code> gibt den Wert von
<code>deck</code> zurück, der sich in der Reihe i und Spalte j
befindet.</p>
<pre class="r"><code>head(deck)</code></pre>
<pre><code>##    face   suit value
## 1  king spades    13
## 2 queen spades    12
## 3  jack spades    11
## 4   ten spades    10
## 5  nine spades     9
## 6 eight spades     8</code></pre>
<pre class="r"><code>deck[1, 1]</code></pre>
<pre><code>## [1] &quot;king&quot;</code></pre>
<p>Um mehr als einen Wert auszugeben, benutze einen Vektor bestehend aus
positiven ganzen Zahlen. Zweimal können wir die erste Zeile auch
ausgeben, durch Wiederholung des Index.</p>
<pre class="r"><code>deck[1, c(1, 2, 3)]</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deck[1, 1:3]</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>new &lt;- deck[1, c(1, 2, 3)]
new</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deck[c(1,1), c(1, 2, 3)]</code></pre>
<pre><code>##     face   suit value
## 1   king spades    13
## 1.1 king spades    13</code></pre>
<p>Das Notationssystem von R ist nicht nur auf <em>Data Frames</em>
beschränkt. Solange du einen Index für jede Dimension anbietest.</p>
<pre class="r"><code>vec &lt;- c(6, 1, 3, 6, 10, 5)
vec[1:3]</code></pre>
<pre><code>## [1] 6 1 3</code></pre>
<p>Ab 2 Spalten erhälst du natürlich wieder einen <em>Data Frame</em>.
Eine Spalte liefert einen Vektor. Wenn du stattdessen einen <em>Data
Frame</em> haben willst, füge das optionale Argument
<code>drop = FALSE</code> hinzu.</p>
<pre class="r"><code>deck[1:2, 1:2]</code></pre>
<pre><code>##    face   suit
## 1  king spades
## 2 queen spades</code></pre>
<pre class="r"><code>deck[1:2, 1]</code></pre>
<pre><code>## [1] &quot;king&quot;  &quot;queen&quot;</code></pre>
<pre class="r"><code>deck[1:2, 1, drop = FALSE]</code></pre>
<pre><code>##    face
## 1  king
## 2 queen</code></pre>
</div>
<div id="negative-ganze-zahlen" class="section level3" number="4.1.2">
<h3><span class="header-section-number">4.1.2</span> Negative ganze
Zahlen</h3>
<p>Negative ganze Zahlen machen genau das Gegeteil von positiven ganzen
Zahlen. R gibt jedes Element bis auf Elemente in negativem Index
wider.<br />
Alles bis auf die erste Zeile wird ausgegeben:
<code>deck[-1, 1:3]</code>. Oder nur die erste Zeile.</p>
<pre class="r"><code>deck[-(2:52), 1:3]</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<p>Willst du die Mehrheit deines Data Frames ausgeben, können negative
Integers ein effizienterer Weg sein. Im selben Index können jedoch nicht
positive und negative ganze Zahlen gemeinsam stehen:
<code>deck[c(-1, 1), 1]</code>. in verschiedenen Indices ist es aber
möglich: <code>deck[-1, 1]</code>.</p>
</div>
<div id="null" class="section level3" number="4.1.3">
<h3><span class="header-section-number">4.1.3</span> Null</h3>
<p>Null als Index? Leeres Objekt!</p>
<pre class="r"><code>deck[0, 0]</code></pre>
<pre><code>## Dataframe mit 0 Spalten und 0 Zeilen</code></pre>
<p>Irgendwie sinnlos, aber möglich.</p>
</div>
<div id="leerer-raum-blank-spaces" class="section level3"
number="4.1.4">
<h3><span class="header-section-number">4.1.4</span> Leerer Raum (Blank
Spaces)</h3>
<p>Wähle jeden Wert der Dimension.</p>
<pre class="r"><code>deck[1, ]</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
</div>
<div id="logical-values" class="section level3" number="4.1.5">
<h3><span class="header-section-number">4.1.5</span> Logical Values</h3>
<p>R gibt jede Reihe wider, die mit einem <code>TRUE</code>
korrespondiert.</p>
<pre class="r"><code>deck[1, c(TRUE, TRUE, FALSE)]</code></pre>
<pre><code>##   face   suit
## 1 king spades</code></pre>
<pre class="r"><code>rows &lt;- c(TRUE, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
  F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, 
  F, F, F, F, F, F, F, F, F, F, F, F, F, F)
deck[rows, ]</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
</div>
<div id="namen-1" class="section level3" number="4.1.6">
<h3><span class="header-section-number">4.1.6</span> Namen</h3>
<p>Die Elemente kannst du natürlich auch beim Namen nennen, wenn sie
welche haben. Bei <em>Data Frames</em> meist.</p>
<pre class="r"><code>deck[1, c(&quot;face&quot;, &quot;suit&quot;, &quot;value&quot;)]</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deck[ , &quot;value&quot;]</code></pre>
<pre><code>##  [1] 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2
## [26]  1 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3
## [51]  2  1</code></pre>
</div>
</div>
<div id="karten-ausgeben" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Karten ausgeben</h2>
<p><strong>Aufgabe</strong> Karte ausgeben. Mithilfe von
<code>function(){}</code>.</p>
<pre class="r"><code>deal &lt;- function(cards) {
  cards[1, ]
}
deal(deck)</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<p>Bei Wiederholung wird allerdings immer bloß die erste Zeile
ausgegeben. Langweilig. Mische die Karten nach jeder Ausgabe.</p>
</div>
<div id="mische-das-deck" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Mische das Deck</h2>
<p>In unserem Deck ist jede Zeile eine Karte des Decks. Sortiere also
die Zeilen neu.</p>
<pre class="r"><code>deck2 &lt;- deck[1:52, ]
head(deck2)</code></pre>
<pre><code>##    face   suit value
## 1  king spades    13
## 2 queen spades    12
## 3  jack spades    11
## 4   ten spades    10
## 5  nine spades     9
## 6 eight spades     8</code></pre>
<p>Bisher hat sich nichts verändert. Jetzt schon.</p>
<pre class="r"><code>deck3 &lt;- deck[c(2, 1, 3:52), ]
head(deck3)</code></pre>
<pre><code>##    face   suit value
## 2 queen spades    12
## 1  king spades    13
## 3  jack spades    11
## 4   ten spades    10
## 5  nine spades     9
## 6 eight spades     8</code></pre>
<p>Wir wollen aber doch eine zufällige Anordung! Benutze die
<code>sample</code> Funktion.</p>
<pre class="r"><code>random &lt;- sample(1:52, size = 3)
random</code></pre>
<pre><code>## [1] 15 13  6</code></pre>
<pre class="r"><code>random &lt;- sample(1:52, size = 52)
random</code></pre>
<pre><code>##  [1]  9 23 50  3 14 38 49 32 42 31 22 24 25 46 19 15 39 34 41 17  7  8 35 10 36
## [26] 37 28 21 33 45 13 27 52 40  2 48 26 30 29 20 47  5 51 12  6 11 16 43  4  1
## [51] 18 44</code></pre>
<pre class="r"><code>deck4 &lt;- deck[random, ]
head(deck4)</code></pre>
<pre><code>##     face     suit value
## 9   five   spades     5
## 23  four    clubs     4
## 50 three   hearts     3
## 3   jack   spades    11
## 14  king    clubs    13
## 38   two diamonds     2</code></pre>
<p><strong>Aufgabe</strong> In einer Funktion.<br />
Schreibe die <code>shuffle</code> Funktion. Nimm einen Data Frame und
gib eine gemischte Kopie wider.</p>
<pre class="r"><code>shuffle &lt;- function(cards) {
  random &lt;- sample(1:52, size = 52)
  deck[random, ]
}</code></pre>
<p>Mische jetzt nach jedem Aufdecken.</p>
<pre class="r"><code>deal(deck)</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deck2 &lt;- shuffle(deck)
deal(deck2)</code></pre>
<pre><code>##    face     suit value
## 27 king diamonds    13</code></pre>
</div>
<div id="dollarzeichen-und-doppelte-klammern" class="section level2"
number="4.4">
<h2><span class="header-section-number">4.4</span> Dollarzeichen und
doppelte Klammern</h2>
<p>Du kannst, um eine Spalte von einem <em>Data Frame</em> auszuwählen,
die <code>$</code> Syntax benutzen. Schreibe den Namen des <em>Data
Frames</em> und dann den Spaltennamen nach dem Dollarzeichen
<code>$</code>.</p>
<pre class="r"><code>deck$value</code></pre>
<pre><code>##  [1] 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3  2
## [26]  1 13 12 11 10  9  8  7  6  5  4  3  2  1 13 12 11 10  9  8  7  6  5  4  3
## [51]  2  1</code></pre>
<p>Als Vektor erfolgt die Ausgabe, mit der du dann weiterarbeiten
kannst.</p>
<pre class="r"><code>mean(deck$value)</code></pre>
<pre><code>## [1] 7</code></pre>
<pre class="r"><code>median(deck$value)</code></pre>
<pre><code>## [1] 7</code></pre>
<p>Dieselbe Notation kannst du bei Listen benutzen.</p>
<pre class="r"><code>lst &lt;- list(numbers = c(1, 2), logical = TRUE, strings = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;))
lst</code></pre>
<pre><code>## $numbers
## [1] 1 2
## 
## $logical
## [1] TRUE
## 
## $strings
## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot;</code></pre>
<pre class="r"><code>lst[1]</code></pre>
<pre><code>## $numbers
## [1] 1 2</code></pre>
<p>Eine kleinere Liste mit nur einem Element ist die Ausgabe, wobei du
auf diese Liste leider keine Funktion wie <code>sum</code> anwenden
kannst.<br />
Benutzt du die <code>$</code> Notation, R gibt die ausgewählten Werte
wider, wie sie sind, ohne Listenstruktur.</p>
<pre class="r"><code>lst$numbers</code></pre>
<pre><code>## [1] 1 2</code></pre>
<pre class="r"><code>sum(lst$numbers)</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Wenn die Elemente deiner Liste keine Namen haben, kannst du doppelte,
eckige Klammern benutzen. Es macht das gleiche wie die <code>$</code>
Notation.</p>
<pre class="r"><code>lst[[1]]</code></pre>
<pre><code>## [1] 1 2</code></pre>
<ul>
<li>eine eckige Klammer bei Liste: kleinere Liste<br />
</li>
<li>doppelte eckige Klammer bei Liste: Werte, die in Listenelement
waren.</li>
</ul>
<pre class="r"><code>lst[&quot;numbers&quot;]</code></pre>
<pre><code>## $numbers
## [1] 1 2</code></pre>
<pre class="r"><code>lst[[&quot;numbers&quot;]]</code></pre>
<pre><code>## [1] 1 2</code></pre>
<p>Denke an einen Güterzug. Aus einem großen Zug mit vielen Wagons wird
ein kleiner Zug mit einem Wagon bei eckigen Klammern. Bei doppelten
eckigen Klammern wird der Inhalt des Wagons entladen.</p>
</div>
</div>
<div id="werte-modifizieren" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Werte modifizieren</h1>
<p>Manchmal muss ein Wert geändert werden. Bei unserem Spiel zum
Beispiel kann es sein, das ein Ass einen höheren Wert hat, je nach
Spiel.<br />
Wir beginnen mit einer Kopie von unserem Kartendeck, sodass wir
manipulieren können.</p>
<pre class="r"><code>deck2 &lt;- deck</code></pre>
<div id="werte-verändern-vor-ort" class="section level2" number="5.1">
<h2><span class="header-section-number">5.1</span> Werte verändern vor
Ort</h2>
<p>Werte können innerhalb eines Objektes modifiziert werden. Welchen
Wert wollen wir modifizieren? Dann wird überschrieben. R aktualisiert
den gewählten Wert im originalen Objekt vor Ort (so nenn ich das mal).
Modifizieren ist einfach.</p>
<pre class="r"><code>vec &lt;- c(0, 0, 0, 0, 0, 0)
vec</code></pre>
<pre><code>## [1] 0 0 0 0 0 0</code></pre>
<pre class="r"><code>vec[1]</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>vec[1] &lt;- 1000
vec</code></pre>
<pre><code>## [1] 1000    0    0    0    0    0</code></pre>
<p>Mehrere Werte kannst du auf einmal ersetzen. Die Anzahl muss
natürlich gleich sein.</p>
<pre class="r"><code>vec[c(1, 3, 5)] &lt;- c(1, 1, 1)
vec</code></pre>
<pre><code>## [1] 1 0 1 0 1 0</code></pre>
<pre class="r"><code>vec[4:6] &lt;- vec[4:6] + 1
vec</code></pre>
<pre><code>## [1] 1 0 1 1 2 1</code></pre>
<p>Auch kannst du Werte setzen, die noch gar nicht in deinem Vektor
vorhanden sind. Das Objekt wird so automatisch erweitert.</p>
<pre class="r"><code>vec[7] &lt;- 0
vec</code></pre>
<pre><code>## [1] 1 0 1 1 2 1 0</code></pre>
<p>So kann eine ganz neue Variable deinem <em>Data Frame</em>
hinzugefügt werden.</p>
<pre class="r"><code>deck2$new &lt;- 1:52
head(deck2)</code></pre>
<pre><code>##    face   suit value new
## 1  king spades    13   1
## 2 queen spades    12   2
## 3  jack spades    11   3
## 4   ten spades    10   4
## 5  nine spades     9   5
## 6 eight spades     8   6</code></pre>
<p>Spalten können leicht von einem <em>Data Frame</em> entfernt werden
durch <code>NULL</code>.</p>
<pre class="r"><code>deck2$new &lt;- NULL
head(deck2)</code></pre>
<pre><code>##    face   suit value
## 1  king spades    13
## 2 queen spades    12
## 3  jack spades    11
## 4   ten spades    10
## 5  nine spades     9
## 6 eight spades     8</code></pre>
<p>Wir wollen die Kartenzahl aller Asse auf 14 ändern, also müssen wir
erst einmal die Ass-Karten ausfindig machen.</p>
<pre class="r"><code>deck2[c(13, 26, 39, 52), ]</code></pre>
<pre><code>##    face     suit value
## 13  ace   spades     1
## 26  ace    clubs     1
## 39  ace diamonds     1
## 52  ace   hearts     1</code></pre>
<pre class="r"><code>deck2[c(13, 26, 39, 52), 3]</code></pre>
<pre><code>## [1] 1 1 1 1</code></pre>
<pre class="r"><code>deck2$value[c(13, 26, 39, 52)]</code></pre>
<pre><code>## [1] 1 1 1 1</code></pre>
<p>Ersetzen ist jetzt ziemlich einfach. Ersetzen vor Ort und dann
schauen wir uns die ersten 14 Karten an.</p>
<pre class="r"><code>deck2$value[c(13, 26, 39, 52)] &lt;- c(14, 14, 14, 14)
#oder
deck2$value[c(13, 26, 39, 52)] &lt;- 14
head(deck2, 13)</code></pre>
<pre><code>##     face   suit value
## 1   king spades    13
## 2  queen spades    12
## 3   jack spades    11
## 4    ten spades    10
## 5   nine spades     9
## 6  eight spades     8
## 7  seven spades     7
## 8    six spades     6
## 9   five spades     5
## 10  four spades     4
## 11 three spades     3
## 12   two spades     2
## 13   ace spades    14</code></pre>
<p>Hier wussten wir natürlich genau wo sich die Asse befinden. Aber wenn
wir das Deck mischen, nicht mehr. Schauen wir uns die ersten 20 Karten
an.</p>
<pre class="r"><code>deck3 &lt;- shuffle(deck)
head(deck3, 20)</code></pre>
<pre><code>##     face     suit value
## 48  five   hearts     5
## 37 three diamonds     3
## 7  seven   spades     7
## 26   ace    clubs     1
## 6  eight   spades     8
## 17   ten    clubs    10
## 35  five diamonds     5
## 34   six diamonds     6
## 8    six   spades     6
## 13   ace   spades     1
## 3   jack   spades    11
## 50 three   hearts     3
## 40  king   hearts    13
## 20 seven    clubs     7
## 39   ace diamonds     1
## 22  five    clubs     5
## 27  king diamonds    13
## 1   king   spades    13
## 33 seven diamonds     7
## 23  four    clubs     4</code></pre>
<p>Aber warum nicht R einfach nach den Assen fragen? Mit <em>logical
Subsetting</em>.</p>
</div>
<div id="logical-subsetting" class="section level2" number="5.2">
<h2><span class="header-section-number">5.2</span> Logical
Subsetting</h2>
<p>Wir erinnern uns an Vektoren mit <code>TRUE</code> und
<code>FALSE</code>.</p>
<pre class="r"><code>vec</code></pre>
<pre><code>## [1] 1 0 1 1 2 1 0</code></pre>
<pre class="r"><code>vec[c(FALSE, FALSE, FALSE, FALSE, TRUE, FALSE, FALSE)]</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Einen langen Vektor mit <code>T</code> und <code>F</code> zu füllen,
hört sich aufwändig an. Aber das müssen wir nicht selbst erstellen. Ein
<em>logical test</em> kann hier helfen.</p>
<div id="logical-test" class="section level3" number="5.2.1">
<h3><span class="header-section-number">5.2.1</span> Logical Test</h3>
<p>Ein <em>logical test</em> ist ein Vergleich wie z.B. “ist 1 kleiner
als 2?”, <code>1 &lt; 2</code>, oder <code>3 &gt; 4</code>. R liefert
sieben logische Operatoren.</p>
<table>
<thead>
<tr class="header">
<th>Operator</th>
<th>Syntax</th>
<th>Test</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>&gt;</code></td>
<td><code>a &gt; b</code></td>
<td>Ist a größer als b?</td>
</tr>
<tr class="even">
<td><code>&gt;=</code></td>
<td><code>a &gt;= b</code></td>
<td>Ist a größer gleich b?</td>
</tr>
<tr class="odd">
<td><code>&lt;</code></td>
<td><code>a &lt; b</code></td>
<td>Ist a kleiner als b?</td>
</tr>
<tr class="even">
<td><code>&lt;=</code></td>
<td><code>a &lt;= b</code></td>
<td>Ist a kleiner gleich b?</td>
</tr>
<tr class="odd">
<td><code>==</code></td>
<td><code>a == b</code></td>
<td>Ist a gleich b?</td>
</tr>
<tr class="even">
<td><code>!=</code></td>
<td><code>a != b</code></td>
<td>Ist a nicht gleich b?</td>
</tr>
<tr class="odd">
<td><code>%in%</code></td>
<td><code>a %in% c(a,b,c)</code></td>
<td>Ist a in der Gruppe von a,b,c?</td>
</tr>
</tbody>
</table>
<p>Jeder Operator gibt ein <code>TRUE</code> oder <code>FALSE</code>
zurück. Vergleichst du Vektoren, nimmt R elementenweise Vergleiche
vor.</p>
<pre class="r"><code>1 &gt; 2</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>1 &gt; c(0, 1, 2)</code></pre>
<pre><code>## [1]  TRUE FALSE FALSE</code></pre>
<pre class="r"><code>c(1, 2, 3) == c(3, 2, 1)</code></pre>
<pre><code>## [1] FALSE  TRUE FALSE</code></pre>
<p><code>%in%</code> testet, ob der/die Wert/e auf der linken Seite im
Vektor auf der rechten Seite vertreten sind. Hier wird nicht
elementweise getestet. Ist jeder Wert auf der linken Seite irgendwo im
Vektor auf der rechten Seite?</p>
<pre class="r"><code>1 %in% c(3, 4, 5)</code></pre>
<pre><code>## [1] FALSE</code></pre>
<pre class="r"><code>c(1,2) %in% c(3, 4, 5)</code></pre>
<pre><code>## [1] FALSE FALSE</code></pre>
<pre class="r"><code>c(1, 2, 3) %in% c(3, 4, 5)</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>c(1, 2, 3, 4) %in% c(3, 4, 5)</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE  TRUE</code></pre>
<p>Verwechsel nicht <code>==</code> und <code>=</code>. Das eine ist ein
Vergleich, das andere ist eine Zuordnung, wie auch
<code>&lt;-</code>.</p>
<p><strong>Aufgabe</strong> Wie viele Asse?</p>
<p>Extrahiere die Kartenwete/face Spalte <code>face</code> von
<code>deck2</code> und teste jeden Wert (ob er ein Ass ist). Zähle die
Anzahl der Asse.</p>
<pre class="r"><code>deck$face</code></pre>
<pre><code>##  [1] &quot;king&quot;  &quot;queen&quot; &quot;jack&quot;  &quot;ten&quot;   &quot;nine&quot;  &quot;eight&quot; &quot;seven&quot; &quot;six&quot;   &quot;five&quot; 
## [10] &quot;four&quot;  &quot;three&quot; &quot;two&quot;   &quot;ace&quot;   &quot;king&quot;  &quot;queen&quot; &quot;jack&quot;  &quot;ten&quot;   &quot;nine&quot; 
## [19] &quot;eight&quot; &quot;seven&quot; &quot;six&quot;   &quot;five&quot;  &quot;four&quot;  &quot;three&quot; &quot;two&quot;   &quot;ace&quot;   &quot;king&quot; 
## [28] &quot;queen&quot; &quot;jack&quot;  &quot;ten&quot;   &quot;nine&quot;  &quot;eight&quot; &quot;seven&quot; &quot;six&quot;   &quot;five&quot;  &quot;four&quot; 
## [37] &quot;three&quot; &quot;two&quot;   &quot;ace&quot;   &quot;king&quot;  &quot;queen&quot; &quot;jack&quot;  &quot;ten&quot;   &quot;nine&quot;  &quot;eight&quot;
## [46] &quot;seven&quot; &quot;six&quot;   &quot;five&quot;  &quot;four&quot;  &quot;three&quot; &quot;two&quot;   &quot;ace&quot;</code></pre>
<pre class="r"><code>deck$face == &quot;ace&quot;</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [13]  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [25] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [37] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [49] FALSE FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>sum(deck$face == &quot;ace&quot;)</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Vergiss nicht die Gänsefüßchen. Sonst sucht R ein Objekt namens
<code>ace</code>. Du kannst diese Methode verwenden, um Asse zu finden
und dann in deinem Deck zu ersetzen. Sogar nachdem gemischt wurde. Bilde
erst einen <em>logical test</em>, um die Asse zu identifizieren. Dann
benutze den <em>logical Vektor</em> als Index.</p>
<pre class="r"><code>deck3$face == &quot;ace&quot;</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [13] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE
## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [49] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>deck3$value[deck3$face == &quot;ace&quot;]</code></pre>
<pre><code>## [1] 1 1 1 1</code></pre>
<p>Jetzt wechsel die Ass-Werte in <code>deck3</code>.</p>
<pre class="r"><code>deck3$value[deck3$face == &quot;ace&quot;] &lt;- 14
head(deck3, 20)</code></pre>
<pre><code>##     face     suit value
## 48  five   hearts     5
## 37 three diamonds     3
## 7  seven   spades     7
## 26   ace    clubs    14
## 6  eight   spades     8
## 17   ten    clubs    10
## 35  five diamonds     5
## 34   six diamonds     6
## 8    six   spades     6
## 13   ace   spades    14
## 3   jack   spades    11
## 50 three   hearts     3
## 40  king   hearts    13
## 20 seven    clubs     7
## 39   ace diamonds    14
## 22  five    clubs     5
## 27  king diamonds    13
## 1   king   spades    13
## 33 seven diamonds     7
## 23  four    clubs     4</code></pre>
<p><strong>Aufgabe</strong> Jeder Kartenwert ist gleich
<code>0</code>.</p>
<pre class="r"><code>deck4 &lt;- deck
deck4$value &lt;- 0
head(deck4, 13)</code></pre>
<pre><code>##     face   suit value
## 1   king spades     0
## 2  queen spades     0
## 3   jack spades     0
## 4    ten spades     0
## 5   nine spades     0
## 6  eight spades     0
## 7  seven spades     0
## 8    six spades     0
## 9   five spades     0
## 10  four spades     0
## 11 three spades     0
## 12   two spades     0
## 13   ace spades     0</code></pre>
<p>Gib jedem Herz einen Wert von <code>1</code>.</p>
<pre class="r"><code>deck4$suit == &quot;hearts&quot;</code></pre>
<pre><code>##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [37] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
## [49]  TRUE  TRUE  TRUE  TRUE</code></pre>
<pre class="r"><code>deck4$value[deck4$suit == &quot;hearts&quot;] &lt;- 1
deck4$value[deck4$suit == &quot;hearts&quot;]</code></pre>
<pre><code>##  [1] 1 1 1 1 1 1 1 1 1 1 1 1 1</code></pre>
<p>In Hearts hat die Pik Dame (queen spades) eine/n Kartenzahl/Value von
13. Schauen wir uns die Damen an und die Piks.</p>
<pre class="r"><code>deck4[deck4$face == &quot;queen&quot;, ]</code></pre>
<pre><code>##     face     suit value
## 2  queen   spades     0
## 15 queen    clubs     0
## 28 queen diamonds     0
## 41 queen   hearts     1</code></pre>
<pre class="r"><code>deck4[deck4$suit == &quot;spades&quot;, ]</code></pre>
<pre><code>##     face   suit value
## 1   king spades     0
## 2  queen spades     0
## 3   jack spades     0
## 4    ten spades     0
## 5   nine spades     0
## 6  eight spades     0
## 7  seven spades     0
## 8    six spades     0
## 9   five spades     0
## 10  four spades     0
## 11 three spades     0
## 12   two spades     0
## 13   ace spades     0</code></pre>
<p>Wir wollen aber nur eine Karte. Wie kombinieren wir beide
Eigenschaften? Mit <em>Boolean Operatoren</em>.</p>
</div>
<div id="boolean-operatoren" class="section level3" number="5.2.2">
<h3><span class="header-section-number">5.2.2</span> Boolean
Operatoren</h3>
<p>Boolean Operatoren sind Dinge wie <em>und</em> (<code>&amp;</code>)
und <em>oder</em> (<code>|</code>). Sie schmeißen das Ergebnis von
*multiplen logical Tests in ein <code>TRUE</code> oder
<code>FALSE</code>. R hat sechs Boolean Operatoren.</p>
<pre class="r"><code>library(knitr)</code></pre>
<pre><code>## Warning: Paket &#39;knitr&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre class="r"><code>library(kableExtra)</code></pre>
<pre><code>## Warning: Paket &#39;kableExtra&#39; wurde unter R Version 4.2.3 erstellt</code></pre>
<pre class="r"><code>df &lt;- data.frame(Operator = c(&quot;`&amp;`&quot;,&quot;`|`&quot;, &quot;`xor`&quot;, &quot;`!`&quot;, &quot;`any`&quot;, &quot;`all`&quot;), 
                 Syntax = c(&quot;`cond1 &amp; cond2`&quot;, &quot;`cond1 | cond2`&quot;, 
                          &quot;`xor(cond1, cond2)`&quot;, &quot;`!cond1`&quot;,
                          &quot;`any(cond1, cond2, ...)`&quot;,
                          &quot;`all(cond1, cond2, ...)`&quot;),
                 Test = c(&quot;Sind sowohl cond1 als auch cond2 wahr?&quot;,
                          &quot;Ist mind. eins von cond1, cond2 wahr?&quot;,
                          &quot;Ist genau eins von cond1, cond2 wahr?&quot;,
                          &quot;Ist cond1 falsch? Umkehrung von logical test&quot;,
                          &quot;Sind irgendwelche der Conditions wahr?&quot;,
                          &quot;Sind alle der Conditions wahr? Gleich b?&quot;))
kable(df)|&gt;
  kable_styling(latex_options = &quot;striped&quot;)|&gt;
  scroll_box(width = &quot;100%&quot;, height = &quot;200px&quot;)</code></pre>
<div
style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:200px; overflow-x: scroll; width:100%; ">
<table class="table" style="margin-left: auto; margin-right: auto;">
<thead>
<tr>
<th style="text-align:left;position: sticky; top:0; background-color: #FFFFFF;">
Operator
</th>
<th style="text-align:left;position: sticky; top:0; background-color: #FFFFFF;">
Syntax
</th>
<th style="text-align:left;position: sticky; top:0; background-color: #FFFFFF;">
Test
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
<code>&amp;amp;</code>
</td>
<td style="text-align:left;">
<code>cond1 &amp;amp; cond2</code>
</td>
<td style="text-align:left;">
Sind sowohl cond1 als auch cond2 wahr?
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>|</code>
</td>
<td style="text-align:left;">
<code>cond1 | cond2</code>
</td>
<td style="text-align:left;">
Ist mind. eins von cond1, cond2 wahr?
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>xor</code>
</td>
<td style="text-align:left;">
<code>xor(cond1, cond2)</code>
</td>
<td style="text-align:left;">
Ist genau eins von cond1, cond2 wahr?
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>!</code>
</td>
<td style="text-align:left;">
<code>!cond1</code>
</td>
<td style="text-align:left;">
Ist cond1 falsch? Umkehrung von logical test
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>any</code>
</td>
<td style="text-align:left;">
<code>any(cond1, cond2, ...)</code>
</td>
<td style="text-align:left;">
Sind irgendwelche der Conditions wahr?
</td>
</tr>
<tr>
<td style="text-align:left;">
<code>all</code>
</td>
<td style="text-align:left;">
<code>all(cond1, cond2, ...)</code>
</td>
<td style="text-align:left;">
Sind alle der Conditions wahr? Gleich b?
</td>
</tr>
</tbody>
</table>
</div>
<p>Um die <em>Boolean Operatoren</em> zu benutzen, platziere sie
zwischen zwei kompletten <em>logical tests</em>.</p>
<p>R führt jeden Test aus und nutzt dann den Operator um die Ergebnisse
zu kombinieren; in ein einziges <code>TRUE</code> oder
<code>FALSE</code>.<br />
<em>Boolean Operatoren</em> folgen den selben elementweisen Ausführungen
wie arithmetische und <em>logical Operatoren</em>.</p>
<pre class="r"><code>a &lt;- c(1, 2, 3)
b &lt;- c(1, 2, 3)
c &lt;- c(1, 2, 4)
a == b</code></pre>
<pre><code>## [1] TRUE TRUE TRUE</code></pre>
<pre class="r"><code>b == c</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE</code></pre>
<pre class="r"><code>a == b &amp; b == c</code></pre>
<pre><code>## [1]  TRUE  TRUE FALSE</code></pre>
<p>Jetzt wollen wir in unserem Deck sowohl die Dame, als auch das Pik
lokalisieren. Mit <em>Boolean Operatoren</em>.</p>
<pre class="r"><code>queenOfSpades &lt;- deck4$face == &quot;queen&quot; &amp; deck4$suit == &quot;spades&quot;
queenOfSpades</code></pre>
<pre><code>##  [1] FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [49] FALSE FALSE FALSE FALSE</code></pre>
<pre class="r"><code>deck4[queenOfSpades, ]</code></pre>
<pre><code>##    face   suit value
## 2 queen spades     0</code></pre>
<pre class="r"><code>deck4$value[queenOfSpades]</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Jetzt können wir ihren Wert updaten.</p>
<pre class="r"><code>deck4$value[queenOfSpades] &lt;- 13
deck4[queenOfSpades, ]</code></pre>
<pre><code>##    face   suit value
## 2 queen spades    13</code></pre>
<p><strong>Aufgabe</strong> Übung.</p>
<p>Konvertiere in Tests folgende Sätze.</p>
<ul>
<li>ist w positiv?</li>
<li>ist x größer als 10 und kleiner als 20?</li>
<li>ist Objekt y das Wort Februar?</li>
<li>ist jeder Wert in z ein Wochentag?</li>
</ul>
<pre class="r"><code>w &lt;- c(-1, 0, 1)
x &lt;- c(5, 15)
y &lt;- &quot;Februar&quot;
z &lt;- c(&quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;)</code></pre>
<p>Na easy. oder?</p>
<pre class="r"><code>w &gt; 0</code></pre>
<pre><code>## [1] FALSE FALSE  TRUE</code></pre>
<pre class="r"><code>10 &lt; x &amp; x &lt; 20</code></pre>
<pre><code>## [1] FALSE  TRUE</code></pre>
<pre class="r"><code>y == &quot;Februar&quot;</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>all(z %in% c(&quot;Montag&quot;, &quot;Dienstag&quot;, &quot;Mittwoch&quot;, &quot;Donnerstag&quot;, &quot;Freitag&quot;, &quot;Samstag&quot;, &quot;Sonntag&quot;))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p><strong>Aufgabe</strong> Blackjack. Jeder König, jede Dame, jeder
Bube hat einen Wert von 10. Ass hat einen Wert von 1 oder 11. Also
los.</p>
<pre class="r"><code>deck5 &lt;- deck
head(deck5, 13)</code></pre>
<pre><code>##     face   suit value
## 1   king spades    13
## 2  queen spades    12
## 3   jack spades    11
## 4    ten spades    10
## 5   nine spades     9
## 6  eight spades     8
## 7  seven spades     7
## 8    six spades     6
## 9   five spades     5
## 10  four spades     4
## 11 three spades     3
## 12   two spades     2
## 13   ace spades     1</code></pre>
<p>Wechsel die Kartenzahl mithilfe von <code>%in%</code>.</p>
<pre class="r"><code>facecard &lt;- deck5$face %in% c(&quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;)
deck5[facecard, ]</code></pre>
<pre><code>##     face     suit value
## 1   king   spades    13
## 2  queen   spades    12
## 3   jack   spades    11
## 14  king    clubs    13
## 15 queen    clubs    12
## 16  jack    clubs    11
## 27  king diamonds    13
## 28 queen diamonds    12
## 29  jack diamonds    11
## 40  king   hearts    13
## 41 queen   hearts    12
## 42  jack   hearts    11</code></pre>
<pre class="r"><code>deck5$value[facecard] &lt;- 10
head(deck5, 13)</code></pre>
<pre><code>##     face   suit value
## 1   king spades    10
## 2  queen spades    10
## 3   jack spades    10
## 4    ten spades    10
## 5   nine spades     9
## 6  eight spades     8
## 7  seven spades     7
## 8    six spades     6
## 9   five spades     5
## 10  four spades     4
## 11 three spades     3
## 12   two spades     2
## 13   ace spades     1</code></pre>
<p>Jetzt müssen wir das Ass-Problem lösen. Was schwierig ist, weil sich
deren Wert von Hand zu Hand ändert. Überschreitet die Gesamtsumme nicht
die 21, so ist das Ass 11 wert, sonst nur 1.</p>
</div>
</div>
<div id="missing-information" class="section level2" number="5.3">
<h2><span class="header-section-number">5.3</span> Missing
Information</h2>
<p>Die Messung ist verloren gegangen oder wurde nicht erhoben,
manipuliert. R hilft.<br />
Der <code>NA</code> Character ist ein spezielles Symbol in R. Es steht
für “nicht verfügbar”; “not available”. Es ist also ein Platzhalter.
Welche Information erwartest du bei Addition mit <code>NA</code>? Oder
<code>NA</code> ist gleich <code>1</code>?</p>
<pre class="r"><code>1 + NA</code></pre>
<pre><code>## [1] NA</code></pre>
<pre class="r"><code>NA == 1</code></pre>
<pre><code>## [1] NA</code></pre>
<div id="na.rm" class="section level3" number="5.3.1">
<h3><span class="header-section-number">5.3.1</span> na.rm</h3>
<p><em>Missing Values</em> können zu Frustration führen. Versuche den
Durchschnitt mit <code>mean</code> zu bestimmen.</p>
<pre class="r"><code>c(NA, 1:50)</code></pre>
<pre><code>##  [1] NA  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24
## [26] 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49
## [51] 50</code></pre>
<pre class="r"><code>mean(c(NA, 1:50))</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Die meisten R Funktionen bieten ein optionales Argument an,
<code>na.rm</code>, das für <code>NA</code> remove steht. R ignoriert
die <code>NA</code>s, wenn du das Argument <code>na.rm = TRUE</code>
hinzufügst.</p>
<pre class="r"><code>mean(c(NA, 1:50), na.rm = TRUE)</code></pre>
<pre><code>## [1] 25.5</code></pre>
</div>
<div id="is.na" class="section level3" number="5.3.2">
<h3><span class="header-section-number">5.3.2</span> is.na</h3>
<p><code>NA</code> identifizieren? Sogar dieser Test liefert ein
erwartbares Ergebnis, seien wir ehrlich. Solche Tests helfen also
nicht.</p>
<pre class="r"><code>c(1, 2, 3, NA) == NA</code></pre>
<pre><code>## [1] NA NA NA NA</code></pre>
<p>R liefert aber eine spezielle Funktion, die testet, ob ein Wert ein
<code>NA</code> ist: <code>is.na</code>.</p>
<pre class="r"><code>is.na(NA)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>vec &lt;- c(1, 2, 3, NA)
is.na(vec)</code></pre>
<pre><code>## [1] FALSE FALSE FALSE  TRUE</code></pre>
<p><strong>Aufgabe</strong> Asse auf <code>NA</code> setzen.</p>
<p>Setzen wir alle Asse auf eine Kartenzahl (<em>Value</em>) von
<code>NA</code>. Es erinnert an die Unwissenheit vom Ass-Wert. Es
verhindert auch die falsche Bewertung vom Ass.</p>
<pre class="r"><code>deck5$value[deck5$face == &quot;ace&quot;] &lt;- NA
head(deck5, 13)</code></pre>
<pre><code>##     face   suit value
## 1   king spades    10
## 2  queen spades    10
## 3   jack spades    10
## 4    ten spades    10
## 5   nine spades     9
## 6  eight spades     8
## 7  seven spades     7
## 8    six spades     6
## 9   five spades     5
## 10  four spades     4
## 11 three spades     3
## 12   two spades     2
## 13   ace spades    NA</code></pre>
</div>
</div>
</div>
<div id="environments" class="section level1" number="6">
<h1><span class="header-section-number">6</span> Environments</h1>
<p>Wir können jetzt Blackjack spielen, haben wir doch unsere
<code>shuffle</code> und <code>deal</code> Funktionen. Schauen wir
mal.</p>
<pre class="r"><code>deal(deck)</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deal(deck)</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deal(deck)</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<p>Oh Mist. Beide Funktionen benutzen <code>deck</code>, aber
manipulieren es nicht.</p>
<div id="environments-umgebungen" class="section level2" number="6.1">
<h2><span class="header-section-number">6.1</span> Environments/
Umgebungen</h2>
<p>Überlege wie dein Computer Datein speichert. In einem Ordnersystem.
Es gibt dort eine Hierarchie und man kämpft sich so von Ordner zu
Unterordner durch. R betreibt ein ähnliches System, um Objekte zu
speichern. Jedes Objekt ist in einer Umgebung abgespeichert. Jede
Umgebung ist mit einer <em>parent Environment</em> (higher-level
environment) verbunden, so dass eine Hierarchie entsteht. Schau dir das
System mit der <code>parenvs</code> Funktion an. Installiere zuerst das
<code>pryr</code> Paket (z.B. über <em>Tools</em> und <em>install
packages</em>) und lade es dann. Eine Liste der <em>Environments</em>,
die während deiner R Session genutzt werden, wird ausgegeben. Er
variiert natürlich von Nutzer zu Nutzer und Session zu Session.</p>
<pre class="r"><code>library(pryr)
parenvs(all = TRUE)</code></pre>
<pre><code>##    label                             name                
## 1  &lt;environment: R_GlobalEnv&gt;        &quot;&quot;                  
## 2  &lt;environment: package:pryr&gt;       &quot;package:pryr&quot;      
## 3  &lt;environment: package:kableExtra&gt; &quot;package:kableExtra&quot;
## 4  &lt;environment: package:knitr&gt;      &quot;package:knitr&quot;     
## 5  &lt;environment: package:ggplot2&gt;    &quot;package:ggplot2&quot;   
## 6  &lt;environment: package:stats&gt;      &quot;package:stats&quot;     
## 7  &lt;environment: package:graphics&gt;   &quot;package:graphics&quot;  
## 8  &lt;environment: package:grDevices&gt;  &quot;package:grDevices&quot; 
## 9  &lt;environment: package:utils&gt;      &quot;package:utils&quot;     
## 10 &lt;environment: package:datasets&gt;   &quot;package:datasets&quot;  
## 11 &lt;environment: package:methods&gt;    &quot;package:methods&quot;   
## 12 &lt;environment: 0x0000020104fb2c58&gt; &quot;Autoloads&quot;         
## 13 &lt;environment: base&gt;               &quot;&quot;                  
## 14 &lt;environment: R_EmptyEnv&gt;         &quot;&quot;</code></pre>
<p>Bei mir ist <code>R_GlobalEnv</code> die unterste Ebene, gespeichert
in einer Umgebung <code>package:pryr</code> usw. bis
<code>R_EmptyEnv</code>. Diese <em>Environment</em> hat keine <em>parent
environment</em>. Das Beispiel ist bloß eine Metapher. Man kann nicht
runter den Weg laufen, nur hoch im System von <em>parent</em> zu
<em>parent</em>.</p>
</div>
<div id="arbeiten-mit-environments" class="section level2" number="6.2">
<h2><span class="header-section-number">6.2</span> Arbeiten mit
Environments</h2>
<p>R liefert ein paar Hilfsfunktionen, die helfen deinen “Environment
Baum” zu entdecken. <code>as.environment</code> nimmt einen
<em>Environment</em>-Namen als <em>Character String</em> und gibt die
korrespondierende Umgebung wider.</p>
<pre class="r"><code>as.environment(&quot;package:stats&quot;)</code></pre>
<pre><code>## &lt;environment: package:stats&gt;
## attr(,&quot;name&quot;)
## [1] &quot;package:stats&quot;
## attr(,&quot;path&quot;)
## [1] &quot;C:/Program Files/R/R-4.2.2/library/stats&quot;</code></pre>
<p>3 Umgebungen kommen mit ihrer eigenen Zugriffsfunktion daher: global
<code>R_GlobalEnv</code>, base <code>base</code> und empty
<code>R_EmptyEnv</code> Environment.</p>
<pre class="r"><code>globalenv()</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<pre class="r"><code>baseenv()</code></pre>
<pre><code>## &lt;environment: base&gt;</code></pre>
<pre class="r"><code>emptyenv()</code></pre>
<pre><code>## &lt;environment: R_EmptyEnv&gt;</code></pre>
<p>Schau dir die <em>parent environment</em> an.</p>
<pre class="r"><code>parent.env(globalenv())</code></pre>
<pre><code>## &lt;environment: package:pryr&gt;
## attr(,&quot;name&quot;)
## [1] &quot;package:pryr&quot;
## attr(,&quot;path&quot;)
## [1] &quot;C:/Users/nikla/AppData/Local/R/win-library/4.2/pryr&quot;</code></pre>
<p>Nur die <em>empty environment</em> hat keinen <em>parent</em>.</p>
<pre class="r"><code>#parent.env(emptyenv())    Fehlermeldung</code></pre>
<p>Schau dir die Objekte gespeichert in einer Umgebung an mit
<code>ls</code> oder <code>ls.str</code>. <code>ls</code> gibt die
Objektnamen wider, <code>ls.str</code> gibt über die Objektstruktur
Informationen.</p>
<pre class="r"><code>ls(emptyenv())</code></pre>
<pre><code>## character(0)</code></pre>
<pre class="r"><code>ls(globalenv())</code></pre>
<pre><code>##  [1] &quot;a&quot;             &quot;ar&quot;            &quot;b&quot;             &quot;c&quot;            
##  [5] &quot;card&quot;          &quot;comp&quot;          &quot;deal&quot;          &quot;deck&quot;         
##  [9] &quot;deck2&quot;         &quot;deck3&quot;         &quot;deck4&quot;         &quot;deck5&quot;        
## [13] &quot;df&quot;            &quot;dice&quot;          &quot;die&quot;           &quot;die_zwei&quot;     
## [17] &quot;facecard&quot;      &quot;five&quot;          &quot;gender&quot;        &quot;hand&quot;         
## [21] &quot;hand1&quot;         &quot;hand2&quot;         &quot;int&quot;           &quot;list1&quot;        
## [25] &quot;logic&quot;         &quot;lst&quot;           &quot;m&quot;             &quot;my_zahl&quot;      
## [29] &quot;new&quot;           &quot;now&quot;           &quot;queenOfSpades&quot; &quot;random&quot;       
## [33] &quot;roll&quot;          &quot;roll2&quot;         &quot;rolls&quot;         &quot;rows&quot;         
## [37] &quot;shuffle&quot;       &quot;text&quot;          &quot;vec&quot;           &quot;w&quot;            
## [41] &quot;x&quot;             &quot;y&quot;             &quot;z&quot;</code></pre>
<p>In der <em>global environment</em> sind viele bekannte Gesichter.
Dort hat R alle bisher kreirten Objekte abgespeichert.<br />
Betrete z.B. <code>deck</code> von deiner <em>global environment</em>.
Andere Umgebungen können analog betreten werden.</p>
<pre class="r"><code>head(globalenv()$deck, 3)</code></pre>
<pre><code>##    face   suit value
## 1  king spades    13
## 2 queen spades    12
## 3  jack spades    11</code></pre>
<p><code>assign</code> kann benutzt werden, um ein Objekt in einer
bestimmten <em>Environment</em> zu speichern. Erst der Name des neuen
Objektes als <em>Character String</em>, dann den <em>Value</em> und dann
die <em>Environment</em>.</p>
<pre class="r"><code>assign(&quot;new&quot;, &quot;Hello Global&quot;, envir = globalenv())
globalenv()$new</code></pre>
<pre><code>## [1] &quot;Hello Global&quot;</code></pre>
<div id="active-environment" class="section level3" number="6.2.1">
<h3><span class="header-section-number">6.2.1</span> Active
Environment</h3>
<p>Die <em>active environment</em> ist normalerweise die global
<em>Environment</em>. Aber das kann sich ändern, wenn du eine Funktion
laufen lässt. Schau dir die aktuelle, aktive Umgebung an.</p>
<pre class="r"><code>environment()</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>Denke dabei an den <em>user workspace</em>. Wenn du ein Objekt
aufrufst, schaut R zuerst in der <em>global environment</em> nach. Aber
wenn das Objekt nicht da ist? Dann befolgt R eine Reihe von Regeln, um
das Objekt zu suchen.</p>
</div>
</div>
<div id="scoping-rules" class="section level2" number="6.3">
<h2><span class="header-section-number">6.3</span> Scoping Rules</h2>
<p>R folgt gewissen Regeln um nach Objekten zu suchen, den <em>Scoping
Rules</em>.</p>
<ol style="list-style-type: decimal">
<li><p>R sucht nach Objekten in der aktuell aktiven Umgebung.</p></li>
<li><p>Arbeitest du an der <em>command line</em>, so ist die aktive
Umgebung die <em>global environment</em>.</p></li>
<li><p><strong>Wenn R nicht ein Objekt in einer Umgebung findet, sucht R
in der <em>parent environment</em>, dann <em>parent</em> von
<em>parent</em> und so weiter bis R das Objekt gefunden hat oder die
<em>empty environment</em> erreicht hat.</strong><br />
Wenn kein Objekt gefunden wird, dann gibt R eine Fehlermeldung
aus.</p></li>
</ol>
</div>
<div id="assignment" class="section level2" number="6.4">
<h2><span class="header-section-number">6.4</span> Assignment</h2>
<p>Ordnest du einen <em>Value</em> einem Objekt zu, speichert R den Wert
in der aktiven Umgebung unter dem Objektnamen. Notfalls überschreibt R
den selben Namen. Das erzeugt ein Dilemma für R, wann immer R eine
Funktion aufruft. Viele Funktionen speichern temporär Objekte, die ihnen
helfen ihren Job zu tun. Zum Beispiel die <code>roll</code> Funktion
speicherte ein Objekt mit Namen <code>die</code> und ein Objekt
<code>dice</code>.</p>
<pre class="r"><code>roll &lt;- function() {
  die &lt;- 1:6
  dice &lt;- sample(die, size = 2, replace = TRUE)
  sum(dice)
}</code></pre>
<p>R speichert diese temporären Objekte in der aktiven Umgebung, ggf.
werden dann existierende Objekte überschrieben. Wie vermeidet R das
Risiko von Überschreibungen?</p>
</div>
<div id="evaluation" class="section level2" number="6.5">
<h2><span class="header-section-number">6.5</span> Evaluation</h2>
<p>R kreiert immer dann eine neue Umgebung, wenn es eine Funktion
bewertet. R benutzt die neue Umgebung als aktive Umgebung, während R die
Funktion ausführt. Danach kehrt R zur <em>Environment</em> zurück, von
der es die Funktion ausgeführt hat. Diese Umgebung nennen wir
<em>runtime environment</em>.</p>
<p>Wir erkunden mithilfe der folgenden Funktion die <em>runtime
environment</em>. Was sind seine <em>parent environments</em> und welche
Objekte enthalten sie? <code>show_env</code> sagt es uns.</p>
<pre class="r"><code>show_env &lt;- function(){
  list(ran.in = environment(), 
    parent = parent.env(environment()), 
    objects = ls.str(environment()))
}</code></pre>
<p>Es ist eine Funktion, die eine <em>runtime environment</em> kreiert.
Es gibt uns den Namen der <em>runtime environment wider</em>, seine
<em>parents</em> und die enthaltenen Objekte.</p>
<pre class="r"><code>show_env()</code></pre>
<pre><code>## $ran.in
## &lt;environment: 0x000002010dd87770&gt;
## 
## $parent
## &lt;environment: R_GlobalEnv&gt;
## 
## $objects</code></pre>
<p>R kreiert eine neue <em>Environment</em> namens
<code>0x7ff711d12e28</code>, es gibt keine Objekte und die parents ist
die <em>global environment</em>. Lassen wir die Funktion noch einmal
laufen, so erhalten wir eine neue <em>Environment</em>
<code>(0x7ff715f49808)</code>.</p>
<pre class="r"><code>show_env()</code></pre>
<pre><code>## $ran.in
## &lt;environment: 0x000002010df09ec8&gt;
## 
## $parent
## &lt;environment: R_GlobalEnv&gt;
## 
## $objects</code></pre>
<p>Nach jedem Ausführen erhalten wir also eine neue Environment. Sie ist
leer und hat die globale <em>Environment</em> als <em>parent</em>. R
verknüpft die <em>runtime environment</em> einer Funktion zu der
<em>Environment</em>, in der die Funktion zuerst kreiert wurde. Nennen
wir sie <em>origin environment</em>. Die <em>origin</em> der Funktion
wird aufgerufen über <code>environment</code>.</p>
<pre class="r"><code>environment(show_env)</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>Die origin von <code>show_env</code> ist die <em>global
environment</em>, weil wir <code>show_env</code> in der <em>command
line</em> kreiert haben, aber die <em>origin</em> braucht nicht die
<em>global environment</em> zu sein. Die <em>Environment</em> von
<code>parenvs</code> ist das <code>pryr</code> Paket.</p>
<pre class="r"><code>environment(parenvs)</code></pre>
<pre><code>## &lt;environment: namespace:pryr&gt;</code></pre>
<p>Der <em>parent</em> einer <em>runtime environment</em> ist nicht
immer die <em>global environment</em>. Es ist welche auch immer
<em>Environment</em>, in die die Funktion zuerst kreiert wurde.</p>
<p>Lass uns jetzt die Objekte betrachten, die in der <em>runtime
environment</em> enthalten sind. Noch enthält <code>show_env</code>s
<em>runtime environment</em> keine Objekte. Aber wir können dies
natürlich ändern. Füllen wir den <em>body</em>. Dann ist die <em>runtime
environment</em> die aktive <em>Environment</em>.</p>
<pre class="r"><code>show_env &lt;- function(){
  a &lt;- 1
  b &lt;- 2
  c &lt;- 3
  list(ran.in = environment(), 
    parent = parent.env(environment()), 
    objects = ls.str(environment()))
}</code></pre>
<p>Wenn wir jetzt <code>show_env</code> ausführen, speichert R
<code>a</code>, <code>b</code>, und <code>c</code> in der <em>runtime
environment</em>.</p>
<pre class="r"><code>show_env()</code></pre>
<pre><code>## $ran.in
## &lt;environment: 0x000002010a70d008&gt;
## 
## $parent
## &lt;environment: R_GlobalEnv&gt;
## 
## $objects
## a :  num 1
## b :  num 2
## c :  num 3</code></pre>
<p>Dadurch geht R sicher, dass eine Funktion nichts überschreibt, dass
es nicht sollte. R steckt auch noch einen zweiten Typ von Objekten in
eine <em>runtime environment</em>. Argumente werden in die <em>runtime
environment</em> übernommen. Das stellt sicher, dass eine Funktion seine
Argumente auch benutzt und findet.</p>
<pre class="r"><code>foo &lt;- &quot;take me to your runtime&quot;

show_env &lt;- function(x = foo){
  list(ran.in = environment(), 
    parent = parent.env(environment()), 
    objects = ls.str(environment()))
}

show_env()</code></pre>
<pre><code>## $ran.in
## &lt;environment: 0x000002010a0e8238&gt;
## 
## $parent
## &lt;environment: R_GlobalEnv&gt;
## 
## $objects
## x :  chr &quot;take me to your runtime&quot;</code></pre>
<p><strong>Zusammenfassend</strong></p>
<p>Bevor eine Funktion aufgerufen wird, arbeitet R in einer aktiven
<em>Environment</em>. Nennen wir sie <em>calling environment</em>. Von
ihr aus wird die Funktion aufgerufen. Nach dem Aufruf der Funktion
entsteht eine neue <em>runtime environment</em>. Diese Umgebung ist ein
<em>child</em> der <em>origin environment</em>. R kopiert jedes der
Funktionsargumente in die <em>runtime environment</em> und macht diese
zur aktiven <em>Environment</em>.<br />
Jetzt wird der Code im body der Funktion ausgeführt. Werden Objekte
kreiert, steckt R sie in die aktive, die <em>runtime environment</em>.
Ruft R Objekte auf, so benutzt R die <strong>Scoping Rules</strong>. R
sucht die <em>runtime environment</em> ab (origin environment), dann die
<em>parent</em> der <em>origin</em> und so weiter.<br />
R beendet die Funktion. Die <em>calling environment</em> wird wieder zur
<em>active</em>. Speichert du die Ergebnisse der Funktion durch
<code>&lt;-</code> in ein neues Objekt, wird dieses in die <em>calling
environment</em> gesteckt.</p>
<p>Wie kannst du dieses Wissen für unsere <code>deal</code> und
<code>shuffle</code> Funktion nutzen? Definieren wir noch einmal
<code>deal</code>.</p>
<pre class="r"><code>deal &lt;- function() {
  deck[1, ]
}</code></pre>
<p><code>deal</code> übernimmt kein Argument und es ruft das
<code>deck</code> Objekt auf, welches sich in der global environment
befindet.</p>
<p><strong>Aufgabe</strong> Funktioniert <code>deal</code>?</p>
<p>Findet R also <code>deck</code> und gibt eine Ausgabe, wenn ich die
Version von <code>deal</code> aufrufe mit <code>deal()</code>?</p>
<p>Ja. R führt <code>deal</code> in einer <em>runtime environment</em>
aus, die das <em>child</em> der <em>global environment</em> ist. Warum
ist es <em>child</em> der <em>global environment</em>? Weil die
<em>global environment</em> ist die <em>origin environment</em> of
<code>deal</code>.</p>
<pre class="r"><code>environment(deal)</code></pre>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>Wenn <code>deal</code> <code>deck</code> aufruft, guckt R hoch ins
<code>deck</code> Objekt. R’s Scoping Rules führen es zu
<code>deck</code> in der <em>global environment</em>.</p>
<pre class="r"><code>deal()</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<p>R findet <code>deck</code>, indem es in die <em>parent</em> von
deal’s <em>runtime environment</em> guckt. Die <em>parent</em> ist die
<em>globale environment</em>, deal’s <em>origin environment</em>. Hier
findet R die Kopie von deck.</p>
<p>Reparieren wir jetzt die <code>deal</code> Funktion, um die
entnommene Karte aus dem Deck zu entfernen. Erinnere dich daran, dass
<code>deal</code> die oberste Karte aus dem <code>deck</code> nimmt, sie
aber nicht entfernt. <code>deal</code> entnimmt immer dieselbe
Karte.</p>
<pre class="r"><code>deal()</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deal()</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<pre class="r"><code>deal()</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
<p>Der folgende Code speichert <code>deck</code> und entnimmt dann eine
Karte immer.</p>
<pre class="r"><code>DECK &lt;- deck
deck &lt;- deck[-1, ]
head(deck, 3)</code></pre>
<pre><code>##    face   suit value
## 2 queen spades    12
## 3  jack spades    11
## 4   ten spades    10</code></pre>
<p>Den Code müssen wir jetzt natürlich <code>deal</code> hinzufügen.</p>
<pre class="r"><code>deal &lt;- function() {
  card &lt;- deck[1, ]
  deck &lt;- deck[-1, ]
  card
}</code></pre>
<p>Der Code wird nicht funktionieren, weil sich R in einer <em>runtime
environment</em> befindet, wenn es <code>deck &lt;- deck[-1, ]</code>
ausführt. Anstatt die globale Kopie von <code>deck</code> mit
<code>deck[-1, ]</code> zu überscheiben, erzeugt <code>deal</code> bloß
eine abgeänderte Kopie von <code>deck</code> in seiner <em>runtime
environment</em>.<br />
Die <code>deal</code> Funktion schaut hoch zu deck in der <em>global
environment</em>, aber speichert deck[-1, ] in der <em>runtime
environment</em> als ein neues Objekt namens <code>deck</code>.</p>
<p><strong>Aufgabe</strong> Überschreibe <code>deck</code>.</p>
<p>Überschreibe <code>deck</code> mit <code>deck &lt;- deck[-1, ]</code>
in der <code>deal</code> Funktion und übergebe <code>deck[-1, ]</code>
an ein Objekt <code>deck</code> in der <em>global environment</em>.
Benutze <code>assign</code>.</p>
<pre class="r"><code>deal &lt;- function() {
  card &lt;- deck[1, ]
  assign(&quot;deck&quot;, deck[-1, ], envir = globalenv())
  card
}</code></pre>
<p>Jetzt reinigt <code>deal</code> die globale Kopie von
<code>deck</code>.</p>
<pre class="r"><code>deal()</code></pre>
<pre><code>##    face   suit value
## 2 queen spades    12</code></pre>
<pre class="r"><code>deal()</code></pre>
<pre><code>##   face   suit value
## 3 jack spades    11</code></pre>
<pre class="r"><code>deal()</code></pre>
<pre><code>##   face   suit value
## 4  ten spades    10</code></pre>
<p>Denke noch an die <code>shuffle</code> Funktion.</p>
<pre class="r"><code>shuffle &lt;- function(cards) { 
  random &lt;- sample(1:52, size = 52)
  cards[random, ]
}</code></pre>
<p><code>shuffle(deck)</code> mischt nicht das Kartendeck-Objekt. Es
gibt eine gemischte Kopie des <code>deck</code> Objektes aus.</p>
<pre class="r"><code>head(deck, 3)</code></pre>
<pre><code>##    face   suit value
## 5  nine spades     9
## 6 eight spades     8
## 7 seven spades     7</code></pre>
<pre class="r"><code>a &lt;- shuffle(deck)
head(deck, 3)</code></pre>
<pre><code>##    face   suit value
## 5  nine spades     9
## 6 eight spades     8
## 7 seven spades     7</code></pre>
<pre class="r"><code>head(a, 3)</code></pre>
<pre><code>##     face   suit value
## 11 three spades     3
## 42  jack hearts    11
## 40  king hearts    13</code></pre>
<p><code>shuffle</code> mischt nicht <code>deck</code> und mischt die
ausgegebenen Karten nicht mit.</p>
<p><strong>Aufgabe</strong> Schreibe <code>shuffle</code> neu.</p>
<p>Es soll die Kopie von <code>deck</code> ersetzen, die in der globalen
<em>Environment</em> lebt, durch <code>DECK</code>. Die neue Version von
<code>shuffle</code> soll keine Argumente haben und keinen Output.</p>
<p><code>DECK</code> lebt in der globalen Umgebung. <code>shuffle</code>
<em>environment of origin</em>. <code>shuffle</code> findet
<code>DECK</code> beim Durchlaufen. R sucht nach <code>DECK</code>
zuerst in der <em>runtime environment</em> von <code>shuffle</code>.
Dann in der <em>origin</em> von <code>shuffle</code>, der <em>global
environment</em>. Dort ist <code>DECK</code> gespeichert. Durch
<code>assign</code> wird die Kopie von <code>DECK</code> als
<code>deck</code> in der <em>global environment</em> gespeichert und
überschreibt die nichtgemischte Version von <code>deck</code>.</p>
<pre class="r"><code>shuffle &lt;- function(){
  random &lt;- sample(1:52, size = 52)
  assign(&quot;deck&quot;, DECK[random, ], envir = globalenv())
}</code></pre>
</div>
<div id="closures" class="section level2" number="6.6">
<h2><span class="header-section-number">6.6</span> Closures</h2>
<p>Unser System funktioniert. Mische die Karten und dann gib sie
aus.</p>
<pre class="r"><code>shuffle()
deal()</code></pre>
<pre><code>##    face   suit value
## 40 king hearts    13</code></pre>
<pre class="r"><code>deal()</code></pre>
<pre><code>##    face  suit value
## 23 four clubs     4</code></pre>
<p>Wir brauchen hierfür <code>deck</code> und <code>DECK</code> in der
globalen Umgebung. Es ist jedoch möglich, dass <code>deck</code>
modifiziert oder gelöscht wird. Besser wäre es <code>deck</code> in
einer sicheren Umgebung zu speichern. <code>deck</code> in einer
<em>runtime environment</em> zu speichern ist also keine so schlechte
Idee.<br />
Du könntest eine Funktion kreieren, die <code>deck</code> als Argument
nimmt und speichert als eine Kopie von <code>deck</code> in
<code>DECK</code>. Diese Funktion könnte auch ihre eigenen Kopien von
<code>deal</code> und <code>shuffle</code> speichern.</p>
<pre class="r"><code>setup &lt;- function(deck) {
  DECK &lt;- deck

  DEAL &lt;- function() {
    card &lt;- deck[1, ]
    assign(&quot;deck&quot;, deck[-1, ], envir = globalenv())
    card
  }

  SHUFFLE &lt;- function(){
    random &lt;- sample(1:52, size = 52)
    assign(&quot;deck&quot;, DECK[random, ], envir = globalenv())
 }
}</code></pre>
<p>Wenn du <code>setup</code> ausführst, kreiert R eine <em>runtime
environment</em> um die Objekte darin zu speichern. All diese Objekte
(<code>deck</code>, <code>DECK</code>, <code>DEAL</code>,
<code>SHUFFLE</code>) sind jetzt aus dem Weg geräumt und in einem child
der <em>global environment</em>. Das macht sie sicher, aber schwer
nutzbar. Frag <code>setup</code>, um <code>DEAL</code> und
<code>SHUFFLE</code> zurückzugeben. Am besten mithilfe einer Liste.</p>
<pre class="r"><code>setup &lt;- function(deck) {
  DECK &lt;- deck

  DEAL &lt;- function() {
    card &lt;- deck[1, ]
    assign(&quot;deck&quot;, deck[-1, ], envir = globalenv())
    card
  }

  SHUFFLE &lt;- function(){
    random &lt;- sample(1:52, size = 52)
    assign(&quot;deck&quot;, DECK[random, ], envir = globalenv())
 }

 list(deal = DEAL, shuffle = SHUFFLE)
}

cards &lt;- setup(deck)</code></pre>
<p>Speicher jedes Element der Liste in der <em>global
environment</em>.</p>
<pre class="r"><code>deal &lt;- cards$deal
shuffle &lt;- cards$shuffle</code></pre>
<p><code>deal</code> und <code>shuffle</code> kannst du jetzt wie zuvor
benutzen. Der Code ist der gleiche wie zuvor.</p>
<pre class="r"><code>deal</code></pre>
<pre><code>## function() {
##     card &lt;- deck[1, ]
##     assign(&quot;deck&quot;, deck[-1, ], envir = globalenv())
##     card
##   }
## &lt;environment: 0x000002010d75fda0&gt;</code></pre>
<pre class="r"><code>shuffle</code></pre>
<pre><code>## function(){
##     random &lt;- sample(1:52, size = 52)
##     assign(&quot;deck&quot;, DECK[random, ], envir = globalenv())
##  }
## &lt;environment: 0x000002010d75fda0&gt;</code></pre>
<p>Ihre <em>origin environment</em> ist nicht länger die <em>global
environment</em>. Sie ist die <em>runtime environment</em>, die R
erstellt hat als du <code>setup</code> aufgerufen hast. Dort kreiert R
<code>DEAL</code> und <code>SHUFFLE</code>. Die Funktionen, die ins neue
<code>deal</code> und <code>shuffle</code> kopiert werden.</p>
<pre class="r"><code>environment(deal)</code></pre>
<pre><code>## &lt;environment: 0x000002010d75fda0&gt;</code></pre>
<pre class="r"><code>environment(shuffle)</code></pre>
<pre><code>## &lt;environment: 0x000002010d75fda0&gt;</code></pre>
<p>Wenn du <code>deal</code> und <code>shuffle</code> aufrufst, bewertet
R diese Funktionen in einer <em>runtime environment</em>, die
<code>0x7ff7169c3390</code> als <em>parent aufruft</em>.
<code>Deck</code> und <code>deck</code> sind in dieser <em>parent
environmet</em>. Das heißt, dass <code>deal</code> und
<code>shuffle</code> sie beim Durchlauf finden. <code>DECK</code> und
<code>deck</code> sind im Suchpfad der Funktion.</p>
<p><strong>Das nennt man CLOSURE.</strong> <code>setup</code>
<em>runtime environment</em> umschließt die <code>deal</code> und
<code>shuffle</code> Funktionen. Beide können eng zusammenarbeiten mit
den Objekten, enthalten in der umschließenden <em>Environment</em>.</p>
<p>Du hast bemerkt, dass <code>deal</code> und <code>shuffle</code>
immer noch das <code>deck</code> Objekt updaten, in der <em>global
environment</em>. Wir ändern das. Wir wollen, dass <code>deal</code> und
<code>shuffle</code> exklusiv mit den Objekten in der <em>parent</em>
umschließenden <em>Environment</em> arbeiten. Anstatt, dass sich die
Funktionen immer auf das upgedatete <code>deck</code> in der <em>global
env</em> beziehen, kannst du sie sich auf die <em>parent env</em> beim
Durchlauf beziehen lassen.</p>
<pre class="r"><code>setup &lt;- function(deck) {
  DECK &lt;- deck

  DEAL &lt;- function() {
    card &lt;- deck[1, ]
    assign(&quot;deck&quot;, deck[-1, ], envir = parent.env(environment()))
    card
  }

  SHUFFLE &lt;- function(){
    random &lt;- sample(1:52, size = 52)
    assign(&quot;deck&quot;, DECK[random, ], envir = parent.env(environment()))
 }

 list(deal = DEAL, shuffle = SHUFFLE)
}

cards &lt;- setup(deck)
deal &lt;- cards$deal
shuffle &lt;- cards$shuffle</code></pre>
<p>Endlich haben wir ein eigenständiges Kartenspiel. Die globale Kopie
von <code>deck</code> kannst du modifizieren wie du willst und immer
noch Karten spielen. <code>deal</code> und <code>shuffle</code> benutzen
die makelose, geschützte Kopie von <code>deck</code>.</p>
<pre class="r"><code>rm(deck)
shuffle()
deal()</code></pre>
<pre><code>##    face  suit value
## 22 five clubs     5</code></pre>
<pre class="r"><code>deal()</code></pre>
<pre><code>##   face   suit value
## 1 king spades    13</code></pre>
</div>
</div>
<div id="programme" class="section level1" number="7">
<h1><span class="header-section-number">7</span> Programme</h1>
<p>In diesem Kapitel wollen wir eine Slot Maschine aufbauen. Die
<code>play</code> Funktion soll zwei Dinge tun. 1. Die Maschine soll
zufällig drei Symbole ausgeben.<br />
2. Ein Preis soll daraus berechnet werden.</p>
<p>Der erste Schritt ist leicht zu simulieren. Mit der
<code>sample</code> Funktion lassen sich leicht drei Symbole
generieren.</p>
<pre class="r"><code>get_symbols &lt;- function() {
  wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;)
  sample(wheel, size = 3, replace = TRUE, 
    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))
}</code></pre>
<p>Drei Symbole mit Zurücklegen sind schnell erspielt.</p>
<pre class="r"><code>get_symbols()</code></pre>
<pre><code>## [1] &quot;0&quot; &quot;0&quot; &quot;0&quot;</code></pre>
<pre class="r"><code>get_symbols()</code></pre>
<pre><code>## [1] &quot;B&quot; &quot;B&quot; &quot;0&quot;</code></pre>
<pre class="r"><code>get_symbols()</code></pre>
<pre><code>## [1] &quot;0&quot; &quot;0&quot; &quot;0&quot;</code></pre>
<p>Die entsprechenden Wahrscheinlichkeiten sind gegeben. Die Slot
Maschine benutzt ein kompliziertes Auszahlungsschema. Man gewinnt
bei:</p>
<ul>
<li>Drei mal gleiches Symbol (außer null)</li>
<li>Drei Balken (Unterschiedlichkeit)</li>
<li>mindestens eine Kirsche</li>
</ul>
<p>Ansonsten gibt es keinen Preis.</p>
<p>Ein Spiel kostet 1 Euro.</p>
<table>
<thead>
<tr class="header">
<th>Kombination</th>
<th>Preis</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>DD DD DD</td>
<td>100</td>
</tr>
<tr class="even">
<td>7 7 7</td>
<td>80</td>
</tr>
<tr class="odd">
<td>BBB BBB BBB</td>
<td>40</td>
</tr>
<tr class="even">
<td>BB BB BB</td>
<td>10</td>
</tr>
<tr class="odd">
<td>B B B</td>
<td>10</td>
</tr>
<tr class="even">
<td>C C C</td>
<td>10</td>
</tr>
<tr class="odd">
<td>Any Comb of bars</td>
<td>5</td>
</tr>
<tr class="even">
<td>C C *</td>
<td>5</td>
</tr>
<tr class="odd">
<td>C * C</td>
<td>5</td>
</tr>
<tr class="even">
<td>* C C</td>
<td>5</td>
</tr>
<tr class="odd">
<td>C * *</td>
<td>2</td>
</tr>
<tr class="even">
<td>* C *</td>
<td>2</td>
</tr>
<tr class="odd">
<td>* * C</td>
<td>2</td>
</tr>
</tbody>
</table>
<p>Um deine <code>play</code> Funktion zu bauen, musst du ein Programm
schreiben, dass den Output von <code>get_symbols</code> nimmt und daraus
den korrekten Preis berechnet.</p>
<p>In R werden Programme entweder als Skripte oder als Funktionen
gespeichert. Wir speichern unser Programm als Funktion namens
<code>score</code>. Am Ende werden wir Funktionen wie folgt schreiben:
<code>score(c("DD", "DD", "DD"))</code> und als Ergebnis
<code>800</code> erhalten.</p>
<div id="strategie" class="section level2" number="7.1">
<h2><span class="header-section-number">7.1</span> Strategie</h2>
<p>Um unsere Slot Maschine zu programmieren, werden wir einen komplexen
Algorithmus anwenden. Benutze dazu eine simple Strategie.</p>
<ul>
<li>breche komplexe Aufgaben in einfachere Subaufgaben runter</li>
<li>Benutze konkrete Beispiele</li>
<li>Beschreibe deine Lösung, konvertiere sie dann in R</li>
</ul>
<p>Also Schritt für Schritt. R enthält zwei Typen von Subtasks:
<em>sequential steps</em> und <em>parallel cases</em>.</p>
<div id="sequential-steps-aufeinanderfolgende-schritte"
class="section level3" number="7.1.1">
<h3><span class="header-section-number">7.1.1</span> <em>Sequential
Steps</em> / Aufeinanderfolgende Schritte</h3>
<p>Die <code>play</code> Funktion nimmt dieses Verfahren vor.</p>
<pre class="r"><code>play &lt;- function() {

  # step 1: generate symbols
  symbols &lt;- get_symbols()

  # step 2: display the symbols
  print(symbols)

  # step 3: score the symbols
  score(symbols)
}</code></pre>
<p>Erst generiert es drei Symbole. Dann werden sie in der Console
angezeigt. Und dann erhalten sie einen Score. Alles step-by-step.</p>
</div>
<div id="parallel-cases-parallele-fälle" class="section level3"
number="7.1.2">
<h3><span class="header-section-number">7.1.2</span> <em>Parallel
Cases</em> / Parallele Fälle</h3>
<p>Ein anderer Weg eine Aufgabe aufzuteilen, ist es Gruppen ähnlicher
Fälle innerhalb der Aufgabe zusammenzufassen. Haben wir bei unserer Slot
Maschine drei gleiche, so ist ein anderer Algorithmus anzuwenden, als
wenn wir drei verschiedene Symbole haben. <code>score</code> benutzt nie
alle Algorithmen auf einmal. Immer nur einen, abhängig von der
Kombination der Symbole.</p>
<p>Diamanten komplizieren alles, da sie als Joker zählen. Das ignorieren
wir. Sie verdoppeln bei uns nur den Preis.<br />
Das geschieht aber erst am Ende, falls notwendig. Erst folgen die
Symbole, dann der Preis.<br />
Den ersten Schritt haben wir gelöst. Unser Programm liefert uns drei
slot machine Symbole mit der <code>get_symbols</code> Funktion. Dann
kann es die Symbole mit der <code>print</code> Funktion anzeigen. Lass
uns jetzt untersuchen wie unser Programm die <em>parallel score</em>
Fälle arrangieren kann.</p>
</div>
</div>
<div id="if-bedingung" class="section level2" number="7.2">
<h2><span class="header-section-number">7.2</span> if Bedingung</h2>
<p>Fälle zu verbinden verlangt nach einer gewissen Struktur.<br />
Unser Programm stößt auf eine Gabel, wann immer es zwischen
verschiedenen Fällen wählen muss. Du kannst bei der Navigation der Gabel
mit einem <code>if</code> Statement helfen.</p>
<p>Ein <code>if</code> Statement gibt R vor, was es bei einem speziellen
Fall zu tun hat.</p>
<pre class="r"><code>if (this) {
  that
}</code></pre>
<p>Das <code>this</code> Objekt sollte ein <em>logical test</em> sein,
oder ein anderer Ausdruck, der mit <code>TRUE</code> oder
<code>FALSE</code> bewertet. Wenn <code>this</code> mit
<code>TRUE</code> bewertet, so führt R den Code zwischen den gschweiften
Klammern aus. Wenn <code>FALSE</code>, dann lässt R den Code aus.</p>
<pre class="r"><code>if (num &lt; 0) {
  num &lt;- num * -1
}</code></pre>
<p>Zum Beispiel soll <code>num</code> positiv gemacht werden. Wenn
<code>num &lt; 0</code> <code>TRUE</code> ist, wird <code>num</code> mit
<code>-1</code> multipliziert. Logisch.</p>
<pre class="r"><code>num &lt;- -2

if (num &lt; 0) {
  num &lt;- num * -1
}

num</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Ist <code>num &lt; 0</code> <code>FALSE</code>, macht R gar
nichts.</p>
<pre class="r"><code>num &lt;- 4

if (num &lt; 0) {
  num &lt;- num * -1
}

num</code></pre>
<pre><code>## [1] 4</code></pre>
<p>Wir brauchen ein eindeutiges <code>TRUE</code> oder
<code>FALSE</code>. Ein Vektor bestehend aus <code>TRUE</code>s und
<code>FALSE</code>s hilft nicht weiter. Mach falls notwendig Gebrauch
von <code>any</code> und <code>all</code>. Du musst dich natürlich nicht
beschränken auf bloß eine Zeile. Zwischen den geschweiften Klammern
<code>{}</code> kannst du dich austoben. Beginnt in unserem Beispiel
<code>num</code> aber als positive Zahl, so wird der ganze Block
ausgelassen. Ansonsten passiert was?</p>
<pre class="r"><code>num &lt;- -1

if (num &lt; 0) {
  print(&quot;num is negative.&quot;)
  print(&quot;Don&#39;t worry, I&#39;ll fix it.&quot;)
  num &lt;- num * -1
  print(&quot;Now num is positive.&quot;)
}</code></pre>
<pre><code>## [1] &quot;num is negative.&quot;
## [1] &quot;Don&#39;t worry, I&#39;ll fix it.&quot;
## [1] &quot;Now num is positive.&quot;</code></pre>
<pre class="r"><code>num</code></pre>
<pre><code>## [1] 1</code></pre>
<p><strong>Aufgabe</strong> Was wird ausgegeben?</p>
<pre class="r"><code>x &lt;- 1
if (3 == 3) {
  x &lt;- 2
}
x</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Logisch was rauskommt. 2 natürlich. Bedingung ist erfüllt, also
<code>TRUE</code>. <strong>Aufgabe</strong> Was wird ausgegeben?</p>
<pre class="r"><code>x &lt;- 1
if (TRUE) {
  x &lt;- 2
}
x</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Auch logisch, auch die 2. Da <code>TRUE</code>.</p>
<p><strong>Aufgabe</strong> Was kommt raus?</p>
<pre class="r"><code>x &lt;- 1
if (x == 1) {
  x &lt;- 2
  if (x == 1) {
    x &lt;- 3
  }
}
x</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Wieder die 2. Die erste Bedingung ist erfüllt, die zweite dann nicht
mhr, da <code>x</code> auf <code>2</code> gesetzt wird. Der Rest in den
eckigen Klammern spielt dann keine Rolle mehr.</p>
</div>
<div id="else-statement-else-bedingung" class="section level2"
number="7.3">
<h2><span class="header-section-number">7.3</span> <em>else
Statement</em> / else Bedingung</h2>
<p>Du kannst aber R auch sagen was es zu machen hat, wenn die Bedingung
<em>falsch</em> ist.</p>
<pre class="r"><code>if (this) {
  Plan A
} else {
  Plan B
}</code></pre>
<p>Wenn <code>this</code> als <code>TRUE</code> bewertet wird, so führt
R den Code zwischen den ersten geschweiften Klammern aus, nicht den
zwischen den zweiten. Wenn <code>this</code> als <code>FALSE</code>
bewertet wird, so führt R den Code zwischen dem zweiten Set geschweifter
Klammern aus. So könntest du runden. <code>trunc()</code> ist hierbei
der Zahl vor dem Komma, wenn a eine Dezimalzahl ist wie z.B. 6.67.
Daraus wird dann 6.</p>
<pre class="r"><code>a &lt;- 3.14
dec &lt;- a - trunc(a)
dec</code></pre>
<pre><code>## [1] 0.14</code></pre>
<p>Runden wir also.</p>
<pre class="r"><code>if (dec &gt;= 0.5) {
  a &lt;- trunc(a) + 1
} else {
  a &lt;- trunc(a)
}

a</code></pre>
<pre><code>## [1] 3</code></pre>
<p>Wenn du mehr als 2 sich gegenseitig ausschließende Fälle hast, kannst
du weitere <code>if</code> und <code>else</code> setzen. Das
<code>if</code> Statement folgt dann direkt dem vorangegangenem
<code>else</code> Statement.</p>
<pre class="r"><code>a &lt;- 1
b &lt;- 1

if (a &gt; b) {
  print(&quot;A wins!&quot;)
} else if (a &lt; b) {
  print(&quot;B wins!&quot;)
} else {
  print(&quot;Tie.&quot;)
}</code></pre>
<pre><code>## [1] &quot;Tie.&quot;</code></pre>
<p>R kämpft sich solange durch bis eine Bedingung mit <code>TRUE</code>
bewertet wird, dann bricht es ab. Bei keinem <code>TRUE</code> führt R
das letzte <code>else</code> Statement aus.<br />
Du kannst <code>if</code> und <code>else</code> benutzen, um in unserer
slot-machine Funktion die Subaufgaben miteinander zu verbinden.</p>
<pre class="r"><code>if ( # Case 1: all the same &lt;1&gt;) {
  prize &lt;- # look up the prize &lt;3&gt;
} else if ( # Case 2: all bars &lt;2&gt; ) {
  prize &lt;- # assign $5 &lt;4&gt;
} else {
  # count cherries &lt;5&gt;
  prize &lt;- # calculate a prize &lt;7&gt;
}

# count diamonds &lt;6&gt;
# double the prize if necessary &lt;8&gt;</code></pre>
<p>Unser Skelett ist noch recht unvollständig. Viel Kommentar, wenig
Code. Wir haben aber das Programm in 8 einfache Subaufgaben
runtergebrochen.</p>
<ol style="list-style-type: decimal">
<li>Teste, ob wir 3 gleiche Symbole haben.</li>
<li>Test, ob die Symbole alle Balken (B) sind.</li>
<li>Schau nach dem Preis für drei gleiche Symbole.</li>
<li>Ordne einen 5 Euro Preis zu.</li>
<li>Zähle die Anzahl an Kirschen.</li>
<li>Zähle die Anzahl an Diamanten.</li>
<li>Kalkuliere einen Preis basierend auf der Anzahl an Kirschen.</li>
<li>Passe den Preis für Diamanten an.</li>
</ol>
<p>Du kannst einen Flow Chart erstellen, mit Pfeilen, der dir die
verschiedenen Wege weist. Sehr anschaulich.</p>
<p>Jetzt können wir die Subaufgaben in Angriff nehmen, eine nach der
anderen. Jede der Unteraufgaben ist leicht zu lösen, wenn du ein
konkretes Beispiel ansetzt und eine Lösung ausschreibst bevor du in R
codest.</p>
<p>Die erste Unteraufgabe fragt nach, ob die Symbole alle gleich sind.
Drei gleiche? Wie die finale <code>score</code> Funktion aussieht, weißt
du in etwa.</p>
<pre class="r"><code>score &lt;- function(symbols) {

  # calculate a prize

  prize
}</code></pre>
<p>Die Argumente <code>symbols</code> sind der Output von
<code>get_symbols</code>: ein Vektor, der drei <em>Character
Strings</em> enthält.<br />
Die ganze Funktion zu schreiben und dann zu testen ist keine gute Idee,
da du sehr wahrscheinlich Fehler machst und dann nicht weißt wo genau
dieser Fehler begangen wurde.<br />
Kümmere dich also nur um eine Unteraufgabe auf einmal. Bau dir ein
konkretes Beispiel und teste alle Unteraufgaben separat. Erstelle z.B.
einen Vektor mit drei möglichen <em>Character Strings</em> per Hand:
<code>symbols &lt;- c("7", "7", "7")</code>. Diese Werte kannst du
natürlich per Hand jedezeit beliebig ändern. Nachdem du dir ein
konkretes Beispiel ausgesucht hast, beschreibe in geschriebener Sprache
wie du die Unteraufgaben machen willst. Je präziser du bist, desto
leichter fällt dir die Übersetzung in R.<br />
Die erste Aufgabe besteht darin, “three of a kind” zu testen. Da sehe
ich noch keine große Hilfe für meinen R Code.<br />
Sage ich aber: ein Vektor namens <code>symbols</code> enthält drei
gleiche Symbole, wenn das erste Element ist gleich dem zweiten Element
und das zweite Element von <code>symbols</code> ist gleich dem dritten
Element. Dann kann ich damit arbeiten.</p>
<p><strong>Aufgabe</strong> Schreibe einen Test.</p>
<p>Mach aus deiner Prosa einen <em>logical test</em>, geschrieben in R.
Benutze dein Wissen von <em>logical tests</em>, Boolean Operatoren und
Subsetting. Der Test muss natürlich mit dem Vektor <code>symbols</code>
zusammenarbeiten und ein <code>TRUE</code> zurückgeben, falls alle drei
Elemente gleich sind. Teste es also an <code>symbols</code>.<br />
Es gibt mehrere Lösungen. Schau hin und verstehe.</p>
<pre class="r"><code>symbols &lt;- c(&quot;7&quot;, &quot;7&quot;, &quot;7&quot;)
symbols[1] == symbols[2] &amp; symbols[2] == symbols[3] </code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>symbols[1] == symbols[2] &amp; symbols[1] == symbols[3] </code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>all(symbols == symbols[1])</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Eine weitere Möglichkeit mit <code>unique</code>.</p>
<pre class="r"><code>length(unique(symbols) == 1)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Jeder einmalige Term deines Vektors wird ausgegeben. Aus 3 mach 1.
Die Länge ist also <code>1</code>, wenn alle Elemente gleich sind.</p>
<p>Unser slot-machine Skript sieht jetzt wie folgt aus
(<code>&amp;&amp;</code> gibt sofort <code>FALSE</code> aus, wenn die
linke Seite des Tests <code>FALSE</code> ist. Rechenleistung wird hier
gespart).</p>
<pre class="r"><code>same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]

if (same) {
  prize &lt;- # look up the prize
} else if ( # Case 2: all bars ) {
  prize &lt;- # assign $5
} else {
  # count cherries
  prize &lt;- # calculate a prize
}

# count diamonds
# double the prize if necessary</code></pre>
<p>Der zweite Preis wird gewonnen, wenn alle Symbole ein Balken sind,
also <code>B</code> oder <code>BB</code> oder <code>BBB</code>:
<code>symbols &lt;- c("B", "BB", "BBB")</code>.</p>
<p><strong>Aufgabe</strong> Test auf Balken.</p>
<p>Du kannst einen sehr langen Code schreiben, der Boolean Operatoren
benutzt. Es gibt natürlich noch andere, kürzere Wege.</p>
<pre class="r"><code>symbols &lt;- c(&quot;B&quot;, &quot;BBB&quot;, &quot;BB&quot;)
symbols[1] == &quot;B&quot; | symbols[1] == &quot;BB&quot; | symbols[1] == &quot;BBB&quot; &amp;
  symbols[2] == &quot;B&quot; | symbols[2] == &quot;BB&quot; | symbols[2] == &quot;BBB&quot; &amp;
  symbols[3] == &quot;B&quot; | symbols[3] == &quot;BB&quot; | symbols[3] == &quot;BBB&quot;</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Zu uneffizient und lang. Oft kannst du multiple <code>|</code>
Operatoren ersetzen durch ein <code>%in%</code>. Für jedes Element
kannst du <code>TRUE</code> testen mit <code>all</code>.</p>
<pre class="r"><code>all(symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;))</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>Fügen wir den Code dem Skript hinzu.</p>
<pre class="r"><code>same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]
bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)

if (same) {
  prize &lt;- # look up the prize
} else if (all(bars)) {
  prize &lt;- # assign $5
} else {
  # count cherries
  prize &lt;- # calculate a prize
}

# count diamonds
# double the prize if necessary</code></pre>
<p>Der einfache <code>%</code> Operator führt eine elementweise logische
UND-Verknüpfung durch. <code>&amp;&amp;</code>führt eine kurze logische
UND-Verknüpfung durch und evaluiert die zweite Bedingung nur unter
bestimmten Bedingungen. Er bewertet die zweite Bedingung nur, wenn die
erste wahr ist.</p>
<p>Unsere nächste Subaufgabe ist <code>symbols</code> einen Preis
zuzuordnen. Bei drei gleichen gibt es eine Belohnung, die aber
verschieden hoch ausfällt, je nach Symbol. <code>DD</code>s ergibt 100
Euro, <code>7</code>er ergeben 80 Euro usw. Ein <code>if</code> Baum
kann helfen.</p>
<pre class="r"><code>if (same) {
  symbol &lt;- symbols[1]
  if (symbol == &quot;DD&quot;) {
    prize &lt;- 800
  } else if (symbol == &quot;7&quot;) {
    prize &lt;- 80
  } else if (symbol == &quot;BBB&quot;) {
    prize &lt;- 40
  } else if (symbol == &quot;BB&quot;) {
    prize &lt;- 5
  } else if (symbol == &quot;B&quot;) {
    prize &lt;- 10
  } else if (symbol == &quot;C&quot;) {
    prize &lt;- 10
  } else if (symbol == &quot;0&quot;) {
    prize &lt;- 0
  }
}</code></pre>
<p>Der Code ist natürlich wieder sehr lang und umständlich. Eine weitere
Methode hilft.</p>
</div>
<div id="lookup-tables-lookup-tabellen" class="section level2"
number="7.4">
<h2><span class="header-section-number">7.4</span> Lookup Tables /
Lookup-Tabellen</h2>
<p>Oft hilft Subsetting bei verschiedensten Analysen in R. Wir können
einen Vektor bauen, mit Symbolen als Namen und Preisen als
Elementen.</p>
<pre class="r"><code>payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
  &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
payouts</code></pre>
<pre><code>##  DD   7 BBB  BB   B   C   0 
## 100  80  40  25  10  10   0</code></pre>
<p>Der korrekte Preis kann jetzt leicht extrahiert werden.</p>
<pre class="r"><code>payouts[&quot;DD&quot;]</code></pre>
<pre><code>##  DD 
## 100</code></pre>
<pre class="r"><code>payouts[&quot;B&quot;]</code></pre>
<pre><code>##  B 
## 10</code></pre>
<p>Die <code>unname</code> Funktion lässt dabei den Namen weg.</p>
<pre class="r"><code>unname(payouts[&quot;DD&quot;])</code></pre>
<pre><code>## [1] 100</code></pre>
<p><code>payouts</code> ist eine Lookup-Tabelle. Solche Tabellen kannst
du in R mithilfe von benannten Objekten leicht bauen.</p>
<pre class="r"><code>symbols &lt;- c(&quot;7&quot;, &quot;7&quot;, &quot;7&quot;)
symbols[1]</code></pre>
<pre><code>## [1] &quot;7&quot;</code></pre>
<pre class="r"><code>payouts[symbols[1]]</code></pre>
<pre><code>##  7 
## 80</code></pre>
<pre class="r"><code>symbols &lt;- c(&quot;C&quot;, &quot;C&quot;, &quot;C&quot;)
payouts[symbols[1]]</code></pre>
<pre><code>##  C 
## 10</code></pre>
<p>Du brauchst beim Hochgucken (<em>look up</em>) nicht das exakte
Symbol zu kennen, weil du R sagen kannst hochzuschauen, welches Symbol
auch immer sich in <code>symbols</code> befindet. Da alle Symbole gleich
sind, kannst du dir <code>symbols[1]</code>, <code>symbols[2]</code>
oder <code>symbol[3]</code> aussuchen. Jetzt hast du schon eine
einigermaßen automatisierte Preisberechnung, wenn <code>symbols</code>
“three of a kind” enthält.</p>
<pre class="r"><code>same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]
bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)

if (same) {
  payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
    &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
  prize &lt;- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize &lt;- # assign $5
} else {
  # count cherries
  prize &lt;- # calculate a prize
}

# count diamonds
# double the prize if necessary</code></pre>
<p>Fall 2 kommt vor, wenn alle Symbole Balken sind. Die Zurodnung zu
einem Gewinn von 5 Euro ist hier sehr einfach.</p>
<pre class="r"><code>same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]
bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)

if (same) {
  payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
    &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
  prize &lt;- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize &lt;- 5
} else {
  # count cherries
  prize &lt;- # calculate a prize
}

# count diamonds
# double the prize if necessary</code></pre>
<p>Übrigens, warum entscheidet sich R bei drei gleichen <code>BBB</code>
für Fall 1 und nicht Fall 2? Weil sobald eine Bedingung erfüllt ist
nicht nach weiteren Bedingungen und Ausgaben gesucht wird. Siehe
auch.</p>
<pre class="r"><code>x &lt;- 11
if(x&gt;8) {
print(&quot;1&quot;)
} else if(x&gt;6) {
print(&quot;2&quot;)
} else {
print(&quot;No&quot;)
}</code></pre>
<pre><code>## [1] &quot;1&quot;</code></pre>
<p>Arbeiten wir jetzt den letzten Fall mit den Kirschen durch. Hier geht
es um die Anzahl der Kirschen in <code>symbols</code>.</p>
<p><strong>Aufgabe</strong> Finde <code>C</code>’s: Kirschen.</p>
<p>Denke an Coercion. Auch Diamanten können so gezählt werden.</p>
<pre class="r"><code>symbols &lt;- c(&quot;C&quot;, &quot;DD&quot;, &quot;C&quot;)
symbols == &quot;C&quot;</code></pre>
<pre><code>## [1]  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>sum(symbols == &quot;C&quot;)</code></pre>
<pre><code>## [1] 2</code></pre>
<pre class="r"><code>sum(symbols == &quot;DD&quot;)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Fügen wir unsere Erkenntnisse unserem Programm hinzu.</p>
<pre class="r"><code>same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]
bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)

if (same) {
  payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
    &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
  prize &lt;- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize &lt;- 5
} else {
  cherries &lt;- sum(symbols == &quot;C&quot;)
  prize &lt;- # calculate a prize
}

diamonds &lt;- sum(symbols == &quot;DD&quot;)
# double the prize if necessary</code></pre>
<p>Der Fall, dass 3 Kirschen vorkommen wurde schon im ersten
<code>if</code> Fall abgedeckt, jetzt fehlen noch 2, 1 und 0 Kirschen.
Mit einem <code>if</code> Baum können wir das ganze natürlich
abhandeln.</p>
<pre class="r"><code>if (cherries == 2) {
  prize &lt;- 5
} else if (cherries == 1) {
  prize &lt;- 2
} else {
  prize &lt;- 0
}</code></pre>
<p>Wir können aber auch durch Subsetting die Aufgabe lösen. Dafür
brauchen wir einen Preisvektor: <code>c(0, 2, 5)</code>. Darauf können
wir leicht zugreifen. Die Anzahl der Kirschen haben wir auch schon
bestimmt durch <code>cherries</code>. Jetzt verbinden wir beides
miteinander. Aber bedenke, dass 0, 1, 2 Kirschen möglich sind. Wir
müssen also noch ein wenig modifizieren.</p>
<pre class="r"><code>cherries + 1
c(0, 2, 5)[cherries + 1]</code></pre>
<p>Daraus folgt für unseren Programmcode.</p>
<pre class="r"><code>if (same) {
  payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
    &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
  prize &lt;- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize &lt;- 5
} else {
  cherries &lt;- sum(symbols == &quot;C&quot;)
  prize &lt;- c(0, 2, 5)[cherries + 1]
}

diamonds &lt;- sum(symbols == &quot;DD&quot;)
# double the prize if necessary</code></pre>
<p><strong>Lookup Table vs. If Baum</strong></p>
<p>Als generelle Regel: benutze einen <code>if</code> Baum, wenn jeder
Ast einen anderen Code ausführt.</p>
<p>Benutze <em>Lookup</em> Tabellen, wenn jeder Ast des Baumes einen
anderen Wert ausgibt.</p>
<p>Unsere letzte Unteraufgabe ist es jetzt, den Preis für jeden
Diamanten zu verdoppeln.</p>
<p><strong>Aufgabe</strong> Anpassung für Diamanten.</p>
<pre class="r"><code>prize * 2 ^ diamonds</code></pre>
<p>Das ist einfach. Das finale Skript sieht also so aus.</p>
<pre class="r"><code>same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]
bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)

if (same) {
  payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
    &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
  prize &lt;- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize &lt;- 5
} else {
  cherries &lt;- sum(symbols == &quot;C&quot;)
  prize &lt;- c(0, 2, 5)[cherries + 1]
}

diamonds &lt;- sum(symbols == &quot;DD&quot;)
prize * 2 ^ diamonds</code></pre>
</div>
<div id="kommentare-in-r" class="section level2" number="7.5">
<h2><span class="header-section-number">7.5</span> Kommentare in R</h2>
<p>Kommentare können helfen deinen Code leichter verständlich zu machen.
Für dich, für andere, nach längerer Zeit und zur Übersichtlichkeit.</p>
<pre class="r"><code># identify case
same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]
bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)

# get prize
if (same) {
  payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
    &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
  prize &lt;- unname(payouts[symbols[1]])
} else if (all(bars)) {
  prize &lt;- 5
} else {
  cherries &lt;- sum(symbols == &quot;C&quot;)
  prize &lt;- c(0, 2, 5)[cherries + 1]
}

# adjust for diamonds
diamonds &lt;- sum(symbols == &quot;DD&quot;)
prize * 2 ^ diamonds</code></pre>
<p>Jetzt kannst du deinen ganzen Code in eine Funktion stecken. Achte
dabei darauf, dass die letzte Zeile der Funktion ein Resultat zurück
gibt und identifiziere alle Argumente, die für die Funktion gebraucht
werden.</p>
<p>Oftmals werden die konkreten Beispiele zum Testen deines Codes zu den
Argumenten. <code>symbols</code> wird bei uns zum Argument der Funktion.
Was auch sonst?<br />
Denke noch an unsere erste, die Funktion <code>play</code> und an
<code>get_symbols</code>.</p>
<pre class="r"><code>score &lt;- function (symbols) {
  # identify case
  same &lt;- symbols[1] == symbols[2] &amp;&amp; symbols[2] == symbols[3]
  bars &lt;- symbols %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)
  
  # get prize
  if (same) {
    payouts &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25, 
      &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
    prize &lt;- unname(payouts[symbols[1]])
  } else if (all(bars)) {
    prize &lt;- 5
  } else {
    cherries &lt;- sum(symbols == &quot;C&quot;)
    prize &lt;- c(0, 2, 5)[cherries + 1]
  }
  
  # adjust for diamonds
  diamonds &lt;- sum(symbols == &quot;DD&quot;)
  prize * 2 ^ diamonds
}

get_symbols &lt;- function() {
  wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;)
  sample(wheel, size = 3, replace = TRUE, 
    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))
}

play &lt;- function() {
  symbols &lt;- get_symbols()
  print(symbols)
  score(symbols)
}

play()</code></pre>
<pre><code>## [1] &quot;BBB&quot; &quot;0&quot;   &quot;0&quot;</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>play()</code></pre>
<pre><code>## [1] &quot;0&quot; &quot;0&quot; &quot;B&quot;</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>play()</code></pre>
<pre><code>## [1] &quot;0&quot; &quot;0&quot; &quot;0&quot;</code></pre>
<pre><code>## [1] 0</code></pre>
</div>
</div>
<div id="s3" class="section level1" number="8">
<h1><span class="header-section-number">8</span> S3</h1>
<p>Wir wollen jetzt uns das Ergebnis in einem anschaulichen Format
ausgeben lassen. Ohne Gänsefüßchen und mit einem Eurozeichen oder
Dollarzeichen vor oder hinter dem Gewinn.<br />
Durch das Aufrufen der Funktion werden durch das <code>print</code> die
Symbole ausgedruckt. Aber nicht in der Variable gespeichert. Weise ich
das Ergebnis einer Variable zu und rufe diese auf, wird nur der Gewinn
angegeben.</p>
<div id="das-s3-system" class="section level2" number="8.1">
<h2><span class="header-section-number">8.1</span> Das S3 System</h2>
<p>Wenn du <code>print</code> auf einen numrischen Vektor ausführst,
wird eine Zahl ausgegeben.</p>
<pre class="r"><code>num &lt;- 1000000000
print(num)</code></pre>
<pre><code>## [1] 1e+09</code></pre>
<p>Übergibst du die Zahl der S3 Klasse <code>POSIXct</code> gefolgt von
<code>POSIXt</code>, <code>print</code> gibt eine Zeit aus.</p>
<pre class="r"><code>class(num) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;)
print(num)</code></pre>
<pre><code>## [1] &quot;2001-09-09 03:46:40 CEST&quot;</code></pre>
<p>Wenn du Objekte mit Klassen benutzt, so findest du dich im S3 System
wieder. Dieses besteht aus:</p>
<ol style="list-style-type: decimal">
<li>Attributen</li>
<li>Funktionen</li>
<li>Methoden</li>
</ol>
</div>
<div id="attribute-1" class="section level2" number="8.2">
<h2><span class="header-section-number">8.2</span> Attribute</h2>
<p>Im vorherigen Kapitel: Attribute, hast du gelernt, dass viele Objekte
mit Attributen daherkommen. Zusätzliche Informationen, die einen Namen
haben und an ein Objekt gehangen werden. Wir hatten es mit Metadaten
verglichen. Zum Beispiel speichert ein <em>Data Frame</em> seine Reihen-
und Spaltennamen als Attribute. Auch der Klassenname wird als Attribut
gespeichert (<code>data.frame</code>).</p>
<p>Attribute können über <code>attributes</code> aufgerufen werden.</p>
<pre class="r"><code>deck &lt;- data.frame(
  face = c(&quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, &quot;nine&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;,
    &quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;, &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, 
    &quot;nine&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;, &quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;, 
    &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, &quot;nine&quot;, &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;, &quot;five&quot;, 
    &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;, &quot;king&quot;, &quot;queen&quot;, &quot;jack&quot;, &quot;ten&quot;, &quot;nine&quot;, 
    &quot;eight&quot;, &quot;seven&quot;, &quot;six&quot;, &quot;five&quot;, &quot;four&quot;, &quot;three&quot;, &quot;two&quot;, &quot;ace&quot;),  
  suit = c(&quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, 
    &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, &quot;spades&quot;, 
    &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, 
    &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;clubs&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, 
    &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, 
    &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;diamonds&quot;, &quot;hearts&quot;, 
    &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, 
    &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;, &quot;hearts&quot;), 
  value = c(13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 
    7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 13, 12, 11, 
    10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
)
deck</code></pre>
<pre><code>##     face     suit value
## 1   king   spades    13
## 2  queen   spades    12
## 3   jack   spades    11
## 4    ten   spades    10
## 5   nine   spades     9
## 6  eight   spades     8
## 7  seven   spades     7
## 8    six   spades     6
## 9   five   spades     5
## 10  four   spades     4
## 11 three   spades     3
## 12   two   spades     2
## 13   ace   spades     1
## 14  king    clubs    13
## 15 queen    clubs    12
## 16  jack    clubs    11
## 17   ten    clubs    10
## 18  nine    clubs     9
## 19 eight    clubs     8
## 20 seven    clubs     7
## 21   six    clubs     6
## 22  five    clubs     5
## 23  four    clubs     4
## 24 three    clubs     3
## 25   two    clubs     2
## 26   ace    clubs     1
## 27  king diamonds    13
## 28 queen diamonds    12
## 29  jack diamonds    11
## 30   ten diamonds    10
## 31  nine diamonds     9
## 32 eight diamonds     8
## 33 seven diamonds     7
## 34   six diamonds     6
## 35  five diamonds     5
## 36  four diamonds     4
## 37 three diamonds     3
## 38   two diamonds     2
## 39   ace diamonds     1
## 40  king   hearts    13
## 41 queen   hearts    12
## 42  jack   hearts    11
## 43   ten   hearts    10
## 44  nine   hearts     9
## 45 eight   hearts     8
## 46 seven   hearts     7
## 47   six   hearts     6
## 48  five   hearts     5
## 49  four   hearts     4
## 50 three   hearts     3
## 51   two   hearts     2
## 52   ace   hearts     1</code></pre>
<pre class="r"><code>attributes(deck)</code></pre>
<pre><code>## $names
## [1] &quot;face&quot;  &quot;suit&quot;  &quot;value&quot;
## 
## $class
## [1] &quot;data.frame&quot;
## 
## $row.names
##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25
## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
## [51] 51 52</code></pre>
<p>R kommt mit vielen Hilfsfunktionen daher. Kennengelernt haben wir
schon die <code>names</code>, die <code>dim</code> und die
<code>class</code> Funktion. Es gibt noch <code>row.names</code>,
<code>levels</code> und viele andere.</p>
<pre class="r"><code>row.names(deck)</code></pre>
<pre><code>##  [1] &quot;1&quot;  &quot;2&quot;  &quot;3&quot;  &quot;4&quot;  &quot;5&quot;  &quot;6&quot;  &quot;7&quot;  &quot;8&quot;  &quot;9&quot;  &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot;
## [16] &quot;16&quot; &quot;17&quot; &quot;18&quot; &quot;19&quot; &quot;20&quot; &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; &quot;26&quot; &quot;27&quot; &quot;28&quot; &quot;29&quot; &quot;30&quot;
## [31] &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; &quot;36&quot; &quot;37&quot; &quot;38&quot; &quot;39&quot; &quot;40&quot; &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot;
## [46] &quot;46&quot; &quot;47&quot; &quot;48&quot; &quot;49&quot; &quot;50&quot; &quot;51&quot; &quot;52&quot;</code></pre>
<pre class="r"><code>row.names(deck) &lt;- 101:152
row.names(deck)</code></pre>
<pre><code>##  [1] &quot;101&quot; &quot;102&quot; &quot;103&quot; &quot;104&quot; &quot;105&quot; &quot;106&quot; &quot;107&quot; &quot;108&quot; &quot;109&quot; &quot;110&quot; &quot;111&quot; &quot;112&quot;
## [13] &quot;113&quot; &quot;114&quot; &quot;115&quot; &quot;116&quot; &quot;117&quot; &quot;118&quot; &quot;119&quot; &quot;120&quot; &quot;121&quot; &quot;122&quot; &quot;123&quot; &quot;124&quot;
## [25] &quot;125&quot; &quot;126&quot; &quot;127&quot; &quot;128&quot; &quot;129&quot; &quot;130&quot; &quot;131&quot; &quot;132&quot; &quot;133&quot; &quot;134&quot; &quot;135&quot; &quot;136&quot;
## [37] &quot;137&quot; &quot;138&quot; &quot;139&quot; &quot;140&quot; &quot;141&quot; &quot;142&quot; &quot;143&quot; &quot;144&quot; &quot;145&quot; &quot;146&quot; &quot;147&quot; &quot;148&quot;
## [49] &quot;149&quot; &quot;150&quot; &quot;151&quot; &quot;152&quot;</code></pre>
<pre class="r"><code>levels(deck) &lt;- c(&quot;level 1&quot;, &quot;level 2&quot;, &quot;level 3&quot;)
levels(deck)</code></pre>
<pre><code>## [1] &quot;level 1&quot; &quot;level 2&quot; &quot;level 3&quot;</code></pre>
<pre class="r"><code>attributes(deck)</code></pre>
<pre><code>## $names
## [1] &quot;face&quot;  &quot;suit&quot;  &quot;value&quot;
## 
## $class
## [1] &quot;data.frame&quot;
## 
## $row.names
##  [1] 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119
## [20] 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138
## [39] 139 140 141 142 143 144 145 146 147 148 149 150 151 152
## 
## $levels
## [1] &quot;level 1&quot; &quot;level 2&quot; &quot;level 3&quot;</code></pre>
<p>R lässt dich irgendwelche Attribute hinzufügen, auch wenn sie fortan
ignoriert werden. Du kannst mit <code>attr</code> irgendwelche Attribute
hinzufügen oder dir den Wert eines Attributes anschauen.</p>
<pre class="r"><code>one_play &lt;- play()</code></pre>
<pre><code>## [1] &quot;0&quot;   &quot;B&quot;   &quot;BBB&quot;</code></pre>
<pre class="r"><code>one_play</code></pre>
<pre><code>## [1] 0</code></pre>
<pre class="r"><code>attributes(one_play)</code></pre>
<pre><code>## NULL</code></pre>
<p><code>attr</code> braucht zwei Argumente: ein R Objekt und den Namen
eines Attributs als <em>Character String</em>.<br />
Geben wir <code>one_play</code> ein Attribut namens
<code>symbols</code>, dass einen Vektor mit <em>Character Strings</em>
enthält.</p>
<pre class="r"><code>attr(one_play, &quot;symbols&quot;) &lt;- c(&quot;B&quot;, &quot;0&quot;, &quot;B&quot;)
attributes(one_play)</code></pre>
<pre><code>## $symbols
## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot;</code></pre>
<p>Die Werte anschauen über <code>attr</code> und den entsprechenden
Namen. Easy.</p>
<pre class="r"><code>attr(one_play, &quot;symbols&quot;)</code></pre>
<pre><code>## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot;</code></pre>
<pre class="r"><code>one_play</code></pre>
<pre><code>## [1] 0
## attr(,&quot;symbols&quot;)
## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot;</code></pre>
<p>Wenn du einem Vektor Attribute verpasst wird R diese normalerweise
unter dem Wert des Vektors anzeigen. Wenn das Attribut die Klasse des
Vektors wechselt, so zeigt R alle Informationen des Vektors auf eine
neue Art und Weise an. Wie bei <code>POSIXct</code> gesehen.</p>
<p><strong>Aufgabe</strong> Füge ein Objekt hinzu.</p>
<p>Modifiziere jetzt das Objekt <code>play</code>, um einen Preis
zurückzugeben, der die <code>symbols</code> als Attribute mitliefert.
<code>print(symbols)</code> brauchen wir jetzt natürlich nicht mehr.</p>
<pre class="r"><code>play &lt;- function() {
  symbols &lt;- get_symbols()
  prize &lt;- score(symbols)
  attr(prize, &quot;symbols&quot;) &lt;- symbols
  prize
}</code></pre>
<p><code>play</code> gibt jetzt sowohl den Preis, als auch die
angehängten Symbole mit dem Preis wieder. Preis und Symbole bleiben als
Paar zusammen, auch wenn wir sie an ein neues Objekt übergeben.</p>
<pre class="r"><code>play()</code></pre>
<pre><code>## [1] 0
## attr(,&quot;symbols&quot;)
## [1] &quot;DD&quot; &quot;BB&quot; &quot;0&quot;</code></pre>
<pre class="r"><code>two_play &lt;- play()
two_play</code></pre>
<pre><code>## [1] 0
## attr(,&quot;symbols&quot;)
## [1] &quot;B&quot; &quot;0&quot; &quot;0&quot;</code></pre>
<p>Auch die <code>structure</code> Funktion kann Attribute zu einem
Objekt setzen. Du kannst den Argumenten einen beliebigen Namen
verpassen.</p>
<pre class="r"><code>play &lt;- function() {
  symbols &lt;- get_symbols()
  structure(score(symbols), symbols = symbols)
}

three_play &lt;- play()
three_play</code></pre>
<pre><code>## [1] 0
## attr(,&quot;symbols&quot;)
## [1] &quot;0&quot; &quot;0&quot; &quot;B&quot;</code></pre>
<p>Jetzt kannst du deine eigene Funktion schreiben, die die Attribute
benutzt.</p>
<pre class="r"><code>slot_display &lt;- function(prize){

  # extract symbols
  symbols &lt;- attr(prize, &quot;symbols&quot;)

  # collapse symbols into single string
  symbols &lt;- paste(symbols, collapse = &quot; &quot;)

  # combine symbol with prize as a character string
  # \n is special escape sequence for a new line (i.e. return or enter)
  string &lt;- paste(symbols, prize, sep = &quot;\n$&quot;)

  # display character string in console without quotes
  cat(string)
}
one_play</code></pre>
<pre><code>## [1] 0
## attr(,&quot;symbols&quot;)
## [1] &quot;B&quot; &quot;0&quot; &quot;B&quot;</code></pre>
<pre class="r"><code>slot_display(one_play)</code></pre>
<pre><code>## B 0 B
## $0</code></pre>
<p>Die Funktion erwartet ein Objekt <code>one_play</code>, dass sowohl
einen numerischen Wert also auch ein <code>symbols</code> Attribut
liefert. Die Werte von <code>symbols</code> werden als ein Objekt
gespeichert. Danach benutzt unsere Funktion <code>paste</code>, um die
drei <em>Strings</em> in einen einzigen <em>String</em>
zusammenzuführen. <code>paste</code> benutzt den Wert von
<code>collapse</code>, um die einzelnen <em>Character Strings</em>
voneinander zu trennen. So werden die Werte <code>B O B</code>
voneinander durch ein Leerzeichen getrennt.<br />
Jetzt haben wir <code>symbols</code> und <code>prize</code>. Zwei
<em>Strings</em>, die wir durch <code>paste</code> zusammenführen.
<code>sep</code> ist der Seperator zwischen den beiden <em>Strings</em>,
so dass unser Ergebnis so aussieht: <code>"B O B\n$0"</code>.<br />
<code>cat</code> ist wie <code>print</code>, nur dass es nicht seinen
Output mit Gänsefüßchen umrahmt. <code>cat</code> ersetzt auch
<code>\n</code> durch eine neue Zeile. Der Output von <code>play</code>
sieht jetzt ein wenig schöner aus.</p>
<pre class="r"><code>slot_display(play())</code></pre>
<pre><code>## B 0 BB
## $0</code></pre>
<pre class="r"><code>slot_display(play())</code></pre>
<pre><code>## B B 0
## $0</code></pre>
</div>
<div id="generische-funktionen" class="section level2" number="8.3">
<h2><span class="header-section-number">8.3</span> Generische
Funktionen</h2>
<p>R benutzt <code>print</code> häufiger als man denken mag. Immer wenn
ein Ergebnis in der Console ausgegeben wird, geschieht dies im
Hintergrund.</p>
<pre class="r"><code>print(pi)</code></pre>
<pre><code>## [1] 3.141593</code></pre>
<pre class="r"><code>pi</code></pre>
<pre><code>## [1] 3.141593</code></pre>
<pre class="r"><code>print(head(deck))</code></pre>
<pre><code>##      face   suit value
## 101  king spades    13
## 102 queen spades    12
## 103  jack spades    11
## 104   ten spades    10
## 105  nine spades     9
## 106 eight spades     8</code></pre>
<pre class="r"><code>head(deck)</code></pre>
<pre><code>##      face   suit value
## 101  king spades    13
## 102 queen spades    12
## 103  jack spades    11
## 104   ten spades    10
## 105  nine spades     9
## 106 eight spades     8</code></pre>
<pre class="r"><code>print(play())</code></pre>
<pre><code>## [1] 0
## attr(,&quot;symbols&quot;)
## [1] &quot;BBB&quot; &quot;0&quot;   &quot;0&quot;</code></pre>
<pre class="r"><code>play()</code></pre>
<pre><code>## [1] 0
## attr(,&quot;symbols&quot;)
## [1] &quot;BBB&quot; &quot;0&quot;   &quot;DD&quot;</code></pre>
<p><code>print</code> ist eine generische Funktion. Das heißt, dass es
verschiedenen Dinge in verschiedenen Fällen macht.</p>
<pre class="r"><code>num &lt;- 1000000000
print(num)</code></pre>
<pre><code>## [1] 1e+09</code></pre>
<pre class="r"><code>class(num) &lt;- c(&quot;POSIXct&quot;, &quot;POSIXt&quot;)
print(num)</code></pre>
<pre><code>## [1] &quot;2001-09-09 03:46:40 CEST&quot;</code></pre>
</div>
<div id="methoden" class="section level2" number="8.4">
<h2><span class="header-section-number">8.4</span> Methoden</h2>
<p><code>print</code> ruft eine spezielle Funktion auf:
<code>UseMethod</code>.</p>
<pre class="r"><code>print</code></pre>
<pre><code>## function (x, ...) 
## UseMethod(&quot;print&quot;)
## &lt;bytecode: 0x0000020106975678&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p><code>UserMethod</code> untersucht die Klasse vom <em>Input</em> und
übergibt alle Argumente einer neuen Funktion. Wenn du <code>print</code>
ein POSIXct Objekt übergibst, gibt <code>UsMethod</code>
<code>print</code>s Argumente an <code>print.POSIXct</code> weiter. Das
Ergebnis lautet dann.</p>
<pre class="r"><code>print.POSIXct</code></pre>
<pre><code>## function (x, tz = &quot;&quot;, usetz = TRUE, max = NULL, ...) 
## {
##     if (is.null(max)) 
##         max &lt;- getOption(&quot;max.print&quot;, 9999L)
##     FORM &lt;- if (missing(tz)) 
##         function(z) format(z, usetz = usetz)
##     else function(z) format(z, tz = tz, usetz = usetz)
##     if (max &lt; length(x)) {
##         print(FORM(x[seq_len(max)]), max = max + 1, ...)
##         cat(&quot; [ reached &#39;max&#39; / getOption(\&quot;max.print\&quot;) -- omitted&quot;, 
##             length(x) - max, &quot;entries ]\n&quot;)
##     }
##     else if (length(x)) 
##         print(FORM(x), max = max, ...)
##     else cat(class(x)[1L], &quot;of length 0\n&quot;)
##     invisible(x)
## }
## &lt;bytecode: 0x000002010e2ba810&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p>Wenn du <code>print</code> einem Faktorobjekt übergibst, wird
<code>UseMethod</code> alle Argumente von <code>print</code> als
<code>print.factor</code> der <code>print</code> Funktion anhängen.</p>
<pre class="r"><code>print.factor</code></pre>
<pre><code>## function (x, quote = FALSE, max.levels = NULL, width = getOption(&quot;width&quot;), 
##     ...) 
## {
##     ord &lt;- is.ordered(x)
##     if (length(x) == 0L) 
##         cat(if (ord) 
##             &quot;ordered&quot;
##         else &quot;factor&quot;, &quot;(0)\n&quot;, sep = &quot;&quot;)
##     else {
##         xx &lt;- character(length(x))
##         xx[] &lt;- as.character(x)
##         keepAttrs &lt;- setdiff(names(attributes(x)), c(&quot;levels&quot;, 
##             &quot;class&quot;))
##         attributes(xx)[keepAttrs] &lt;- attributes(x)[keepAttrs]
##         print(xx, quote = quote, ...)
##     }
##     maxl &lt;- if (is.null(max.levels)) 
##         TRUE
##     else max.levels
##     if (maxl) {
##         n &lt;- length(lev &lt;- encodeString(levels(x), quote = ifelse(quote, 
##             &quot;\&quot;&quot;, &quot;&quot;)))
##         colsep &lt;- if (ord) 
##             &quot; &lt; &quot;
##         else &quot; &quot;
##         T0 &lt;- &quot;Levels: &quot;
##         if (is.logical(maxl)) 
##             maxl &lt;- {
##                 width &lt;- width - (nchar(T0, &quot;w&quot;) + 3L + 1L + 
##                   3L)
##                 lenl &lt;- cumsum(nchar(lev, &quot;w&quot;) + nchar(colsep, 
##                   &quot;w&quot;))
##                 if (n &lt;= 1L || lenl[n] &lt;= width) 
##                   n
##                 else max(1L, which.max(lenl &gt; width) - 1L)
##             }
##         drop &lt;- n &gt; maxl
##         cat(if (drop) 
##             paste(format(n), &quot;&quot;), T0, paste(if (drop) 
##             c(lev[1L:max(1, maxl - 1)], &quot;...&quot;, if (maxl &gt; 1) lev[n])
##         else lev, collapse = colsep), &quot;\n&quot;, sep = &quot;&quot;)
##     }
##     if (!isTRUE(val &lt;- .valid.factor(x))) 
##         warning(val)
##     invisible(x)
## }
## &lt;bytecode: 0x000002010a531a58&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p><code>print.POSIXct</code> und <code>print.factor</code> sind
Methoden von <code>print</code>. Sie arbeiten wie reguläre R Funktionen.
Sie machen beide aber verschiedene Dinge!<br />
<code>print</code> ruft <code>UseMethod</code> auf, welches dann eine
spezielle Methode wählt. Diese hängt von der Klasse von
<code>print</code>s erstem Argument ab.<br />
Welche Methoden existieren für generische Funktionen, kannst du mithilfe
des <code>method</code> Aufrufs auf eine Funktion sehen.
<code>print</code> hat fast 200 Methoden. Es existieren also sehr viele
Klassen in R.</p>
<pre class="r"><code>methods(print)[1:10]</code></pre>
<pre><code>##  [1] &quot;print.acf&quot;      &quot;print.AES&quot;      &quot;print.all_vars&quot; &quot;print.anova&quot;   
##  [5] &quot;print.any_vars&quot; &quot;print.aov&quot;      &quot;print.aovlist&quot;  &quot;print.ar&quot;      
##  [9] &quot;print.Arima&quot;    &quot;print.arima0&quot;</code></pre>
<p>Dieses System ist als <strong>S3</strong> bekannt. Viele bekannte R
Funktionen sind S3 generisch, z.B. <code>summary</code>und
<code>head</code>. Andere Funktionen wie <code>c</code>, <code>+</code>,
<code>-</code>, <code>&lt;</code> und weitere verhalten sich wie
generische Funktionen. Sie rufen aber <code>.primitive</code> statt
<code>UseMethod</code> auf.</p>
<div id="method-dispatch" class="section level3" number="8.4.1">
<h3><span class="header-section-number">8.4.1</span> Method
Dispatch</h3>
<p><code>UseMethod</code> benutzt ein sehr simples System, um Methoden
an Funktionen anzupassen.<br />
Jede S3 Methode hat einen zweigeteilten Namen. Der erste Teil bezieht
sich auf die Funktion, mit der die Methode arbeitet. Der zweite Teil
bezieht sich auf die Klasse. Beide Teile sind durch einen Punkt
miteinander verbunden, wie <code>print.function</code>. Arbeiten wir mit
Matrizen: <code>summary.matrix</code>, usw.</p>
<p>Du kannst mit diesem System arbeiten, indem du eine eigene Funktion
schreibst und ihr einen gültigen S3 Namen verpasst. Geben wir z.B.
<code>one_play</code> eine Klasse. R speichert sämtliche <em>Character
Strings</em> im Klassenattribut:</p>
<pre class="r"><code>class(one_play) &lt;- &quot;slots&quot;</code></pre>
<p>Schreiben wir jetzt eine <code>print</code> Methode für die Klasse.
Sie muss <code>print.slots</code> genannt werden, sonst wird sie nicht
gefunden. Sie muss auch dieselben Argumente wie <code>print</code>
haben.</p>
<pre class="r"><code>args(print)</code></pre>
<pre><code>## function (x, ...) 
## NULL</code></pre>
<pre class="r"><code>print.slots &lt;- function(x, ...) {
  cat(&quot;I&#39;m using the print.slots method&quot;)
}</code></pre>
<p>Diese Methode funktioniert, macht aber hier wenig Sinn.</p>
<pre class="r"><code>print(one_play)</code></pre>
<pre><code>## I&#39;m using the print.slots method</code></pre>
<pre class="r"><code>one_play</code></pre>
<pre><code>## I&#39;m using the print.slots method</code></pre>
<pre class="r"><code>rm(print.slots)</code></pre>
<p>Manche Objekte haben mehrere Klassen. Welche Klasse benutzt
<code>UseMethod</code> jetzt, um eine <code>print</code> Methode zu
finden?</p>
<pre class="r"><code>now &lt;- Sys.time()
attributes(now)</code></pre>
<pre><code>## $class
## [1] &quot;POSIXct&quot; &quot;POSIXt&quot;</code></pre>
<p><code>UseMethod</code> sucht zuerst nach einer Methode, die zur
ersten Klassen passt. Wird keine gefunden, sucht sie nach einer Methode,
die zur zweiten Klasse passt. Gibst du <code>print</code> ein Objekt,
deren Klasse(n) keine <code>print</code> Methode haben,
<code>UseMethod</code> ruft <code>print.default</code> auf.<br />
Lass uns eine bessere Methode für unseren <em>slot machine Output</em>
schreiben.</p>
<p><strong>Aufgabe</strong> Schreibe eine <em>print</em> Methode.</p>
<p>Die Methode sollte <code>slot_display</code> aufrufen.<br />
Wir haben schon harte Arbeit für die Methode geleistet. Folgende Methode
funktioniert.</p>
<p>Der Name natürlich <code>print.slots</code>, so dass
<code>UseMethod</code> sie finden kann.</p>
<pre class="r"><code>print.slots &lt;- function(x, ...) {
  slot_display(x)
}</code></pre>
<p>R benutzt jetzt automatisch <code>slot_display</code>, um Objekte der
Klasse <em>slots</em> anzuzeigen.</p>
<pre class="r"><code>one_play</code></pre>
<pre><code>## B 0 B
## $0</code></pre>
<p>Jetzt wollen wir sichergehen, dass jeder Output die Klasse
<code>slots</code> hat.</p>
<p><strong>Aufgabe</strong> Füge eine Klasse hinzu.</p>
<p>Modifiziere die <code>play</code> Funktion, so dass sie
<code>slots</code> zum <code>class</code> Attribut des Outputs
zuweist.</p>
<pre class="r"><code>play &lt;- function() {
  symbols &lt;- get_symbols()
  structure(score(symbols), symbols = symbols)
}</code></pre>
<p>Füge nur <code>class = "slots"</code> in
<code>structure</code>hinzu.</p>
<pre class="r"><code>play &lt;- function() {
  symbols &lt;- get_symbols()
  structure(score(symbols), symbols = symbols, class = &quot;slots&quot;)
}</code></pre>
<p>Jedes Spiel der <em>slot machine</em> hat jetzt die Klasse
<code>slots</code>.</p>
<pre class="r"><code>class(play())</code></pre>
<pre><code>## [1] &quot;slots&quot;</code></pre>
<p>Als Ergebnis gibt R alles in unserem schönen Format wieder.</p>
<pre class="r"><code>play()</code></pre>
<pre><code>## 0 0 0
## $0</code></pre>
<pre class="r"><code>play()</code></pre>
<pre><code>## B 7 0
## $0</code></pre>
<pre class="r"><code>play()</code></pre>
<pre><code>## BB B 0
## $0</code></pre>
<pre class="r"><code>play()</code></pre>
<pre><code>## 0 0 BB
## $0</code></pre>
<pre class="r"><code>play()</code></pre>
<pre><code>## 0 0 0
## $0</code></pre>
</div>
</div>
<div id="klassen-1" class="section level2" number="8.5">
<h2><span class="header-section-number">8.5</span> Klassen</h2>
<p>Du kannst jetzt auch eine neue Klasse von Objekten in R machen:</p>
<ul>
<li>Wähle einen Namen für deine Klasse.</li>
<li>Ordne jeder Instanz deiner Klasse ein class Attribut zu.</li>
<li>Schreibe class Methoden für irgendwelche generischen Funktionen, für
die du wahrscheinlich Objekte deiner Klasse anwendest.</li>
</ul>
<p>Du kannst Methoden einer Klasse mit dem <code>class</code> Argument
aufrufen. Jede geschriebene Methode für die Klasse wird angezeigt.</p>
<pre class="r"><code>methods(class = &quot;factor&quot;)</code></pre>
<pre><code>##  [1] [             [[            [[&lt;-          [&lt;-           all.equal    
##  [6] as.character  as.data.frame as.Date       as.list       as.logical   
## [11] as.POSIXlt    as.vector     c             coerce        droplevels   
## [16] format        initialize    is.na&lt;-       length&lt;-      levels&lt;-     
## [21] Math          Ops           plot          print         relevel      
## [26] relist        rep           scale_type    show          slotsFromS3  
## [31] summary       Summary       xtfrm        
## see &#39;?methods&#39; for accessing help and source code</code></pre>
<p>Es ist viel Arbeit und normalerweise musst du eine <code>class</code>
Methode für jede <em>basic</em> Operation in R schreiben.</p>
<p>R lässt Attribute weg, wenn Objekte zu einem Vektor verbunden
werden.</p>
<pre class="r"><code>play1 &lt;- play()
play1</code></pre>
<pre><code>## B BBB BB
## $5</code></pre>
<pre class="r"><code>play2 &lt;- play()
play2</code></pre>
<pre><code>## BB 0 B
## $0</code></pre>
<pre class="r"><code>c(play1, play2)</code></pre>
<pre><code>## [1] 5 0</code></pre>
<p>Der Vektor hat jetzt nicht mehr das <em>slots</em> Klassenattribut.
Auch beim Subsetting verliert ein Objekt sein Attribut.</p>
<pre class="r"><code>play1[1]</code></pre>
<pre><code>## [1] 5</code></pre>
<p>Du kannst das vermeiden, indem du eine <code>c.slots</code> Methode
schreibst, sowie eine <code>[.slots</code> Methode. Dann hast du aber
andere Probleme.<br />
Wir bleiben also beim <em>single prize value</em>.</p>
</div>
</div>
<div id="loopsschleifen" class="section level1" number="9">
<h1><span class="header-section-number">9</span> Loops/Schleifen</h1>
<p>Schleifen sind R’s Methode eine Aufgabe zu wiederholen. Schauen wir
uns unsere Slot Maschine und die <code>score</code> Funktion an. Ihr
wird Betrug vorgeworfen! Das lässt sich natürlich nur überprüfen, wenn
wir das Programm einige Male laufen lassen. Einige sehr viele Male
natürlich.</p>
<div id="erwatungswert" class="section level2" number="9.1">
<h2><span class="header-section-number">9.1</span> Erwatungswert</h2>
<p>Der Erwartungswert einer Funktion ist der gewichtete Durchschnitt.
Jeder mögliche Wert wird mit der Eintrittswahrscheinlichkeit
multipliziert und aufsummiert.</p>
<p><span class="math display">\[E(x) = \sum_{i=1}^n (x_i \cdot
P(x_i))\]</span></p>
<p>Spielen wir das Spiel unendlich oft, so erhalten wir als
durchschnittlichen Gewinn den Erwartungswert.<br />
Benutzen wir diese Formel, um ein paar einfache Erwartungswerte
auszurechnen.</p>
<p>Berechnen wir den Erwartungswert des einfachen Würfelwurfes. Jede
Zahl von 1 bis 6 wird mit ihrer Eintrittswahrscheinlichkeit 1/6
multipliziert und aufsummiert.</p>
<pre class="r"><code>die &lt;- c(1, 2, 3, 4, 5, 6)</code></pre>
<p><span class="math display">\[ E(die) = \sum_{i=1}^n (die_i \cdot
P(die_i))\]</span></p>
<p>Leicht können wir aufsummieren.</p>
<p><span class="math display">\[\begin{align}
    E(die) &amp;= \sum_{i=1}^n (die_i \cdot P(die_i)) \\
    &amp;= 1 \cdot \frac{1}{6} +  ...  + 6 \cdot \frac{1}{6} \\
    &amp;= 3.5
\end{align}\]</span></p>
<p>Der Erwartungswert eines einfachen Würfelwurfes liegt also bei
3.5</p>
<p>Es geht natürlich auch ein wenig schwieriger. Lass uns jetzt den
Erwartungswert eines Würfelpaares berechnen, wobei nicht alle
Wahrscheinlichkeiten gleich groß sind.</p>
<p>Zuerst brauchen wir alle möglichen Kombinationen.</p>
</div>
<div id="expand.grid" class="section level2" number="9.2">
<h2><span class="header-section-number">9.2</span>
<code>expand.grid</code></h2>
<p>Die <code>expand.grid</code> Funktion bietet einen schnellen Weg alle
Kombinationen der Elemente von n Vektoren zu berechnen. Berechne zum
Beispiel alle Kombinationen von <code>c(1, 2, 3)</code> und
<code>c(1, 2)</code>. Es sind 6 Stück.</p>
<p>Wir führen zum Beispiel <code>expand.grid</code> auf 2 Kopien von
<code>die</code> aus.</p>
<pre class="r"><code>rolls &lt;- expand.grid(die, die)
rolls</code></pre>
<pre><code>##    Var1 Var2
## 1     1    1
## 2     2    1
## 3     3    1
## 4     4    1
## 5     5    1
## 6     6    1
## 7     1    2
## 8     2    2
## 9     3    2
## 10    4    2
## 11    5    2
## 12    6    2
## 13    1    3
## 14    2    3
## 15    3    3
## 16    4    3
## 17    5    3
## 18    6    3
## 19    1    4
## 20    2    4
## 21    3    4
## 22    4    4
## 23    5    4
## 24    6    4
## 25    1    5
## 26    2    5
## 27    3    5
## 28    4    5
## 29    5    5
## 30    6    5
## 31    1    6
## 32    2    6
## 33    3    6
## 34    4    6
## 35    5    6
## 36    6    6</code></pre>
<p>Insgesamt erhalten wir also alle 36 Kombinationen.<br />
Natürlich können wir auch mehr als 2 Vektoren auf die Funktion anwenden,
z.B. <code>expand.grid(die, die, die)</code> usw. Es wird immer ein
<em>Data Frame</em> ausgegeben, der jede mögliche Kombination genau
einmal enthält.</p>
<p>Die Augensumme kannst du leicht berechnen und der Tabelle
hinzufügen.</p>
<pre class="r"><code>rolls$value &lt;- rolls$Var1 + rolls$Var2
head(rolls, 3)</code></pre>
<pre><code>##   Var1 Var2 value
## 1    1    1     2
## 2    2    1     3
## 3    3    1     4</code></pre>
<p>Als nächstes brauchen wir noch die Wahrscheinlichkeiten. Da die
Würfelwürfe unabhängig voneinander sind, gilt:</p>
<p><span class="math display">\[\begin{align}
   P(A\&amp;B\&amp;C\&amp;...) = P(A) \cdot P(B) \cdot P(C) \cdot ...
\end{align}\]</span></p>
<p>Die Wahrscheinlichkeit für (1, 1) ist also die Wahrscheinlichkeit für
eine 1 mal die Wahrscheinlichkeit für noch eine 1. Bei unserem Würfel
(nicht fair) ist das jeweils 1/8.</p>
<p><span class="math display">\[\begin{align}
    P(1\&amp;1) &amp;= P(1) \cdot P(1) \\
            &amp;= 1/8 \cdot 1/8 \\
            &amp;= 1/64
\end{align}\]</span></p>
<p>Insgesamt gilt für die Eintrittswahrscheinlichkeit unseres unfairen
Würfels:</p>
<pre class="r"><code>prob &lt;- c(&quot;1&quot; = 1/8, &quot;2&quot; = 1/8, &quot;3&quot; = 1/8, &quot;4&quot; = 1/8, &quot;5&quot; = 1/8, &quot;6&quot; = 3/8)

prob</code></pre>
<pre><code>##     1     2     3     4     5     6 
## 0.125 0.125 0.125 0.125 0.125 0.375</code></pre>
<p>Jetzt können wir die Wahrscheinlichkeit für die Zahlen 1 bis 6
berechnen. Erst für Würfelwurf <code>1</code>, dann für Würfelwurf
<code>2</code>. Für alle 36 Fälle. Dann können wir multiplizieren.</p>
<pre class="r"><code>rolls$Var1</code></pre>
<pre><code>##  [1] 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6</code></pre>
<pre class="r"><code>prob[rolls$Var1]</code></pre>
<pre><code>##     1     2     3     4     5     6     1     2     3     4     5     6     1 
## 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 0.125 
##     2     3     4     5     6     1     2     3     4     5     6     1     2 
## 0.125 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375 0.125 0.125 
##     3     4     5     6     1     2     3     4     5     6 
## 0.125 0.125 0.125 0.375 0.125 0.125 0.125 0.125 0.125 0.375</code></pre>
<pre class="r"><code>rolls$prob1 &lt;- prob[rolls$Var1]
head(rolls, 3)</code></pre>
<pre><code>##   Var1 Var2 value prob1
## 1    1    1     2 0.125
## 2    2    1     3 0.125
## 3    3    1     4 0.125</code></pre>
<p>Ein Vektor wurde angefügt.</p>
<pre class="r"><code>rolls$prob2 &lt;- prob[rolls$Var2]
head(rolls, 3)</code></pre>
<pre><code>##   Var1 Var2 value prob1 prob2
## 1    1    1     2 0.125 0.125
## 2    2    1     3 0.125 0.125
## 3    3    1     4 0.125 0.125</code></pre>
<p>Multiplizieren liefert die Wahrscheinlichkeiten für die
Augensummen.</p>
<pre class="r"><code>rolls$prob &lt;- rolls$prob1 * rolls$prob2
head(rolls, 3)</code></pre>
<pre><code>##   Var1 Var2 value prob1 prob2     prob
## 1    1    1     2 0.125 0.125 0.015625
## 2    2    1     3 0.125 0.125 0.015625
## 3    3    1     4 0.125 0.125 0.015625</code></pre>
<p>Der Erwartungswert ist jetzt die Summe der Werte multipliziert mit
der Eintrittswahrscheinlichkeit.</p>
<pre class="r"><code>sum(rolls$value * rolls$prob)</code></pre>
<pre><code>## [1] 8.25</code></pre>
<p>8.25 ist der Erwartungswert unseres unfairen Paarwurfes. Für faire
Würfel ist er 7.</p>
<p>Lass uns jetzt den Erwartungswert für die Slot Maschine
berechnen.</p>
<p><strong>Aufgabe</strong> Kombinationen für <em>slot machine</em>
bestimmen.</p>
<p>Wir brauchen wieder <code>expand.grid</code> für unsere 3
Kombinationsmöglichkeiten aus dem <code>wheel</code> Vektor.</p>
<pre class="r"><code>wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;)</code></pre>
<p>Verhindere durch <code>stringsAsFactors = FALSE</code>, dass die
Kombinationen als Faktoren gespeichert werden.</p>
<p>Gebe jetzt <code>expand.grid</code> drei Kopien von
<code>wheel</code>.</p>
<pre class="r"><code>combos &lt;- expand.grid(wheel, wheel, wheel, stringsAsFactors = FALSE)
head(combos)</code></pre>
<pre><code>##   Var1 Var2 Var3
## 1   DD   DD   DD
## 2    7   DD   DD
## 3  BBB   DD   DD
## 4   BB   DD   DD
## 5    B   DD   DD
## 6    C   DD   DD</code></pre>
<pre class="r"><code>tail(combos)</code></pre>
<pre><code>##     Var1 Var2 Var3
## 338    7    0    0
## 339  BBB    0    0
## 340   BB    0    0
## 341    B    0    0
## 342    C    0    0
## 343    0    0    0</code></pre>
<p>Folgende Wahrscheinlichkeiten gelten für unsere <em>slot
machine</em>.</p>
<pre class="r"><code>get_symbols &lt;- function() {
  wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;)
  sample(wheel, size = 3, replace = TRUE, 
    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))
}</code></pre>
<p><strong>Aufgabe</strong> Baue eine Look-Up Tabelle.<br />
Haben wir schon einmal gemacht. Dafür brauchen wir Namen für unsere
Wahrscheinlichkeiten.</p>
<pre class="r"><code>prob &lt;- c(&quot;DD&quot; = 0.03, &quot;7&quot; = 0.03, &quot;BBB&quot; = 0.06, 
  &quot;BB&quot; = 0.1, &quot;B&quot; = 0.25, &quot;C&quot; = 0.01, &quot;0&quot; = 0.52)</code></pre>
<p>Füge die Wahrscheinlichkeiten der Tabelle hinzu.</p>
<pre class="r"><code>combos$prob1 &lt;- prob[combos$Var1]
combos$prob2 &lt;- prob[combos$Var2]
combos$prob3 &lt;- prob[combos$Var3]

head(combos, 3)</code></pre>
<pre><code>##   Var1 Var2 Var3 prob1 prob2 prob3
## 1   DD   DD   DD  0.03  0.03  0.03
## 2    7   DD   DD  0.03  0.03  0.03
## 3  BBB   DD   DD  0.06  0.03  0.03</code></pre>
<pre class="r"><code>dim(combos)</code></pre>
<pre><code>## [1] 343   6</code></pre>
<p><strong>Aufgabe</strong> Berechne Wahrscheinlichkeiten für alle
Kombinationen.</p>
<p>Wieder müssen wir das Produkt der Eizelwahrscheinlichkeiten
berechnen, da diese unabhängig voneinander sind.</p>
<pre class="r"><code>combos$prob &lt;- combos$prob1 * combos$prob2 * combos$prob3

head(combos, 3)</code></pre>
<pre><code>##   Var1 Var2 Var3 prob1 prob2 prob3    prob
## 1   DD   DD   DD  0.03  0.03  0.03 2.7e-05
## 2    7   DD   DD  0.03  0.03  0.03 2.7e-05
## 3  BBB   DD   DD  0.06  0.03  0.03 5.4e-05</code></pre>
<pre class="r"><code>sum(combos$prob)</code></pre>
<pre><code>## [1] 1</code></pre>
<p>Jetzt müssen wir den Preis natürlich noch bestimmen. Für die erste
Reihe zum Beispiel.</p>
<pre class="r"><code>symbols &lt;- c(combos[1, 1], combos[1, 2], combos[1, 3])
score(symbols)</code></pre>
<pre><code>## [1] 800</code></pre>
<p>Insgesamt gibt es aber 343 Zeilen. Wir brauchen eine <code>for</code>
Schleife.</p>
</div>
<div id="for-loop-for-schleife" class="section level2" number="9.3">
<h2><span class="header-section-number">9.3</span> <em>for Loop</em> /
for-Schleife</h2>
<p>Eine <code>for</code> Schleife wiederholt einen Batzen Code viele
Male für ein Element in einer Menge. Die Syntax in R sieht so aus.</p>
<pre class="r"><code>for (value in that) {
  this
}</code></pre>
<p>Für jedes Mitglied der Menge <code>that</code> wird der Code zwischen
den geschweiften Klammern ausgeführt. Im folgenden Beispiel wird der
<code>print</code> Befehl für jedes Element der Menge (<em>Character
Strings</em>) ausgeführt. Also hier genau 4 mal.</p>
<pre class="r"><code>for (value in c(&quot;My&quot;, &quot;first&quot;, &quot;for&quot;, &quot;loop&quot;)) {
  print(&quot;one run&quot;)
}</code></pre>
<pre><code>## [1] &quot;one run&quot;
## [1] &quot;one run&quot;
## [1] &quot;one run&quot;
## [1] &quot;one run&quot;</code></pre>
<p>Natürlich kannst du auch direkt den <code>value</code> ausgeben
lassen. Er nimmt jeden Wert der Menge an, die hinter <code>in</code>
steht.</p>
<pre class="r"><code>for (value in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) {
  print(value)
}</code></pre>
<pre><code>## [1] &quot;My&quot;
## [1] &quot;second&quot;
## [1] &quot;for&quot;
## [1] &quot;loop&quot;</code></pre>
<pre class="r"><code>value</code></pre>
<pre><code>## [1] &quot;loop&quot;</code></pre>
<p>Der <code>value</code> hat am Ende immer noch den Namen des letzten
Elements unserer Menge: “loop”.</p>
<p>Du musst nicht den Namen <code>value</code> nehmen, sondern kannst
jeden beliebigen anderen Namen wählen.</p>
<pre class="r"><code>for (word in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) {
  print(word)
}</code></pre>
<pre><code>## [1] &quot;My&quot;
## [1] &quot;second&quot;
## [1] &quot;for&quot;
## [1] &quot;loop&quot;</code></pre>
<pre class="r"><code>for (string in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) {
  print(string)
}</code></pre>
<pre><code>## [1] &quot;My&quot;
## [1] &quot;second&quot;
## [1] &quot;for&quot;
## [1] &quot;loop&quot;</code></pre>
<pre class="r"><code>for (i in c(&quot;My&quot;, &quot;second&quot;, &quot;for&quot;, &quot;loop&quot;)) {
  print(i)
}</code></pre>
<pre><code>## [1] &quot;My&quot;
## [1] &quot;second&quot;
## [1] &quot;for&quot;
## [1] &quot;loop&quot;</code></pre>
<p>Wir können jetzt eine <code>for</code> Schleife anwenden, um für jede
Zeile in <code>combos</code> den <code>score</code> zu berechnen. Du
musst das Ergebnis aber vorsichtig abspeichern.</p>
<pre class="r"><code>for (value in c(&quot;My&quot;, &quot;third&quot;, &quot;for&quot;, &quot;loop&quot;)) {
  value
}</code></pre>
<p>Nichts wird hier ausgegeben, da das <code>print</code> fehlt. Während
die Schleife läuft, musst du die Outputs abspeichern.<br />
Zum Beispiel kannst du einen leeren Vektor erzeugen und ihn dann während
des Durchlaufens befüllen.</p>
<pre class="r"><code>chars &lt;- vector(length = 4)
words &lt;- c(&quot;My&quot;, &quot;fourth&quot;, &quot;for&quot;, &quot;loop&quot;)

for (i in 1:4) {
  chars[i] &lt;- words[i]
}

chars</code></pre>
<pre><code>## [1] &quot;My&quot;     &quot;fourth&quot; &quot;for&quot;    &quot;loop&quot;</code></pre>
<p>Anstatt auf eine Menge von Objekten deine Schleife auszuführen, führe
sie auf ganzen Zahlen aus, und indiziere auf dein Objekt und deinen
Speicher-Vektor.</p>
<p>Fügen wir <code>combos</code> einen Vektor mit <code>NA</code>s
hinzu.</p>
<p><strong>Aufgabe</strong> Bilde eine Schleife.</p>
<pre class="r"><code>for (i in 1:nrow(combos)) {
  symbols &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3])
  combos$prize[i] &lt;- score(symbols)
}</code></pre>
<p>Nach dem Ausführen der Schleife, enthält <code>combos$prize</code>
den korrekten Preis für jede Zeile.</p>
<pre class="r"><code>head(combos, 3)</code></pre>
<pre><code>##   Var1 Var2 Var3 prob1 prob2 prob3    prob prize
## 1   DD   DD   DD  0.03  0.03  0.03 2.7e-05   800
## 2    7   DD   DD  0.03  0.03  0.03 2.7e-05     0
## 3  BBB   DD   DD  0.06  0.03  0.03 5.4e-05     0</code></pre>
<p>Der Erwartungswert kann endlich berechnet werden. Er ist die Summe
von <code>combos$prize</code>, gewichtet mit
<code>combos$prob</code>.</p>
<pre class="r"><code>sum(combos$prize * combos$prob)</code></pre>
<pre><code>## [1] 0.538014</code></pre>
<p>Auf einen Dollar holen wir also 54 Cents raus. Kein guter Deal,
oder?<br />
Etwas haben wir aber vergessen. <code>DD</code> ist ein Joker.</p>
<p>Ignorieren wir es: 54 Cents. Ohne ignorieren: 93 Cents.</p>
<p><strong>Aufgabe</strong> Challenge.</p>
<pre class="r"><code>score &lt;- function(symbols) {
  
  diamonds &lt;- sum(symbols == &quot;DD&quot;)
  cherries &lt;- sum(symbols == &quot;C&quot;)
  
  # identify case
  # since diamonds are wild, only nondiamonds 
  # matter for three of a kind and all bars
  slots &lt;- symbols[symbols != &quot;DD&quot;]
  same &lt;- length(unique(slots)) == 1
  bars &lt;- slots %in% c(&quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;)

  # assign prize
  if (diamonds == 3) {
    prize &lt;- 100
  } else if (same) {
    payouts &lt;- c(&quot;7&quot; = 80, &quot;BBB&quot; = 40, &quot;BB&quot; = 25,
      &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
    prize &lt;- unname(payouts[slots[1]])
  } else if (all(bars)) {
    prize &lt;- 5
  } else if (cherries &gt; 0) {
    # diamonds count as cherries
    # so long as there is one real cherry
    prize &lt;- c(0, 2, 5)[cherries + diamonds + 1]
  } else {
    prize &lt;- 0
  }
  
  # double for each diamond
  prize * 2^diamonds
}</code></pre>
<p><strong>Aufgabe</strong> Berechne den Erwartungswert.</p>
<p>Berechne den Erwartungswert, wenn die neue <code>score</code>
Funktion genutzt wird.</p>
<pre class="r"><code>for (i in 1:nrow(combos)) {
  symbols &lt;- c(combos[i, 1], combos[i, 2], combos[i, 3])
  combos$prize[i] &lt;- score(symbols)
}
sum(combos$prize * combos$prob)</code></pre>
<pre><code>## [1] 0.934356</code></pre>
<p>Der Erwartungswert beträgt also 0.934356 Dollar.</p>
</div>
<div id="while-loops-while-schleifen." class="section level2"
number="9.4">
<h2><span class="header-section-number">9.4</span> <em>while Loops</em>
/ while-Schleifen.</h2>
<p>Eine <code>while</code> Schleife läuft so lange wiederholend durch,
wie sie <code>TRUE</code> ist.</p>
<pre class="r"><code>while (condition) {
  code
}</code></pre>
<p>So lange <code>condition</code> <code>TRUE</code> ist, läuft
<code>while</code> den Code zwischen den geschweiften Klammern. Wenn
<code>condition</code> zu <code>FALSE</code> wird, beendet die Schleife
ihren Job.</p>
<p>Wie wechselt die <code>condition</code> von <code>TRUE</code> zu
<code>FALSE</code>? Nur, wenn der Code in der Schleife sich verändert.
Ohne, musst du wohl ESC drücken.</p>
<p>Wie bei <code>for</code> Schleifen, geben <code>while</code>
Schleifen kein Ergebnis aus. Du musst wissen was die Schleife ausgeben
soll und es als Objekt speichern. Diese Art von Schleifen wird aber eher
selten angewendet.</p>
<pre class="r"><code>plays_till_broke &lt;- function(start_with) {
  cash &lt;- start_with
  n &lt;- 0
  while (cash &gt; 0) {
    cash &lt;- cash - 1 + play()
    n &lt;- n + 1
  }
  n
}

plays_till_broke(100)</code></pre>
<pre><code>## [1] 307</code></pre>
</div>
<div id="repeat-schleife-repeat-loop" class="section level2"
number="9.5">
<h2><span class="header-section-number">9.5</span> repeat-Schleife /
<em>repeat Loop</em></h2>
<p>Sie wiederholen einen Batzen Code, bis du ihnen sagst aufzuhören
(ESC), oder bis sie auf den <code>break</code> Befehl treffen. Dieser
stoppt die Schleife.<br />
Schreibe die Schleife von oben mithilfe von <code>repeat</code>.</p>
<pre class="r"><code>plays_till_broke &lt;- function(start_with) {
  cash &lt;- start_with
  n &lt;- 0
  repeat {
    cash &lt;- cash - 1 + play()
    n &lt;- n + 1
    if (cash &lt;= 0) {
      break
    }
  }
  n
}

plays_till_broke(100)</code></pre>
<pre><code>## [1] 539</code></pre>
</div>
</div>
<div id="speed" class="section level1" number="10">
<h1><span class="header-section-number">10</span> Speed</h1>
<p>Geschwindigkeit, wir brauchen Geschwindigkeit. Das Arbeiten mit
großen Datensätzen gelingt nur, wenn unser Code schnell durchläuft.
Dafür sorgen wir in diesem Kapitel.</p>
<div id="vektorisierter-code" class="section level2" number="10.1">
<h2><span class="header-section-number">10.1</span> Vektorisierter
Code</h2>
<p>Der schnellste Code in R macht sich drei Dinge zu Nutze:</p>
<ol style="list-style-type: decimal">
<li>Logical Tests</li>
<li>Subsetting</li>
<li>Elementweise Ausführung</li>
</ol>
<p>Vektorisierter Code hat die höchste Qualität!<br />
Er kann einen Vektor als <em>Input</em> nehmen, und gleichzeitig jeden
seiner Werte manipulieren. Vergleichen wir 2 Beispiele. Das erste
Beispiel benutzt eine <code>loop</code> Schleife, das zweite manipuliert
mithilfe von <em>logical Subsetting</em> jede negative Zahl im Vektor
zur selben Zeit.</p>
<pre class="r"><code>abs_loop &lt;- function(vec){
  for (i in 1:length(vec)) {
    if (vec[i] &lt; 0) {
      vec[i] &lt;- -vec[i]
    }
  }
  vec
}</code></pre>
<p>Ohne <code>for</code> Schleife.</p>
<pre class="r"><code>abs_sets &lt;- function(vec){
  negs &lt;- vec &lt; 0
  vec[negs] &lt;- vec[negs] * -1
  vec
}</code></pre>
<p><code>abs_set</code> ist viel schneller als <code>abs_loop</code>,
weil R diese Operationen schneller kann:<br />
<em>logical tests</em>, <em>subsetting</em> und <em>element-wise
execution</em>.<br />
Um zu sehen wie schnell <code>abs_set</code> ist, benutze
<code>system.time</code>. Schauen wir uns den Vergleich mithilfe eines
langen Vektors an.</p>
<pre class="r"><code>long &lt;- rep(c(-1, 1), 5000000)</code></pre>
<p>So erstellen wir einen Vektor der Länge 10 Mio., wobei sich immer -1
und +1 abwechseln.</p>
<pre class="r"><code>system.time(abs_loop(long))</code></pre>
<pre><code>##        User      System verstrichen 
##        3.15        0.08        7.48</code></pre>
<pre class="r"><code>system.time(abs_sets(long))</code></pre>
<pre><code>##        User      System verstrichen 
##        0.90        0.19        3.05</code></pre>
<p>Die letzte Spalte zeigt, dass <code>abs_set</code> den absoluten Wert
30 mal schneller berechnet hat als <code>abs_loop</code>.</p>
<p><strong>Aufgabe</strong> Wie schnell ist <code>abs</code>?<br />
Viele Funktionen in R sind bereits vektorisiert und so optimiert, um so
schnell wie möglich zu laufen. Die <code>abs</code> Funktion zum
Beispiel. Überprüfe wie viel schneller <code>abs</code> den Betrag
berechnet, als die anderen Funktionen.</p>
<p>Ca. 11 mal schneller als <code>abs_set</code> und 300 mal schneller
als <code>abs_loop</code>.</p>
<pre class="r"><code>system.time(abs(long))</code></pre>
<pre><code>##        User      System verstrichen 
##        0.04        0.08        0.30</code></pre>
</div>
<div id="wie-schreibe-ich-vektorisierten-code" class="section level2"
number="10.2">
<h2><span class="header-section-number">10.2</span> Wie schreibe ich
vektorisierten Code?</h2>
<ol style="list-style-type: decimal">
<li>Benutze verktorisierte Funktionen<br />
</li>
<li>Benutze <em>subsetting</em>. Versuche jedes Element auf einmal zu
manipulieren.</li>
</ol>
<p>Alle Elemente, die wir mit -1 multiplizieren, können wir über einen
<em>logial test</em> identifizieren.</p>
<pre class="r"><code>vec &lt;- c(1, -2, 3, -4, 5, -6, 7, -8, 9, -10)
vec &lt; 0</code></pre>
<pre><code>##  [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE</code></pre>
<pre class="r"><code>vec[vec &lt; 0]</code></pre>
<pre><code>## [1]  -2  -4  -6  -8 -10</code></pre>
<p>Alle in R verfügbaren arithmetischen Operatoren sind vektorisiert.
Wir brauchen also nur einfach alle negativen Werte mit -1 zur selben
Zeit zu multiplizieren.</p>
<pre class="r"><code>vec[vec &lt; 0] * -1</code></pre>
<pre><code>## [1]  2  4  6  8 10</code></pre>
<pre class="r"><code>vec[vec &lt; 0] &lt;- vec[vec &lt; 0] * -1
vec</code></pre>
<pre><code>##  [1]  1  2  3  4  5  6  7  8  9 10</code></pre>
<p><strong>Aufgabe</strong> Vektorisiere eine Funktion.</p>
<p>Folgende Funktion nimmt einen Vektor mit <em>slot</em> Symbolen und
ändert diese.</p>
<pre class="r"><code>change_symbols &lt;- function(vec){
  for (i in 1:length(vec)){
    if (vec[i] == &quot;DD&quot;) {
      vec[i] &lt;- &quot;joker&quot;
    } else if (vec[i] == &quot;C&quot;) {
      vec[i] &lt;- &quot;ace&quot;
    } else if (vec[i] == &quot;7&quot;) {
      vec[i] &lt;- &quot;king&quot;
    }else if (vec[i] == &quot;B&quot;) {
      vec[i] &lt;- &quot;queen&quot;
    } else if (vec[i] == &quot;BB&quot;) {
      vec[i] &lt;- &quot;jack&quot;
    } else if (vec[i] == &quot;BBB&quot;) {
      vec[i] &lt;- &quot;ten&quot;
    } else {
      vec[i] &lt;- &quot;nine&quot;
    } 
  }
  vec
}

vec &lt;- c(&quot;DD&quot;, &quot;C&quot;, &quot;7&quot;, &quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;, &quot;0&quot;)

change_symbols(vec)</code></pre>
<pre><code>## [1] &quot;joker&quot; &quot;ace&quot;   &quot;king&quot;  &quot;queen&quot; &quot;jack&quot;  &quot;ten&quot;   &quot;nine&quot;</code></pre>
<pre class="r"><code>many &lt;- rep(vec, 1000000)
system.time(change_symbols(many))</code></pre>
<pre><code>##        User      System verstrichen 
##       29.81        0.26       70.04</code></pre>
<p>Um die Aufgabe zu vektorisieren, baue einen <em>logical
test</em>.</p>
<pre class="r"><code>vec[vec == &quot;DD&quot;]
## &quot;DD&quot;

vec[vec == &quot;C&quot;]
## &quot;C&quot;

vec[vec == &quot;7&quot;]
## &quot;7&quot;

vec[vec == &quot;B&quot;]
## &quot;B&quot;

vec[vec == &quot;BB&quot;]
## &quot;BB&quot;

vec[vec == &quot;BBB&quot;]
## &quot;BBB&quot;

vec[vec == &quot;0&quot;]
## &quot;0&quot;</code></pre>
<p>Folgender Code ändert das Symbol für jeden Fall.</p>
<pre class="r"><code>vec[vec == &quot;DD&quot;] &lt;- &quot;joker&quot;
vec[vec == &quot;C&quot;] &lt;- &quot;ace&quot;
vec[vec == &quot;7&quot;] &lt;- &quot;king&quot;
vec[vec == &quot;B&quot;] &lt;- &quot;queen&quot;
vec[vec == &quot;BB&quot;] &lt;- &quot;jack&quot;
vec[vec == &quot;BBB&quot;] &lt;- &quot;ten&quot;
vec[vec == &quot;0&quot;] &lt;- &quot;nine&quot;</code></pre>
<p>Baue es in eine Funktion ein.</p>
<pre class="r"><code>change_vec &lt;- function (vec) {
  vec[vec == &quot;DD&quot;] &lt;- &quot;joker&quot;
  vec[vec == &quot;C&quot;] &lt;- &quot;ace&quot;
  vec[vec == &quot;7&quot;] &lt;- &quot;king&quot;
  vec[vec == &quot;B&quot;] &lt;- &quot;queen&quot;
  vec[vec == &quot;BB&quot;] &lt;- &quot;jack&quot;
  vec[vec == &quot;BBB&quot;] &lt;- &quot;ten&quot;
  vec[vec == &quot;0&quot;] &lt;- &quot;nine&quot;
  
  vec
}

system.time(change_vec(many))</code></pre>
<pre><code>##        User      System verstrichen 
##        1.44        0.26        4.55</code></pre>
<p>Besser sind natürlich immer <em>Look-Up</em> Tabellen.</p>
<pre class="r"><code>change_vec2 &lt;- function(vec){
  tb &lt;- c(&quot;DD&quot; = &quot;joker&quot;, &quot;C&quot; = &quot;ace&quot;, &quot;7&quot; = &quot;king&quot;, &quot;B&quot; = &quot;queen&quot;, 
    &quot;BB&quot; = &quot;jack&quot;, &quot;BBB&quot; = &quot;ten&quot;, &quot;0&quot; = &quot;nine&quot;)
  unname(tb[vec])
}

system.time(change_vec(many))</code></pre>
<pre><code>##        User      System verstrichen 
##        1.36        0.26        4.77</code></pre>
</div>
<div id="wie-schnelle-for-loops-schreiben" class="section level2"
number="10.3">
<h2><span class="header-section-number">10.3</span> Wie schnelle
<code>for Loops</code> schreiben?</h2>
<p>Zuerst kannst du Schleifen beschleunigen, indem du soviel wie möglich
außerhalb der Schleife schreibst. Weil alles innerhalb natürlich viele
Male durchläuft.<br />
Gehe sicher, dass dein Objekt in der Schleife, in dem du alle
Informationen speicherst, groß genug ist.<br />
Das Objekt <code>output</code> hat schon eine Länge von 1 Mio.</p>
<pre class="r"><code>system.time({
  output &lt;- rep(NA, 1000000) 
  for (i in 1:1000000) {
    output[i] &lt;- i + 1
  }
})</code></pre>
<pre><code>##        User      System verstrichen 
##        0.25        0.02        0.95</code></pre>
<p>Das Objekt der zweiten Schleife hat beim Start eine Länge von 1. R
verlängert dieses Objek beim Laufen dann.</p>
<pre class="r"><code>system.time({
  output &lt;- NA 
  for (i in 1:1000000) {
    output[i] &lt;- i + 1
  }
})</code></pre>
<pre><code>##        User      System verstrichen 
##        0.79        0.16        2.52</code></pre>
<p>Im zweiten Fall muss R immer einen neues Platz im <em>Memory</em> des
Computers finden. Der alte Vektor wird gelöscht, nachdem eine neue Kopie
entstanden ist: 1 Mio. mal.</p>
</div>
<div id="vektorisierter-code-in-der-praxis" class="section level2"
number="10.4">
<h2><span class="header-section-number">10.4</span> Vektorisierter Code
in der Praxis</h2>
<p>In unserem <em>slot machine</em> Beispiel kann der Durchschnittspreis
leicht berechnet werden, indem wir die Maschine sehr oft laufen
lassen.<br />
Dieser Preis ist eine gute Schätzung für die wahre Payout-Rate. Diese
Methode basiert auf dem Gesetz der großen Zahlen.</p>
<pre class="r"><code>winnings &lt;- vector(length = 1000000)
for (i in 1:1000000) {
  winnings[i] &lt;- play()
}

mean(winnings)</code></pre>
<pre><code>## [1] 0.925879</code></pre>
<p>Wenn du diese Simulation laufen lässt, dauert es sehr lange. Du
kannst die 5.7 Minuten deutlich reduzieren, indem du vektorisierten Code
benutzt.</p>
<pre class="r"><code>system.time(for (i in 1:1000000) {
  winnings[i] &lt;- play()
})</code></pre>
<pre><code>##        User      System verstrichen 
##      151.75        4.55      223.61</code></pre>
<p>Statt <code>if</code> Baum und <code>for</code> Kombination, könntest
du verktorisierten Code benutzen. Es werden viele Kombinationen
ausgegeben, auf die du dann mit <em>logical subsetting</em> zugreifen
kannst. Auf alle gleichzeitig.<br />
In unserem Fall erhalten wir eine Matrix mit n Zeilen und 3 Spalten.
Jede Zeile enthält eine <em>slot</em> Kombination.</p>
<pre class="r"><code>get_many_symbols &lt;- function(n) {
  wheel &lt;- c(&quot;DD&quot;, &quot;7&quot;, &quot;BBB&quot;, &quot;BB&quot;, &quot;B&quot;, &quot;C&quot;, &quot;0&quot;)
  vec &lt;- sample(wheel, size = 3 * n, replace = TRUE,
    prob = c(0.03, 0.03, 0.06, 0.1, 0.25, 0.01, 0.52))
  matrix(vec, ncol = 3)
}

get_many_symbols(5)</code></pre>
<pre><code>##      [,1]  [,2] [,3] 
## [1,] &quot;0&quot;   &quot;B&quot;  &quot;BBB&quot;
## [2,] &quot;DD&quot;  &quot;7&quot;  &quot;B&quot;  
## [3,] &quot;0&quot;   &quot;B&quot;  &quot;BB&quot; 
## [4,] &quot;BBB&quot; &quot;0&quot;  &quot;0&quot;  
## [5,] &quot;0&quot;   &quot;DD&quot; &quot;BB&quot;</code></pre>
<p>Du kannst auch <code>play</code> neu schreiben mit n als Argument.
Als Ausgabe erhälst du <code>n</code> Preise in einem <em>Data
Frame</em>.</p>
<pre class="r"><code>play_many &lt;- function(n) {
  symb_mat &lt;- get_many_symbols(n = n)
  data.frame(w1 = symb_mat[,1], w2 = symb_mat[,2],
             w3 = symb_mat[,3], prize = score_many(symb_mat))
}</code></pre>
<p>Jetzt schreibe die komplizierte Funktion <code>score_many</code>, die
vektorisierte Version von <code>score</code>. <code>rowSums</code>
berechnet die Summe jeder Zeile von Zahlen (oder <em>logicals</em>). Sie
hilft dir hier.</p>
<p>Überlege dir ein konkretes Beispiel.</p>
<pre class="r"><code>symbols &lt;- matrix(
  c(&quot;DD&quot;, &quot;DD&quot;, &quot;DD&quot;, 
    &quot;C&quot;, &quot;DD&quot;, &quot;0&quot;, 
    &quot;B&quot;, &quot;B&quot;, &quot;B&quot;, 
    &quot;B&quot;, &quot;BB&quot;, &quot;BBB&quot;, 
    &quot;C&quot;, &quot;C&quot;, &quot;0&quot;, 
    &quot;7&quot;, &quot;DD&quot;, &quot;DD&quot;), nrow = 6, byrow = TRUE)

symbols</code></pre>
<pre><code>##      [,1] [,2] [,3] 
## [1,] &quot;DD&quot; &quot;DD&quot; &quot;DD&quot; 
## [2,] &quot;C&quot;  &quot;DD&quot; &quot;0&quot;  
## [3,] &quot;B&quot;  &quot;B&quot;  &quot;B&quot;  
## [4,] &quot;B&quot;  &quot;BB&quot; &quot;BBB&quot;
## [5,] &quot;C&quot;  &quot;C&quot;  &quot;0&quot;  
## [6,] &quot;7&quot;  &quot;DD&quot; &quot;DD&quot;</code></pre>
<p>Dann kannst du jede Zeile von <code>score_many</code> durchlaufen
lassen.</p>
<p><strong>Aufgabe</strong> Teste dich.</p>
<p>Schreibe deine eigenen vektorisierte Version von <code>score</code>.
Gehe davon aus, dass die Daten in einer <span class="math inline">\(n
\times 3\)</span>-Matrix gespeichert werden.<br />
Jede Zeile stellt naürlich eine Kombination von Symbolen dar.</p>
<p><code>score_many</code> ist die vektorisierte Version von
<code>score</code>. Sie läuft ca. 20 Sekunden und ist so 17 mal
schneller als die <code>for</code>-Schleife.</p>
<pre class="r"><code># symbols should be a matrix with a column for each slot machine window
score_many &lt;- function(symbols) {

  # Step 1: Assign base prize based on cherries and diamonds ---------
  ## Count the number of cherries and diamonds in each combination
  cherries &lt;- rowSums(symbols == &quot;C&quot;)
  diamonds &lt;- rowSums(symbols == &quot;DD&quot;) 
  
  ## Wild diamonds count as cherries
  prize &lt;- c(0, 2, 5)[cherries + diamonds + 1]
  
  ## ...but not if there are zero real cherries 
  ### (cherries is coerced to FALSE where cherries == 0)
  prize[!cherries] &lt;- 0
  
  # Step 2: Change prize for combinations that contain three of a kind 
  same &lt;- symbols[, 1] == symbols[, 2] &amp; 
    symbols[, 2] == symbols[, 3]
  payoffs &lt;- c(&quot;DD&quot; = 100, &quot;7&quot; = 80, &quot;BBB&quot; = 40, 
    &quot;BB&quot; = 25, &quot;B&quot; = 10, &quot;C&quot; = 10, &quot;0&quot; = 0)
  prize[same] &lt;- payoffs[symbols[same, 1]]
  
  # Step 3: Change prize for combinations that contain all bars ------
  bars &lt;- symbols == &quot;B&quot; | symbols ==  &quot;BB&quot; | symbols == &quot;BBB&quot;
  all_bars &lt;- bars[, 1] &amp; bars[, 2] &amp; bars[, 3] &amp; !same
  prize[all_bars] &lt;- 5
  
  # Step 4: Handle wilds ---------------------------------------------
  
  ## combos with two diamonds
  two_wilds &lt;- diamonds == 2

  ### Identify the nonwild symbol
  one &lt;- two_wilds &amp; symbols[, 1] != symbols[, 2] &amp; 
    symbols[, 2] == symbols[, 3]
  two &lt;- two_wilds &amp; symbols[, 1] != symbols[, 2] &amp; 
    symbols[, 1] == symbols[, 3]
  three &lt;- two_wilds &amp; symbols[, 1] == symbols[, 2] &amp; 
    symbols[, 2] != symbols[, 3]
  
  ### Treat as three of a kind
  prize[one] &lt;- payoffs[symbols[one, 1]]
  prize[two] &lt;- payoffs[symbols[two, 2]]
  prize[three] &lt;- payoffs[symbols[three, 3]]
  
  ## combos with one wild
  one_wild &lt;- diamonds == 1
  
  ### Treat as all bars (if appropriate)
  wild_bars &lt;- one_wild &amp; (rowSums(bars) == 2)
  prize[wild_bars] &lt;- 5
  
  ### Treat as three of a kind (if appropriate)
  one &lt;- one_wild &amp; symbols[, 1] == symbols[, 2]
  two &lt;- one_wild &amp; symbols[, 2] == symbols[, 3]
  three &lt;- one_wild &amp; symbols[, 3] == symbols[, 1]
  prize[one] &lt;- payoffs[symbols[one, 1]]
  prize[two] &lt;- payoffs[symbols[two, 2]]
  prize[three] &lt;- payoffs[symbols[three, 3]]
 
  # Step 5: Double prize for every diamond in combo ------------------
  unname(prize * 2^diamonds)
  
}

system.time(play_many(10000000))</code></pre>
<pre><code>##        User      System verstrichen 
##       16.90        6.89       31.66</code></pre>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // temporarily add toc-ignore selector to headers for the consistency with Pandoc
    $('.unlisted.unnumbered').addClass('toc-ignore')

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_');
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = true;
    options.smoothScroll = true;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
